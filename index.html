<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiro no Metrô</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Fonte padrão, mas Press Start 2P para elementos do jogo */
            background-color: #1a202c; /* Cor de fundo escura */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Evita barras de rolagem */
        }

        .game-master-wrapper {
            display: flex;
            flex-direction: column; /* Empilha os contêineres verticalmente */
            border-radius: 1.5rem; /* Cantos mais arredondados para o wrapper geral */
            overflow: hidden; /* Garante que o conteúdo respeite o border-radius */
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.7); /* Sombra mais forte para profundidade */
            border: 4px solid #4a5568; /* Borda mais grossa */
            width: 400px; /* Largura fixa para a área total do jogo */
            height: 700px; /* Altura fixa para a área total do jogo */
            max-width: 95vw; /* Garante que caiba em telas menores */
            max-height: 95vh; /* Garante que caiba em telas menores */
            background-color: #2d3748; /* Fundo para o próprio wrapper */
            position: relative; /* Para sobreposição da tela inicial */
        }

        /* Novo layout principal do jogo */
        .main-game-layout {
            display: flex;
            flex-grow: 1; /* Permite que ocupe o espaço restante */
            width: 100%;
            height: 100%; /* Ocupa toda a altura disponível dentro do wrapper */
        }

        /* Contêineres laterais para barras de vida/escudo */
        .sidebar-container {
            width: 25px; /* Largura das barras laterais (ainda mais fina) */
            background-color: #1a202c;
            display: flex;
            flex-direction: column; /* Barras verticais */
            align-items: center;
            padding: 0.5rem 0.2rem;
            flex-shrink: 0;
            z-index: 10;
            position: relative; /* Para posicionamento de ícones e texto */
        }

        .left-sidebar {
            border-right: 2px solid #4a5568;
            box-shadow: inset -3px 0 5px rgba(0,0,0,0.3);
        }

        .right-sidebar {
            border-left: 2px solid #4a5568;
            box-shadow: inset 3px 0 5px rgba(0,0,0,0.3);
        }

        .sidebar-bar-wrapper {
            width: 100%;
            flex-grow: 1; /* Ocupa o espaço vertical disponível */
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* Preenche de baixo para cima */
            align-items: center;
            margin-top: 1rem; /* Espaço do topo */
            margin-bottom: 1rem; /* Espaço da base */
            position: relative;
        }

        .vertical-bar {
            width: 15px; /* Largura da barra vertical */
            height: 100%; /* Altura total do wrapper */
            background-color: #555;
            border-radius: 7.5px; /* Metade da largura para cantos arredondados */
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255,255,255,0.2);
            display: flex; /* Para centralizar o texto */
            align-items: flex-end; /* Para o preenchimento subir */
        }

        .vertical-fill {
            width: 100%;
            background-color: #f6e05e; /* Amarelo para vida normal */
            transition: height 0.2s ease-out, background-color 0.2s ease-out;
            position: absolute;
            bottom: 0; /* Começa do fundo */
        }

        .vertical-overshield-fill { /* NOVO: Estilo para a barra de sobrevida */
            width: 100%;
            background-color: #8A2BE2; /* Roxo vibrante para sobrevida */
            transition: height 0.2s ease-out;
            position: absolute;
            bottom: 0;
            z-index: 1; /* Acima do preenchimento normal, abaixo do texto */
        }

        .vertical-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg); /* Gira e centraliza o texto */
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 2;
            white-space: nowrap;
        }

        .sidebar-icon {
            font-size: 1.2rem;
            color: #cbd5e0;
            margin-bottom: 0.5rem;
        }

        /* Contêiner da área do jogo (agora central) */
        .game-area-wrapper {
            flex-grow: 1; /* Ocupa o espaço central restante */
            display: flex;
            flex-direction: column;
            position: relative; /* Para posicionar elementos internos */
        }

        /* Novo contêiner superior para Dano e Nível */
        .top-info-container {
            width: 100%;
            background-color: #1a202c;
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-between; /* Espaço entre os itens */
            align-items: center;
            color: #cbd5e0;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            flex-shrink: 0;
            border-bottom: 2px solid #4a5568;
            box-shadow: inset 0 -3px 5px rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* Contêiner do jogo em si (o que rolava antes) */
        .game-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Ocupa o espaço restante entre top e bottom info */
            overflow: hidden;
            /* REMOVIDO: transition: filter 0.5s ease-in-out; */
        }

        /* Novo contêiner inferior para Progresso do Boss e Pontos */
        .bottom-info-container {
            width: 100%;
            background-color: #1a202c;
            padding: 0.8rem 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            color: #cbd5e0;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            flex-shrink: 0;
            border-top: 2px solid #4a5568;
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* Estilos existentes (mantidos e ajustados) */
        .background-segment {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('https://i.ibb.co/fYVsCnG4/file-000000003bdc622f9c39eafbf705cd33.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 0;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
            transition: filter 0.5s ease-in-out; /* Adicionado para transição suave */
        }

        .background-segment.rotated-180 {
            transform: rotate(180deg);
        }

        .player {
            position: absolute;
            bottom: 20px;
            width: 60px;
            height: 60px;
            background-image: url('https://i.ibb.co/mrgQRnPP/file-00000000bd8861f8b1feda6cccc966af.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            left: calc(50% - 30px);
            box-shadow: 0 0 15px 5px rgba(99, 179, 237, 0.9), 0 0 25px 10px rgba(99, 179, 237, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 7;
            transition: filter 0.1s ease-out;
            /* REMOVIDO: filter: hue-rotate(...) para não ser afetado pelo estágio */
        }

        .player.player-hit-effect {
            filter: invert(100%) hue-rotate(180deg);
        }

        .player.player-shield-active {
            filter: hue-rotate(200deg) brightness(1.2);
            box-shadow: 0 0 20px 8px rgba(0, 0, 255, 0.9), 0 0 30px 15px rgba(0, 0, 255, 0.5);
        }

        .bullet {
            position: absolute;
            background-color: #f6e05e;
            width: 8px;
            height: 20px;
            border-radius: 0.25rem;
            box-shadow: 0 0 8px 3px rgba(246, 224, 94, 0.9), 0 0 15px 5px rgba(246, 224, 94, 0.5);
            z-index: 5;
        }

        .falling-object {
            position: absolute;
            top: -60px;
            width: 60px;
            height: 60px;
            background-image: url('https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: filter 0.1s ease-out;
            z-index: 2;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
        }

        .falling-object.enemy-hit-effect {
            filter: brightness(200%) saturate(200%);
        }

        .falling-object.heavy-enemy {
            width: 72px;
            height: 72px;
            z-index: 6;
        }

        .enemy-health-bar-wrapper {
            position: absolute;
            width: 100%;
            top: -15px;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3;
        }

        .enemy-health-bar {
            width: 80%;
            height: 5px;
            background-color: #555;
            border-radius: 2.5px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .enemy-health-fill {
            height: 100%;
            background-color: #48bb78;
            width: 100%;
            transition: width 0.1s ease-out, background-color 0.1s ease-out;
        }

        .power-up, .debuff {
            position: absolute;
            width: 36px; /* 20% maior */
            height: 36px; /* 20% maior */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            z-index: 6;
            animation: pulse 1s infinite alternate, neon-glow 1.5s infinite alternate; /* Efeito neon */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /* REMOVIDO: hue-rotate(${-currentStageHueRotation}deg) */
            filter: saturate(200%) brightness(150%); /* Apenas saturação e brilho para neon */
        }

        @keyframes pulse {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes neon-glow {
            0% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px var(--neon-color, #00f), 0 0 15px var(--neon-color, #00f); }
            50% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px var(--neon-color, #00f), 0 0 30px var(--neon-color, #00f); }
            100% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px var(--neon-color, #00f), 0 0 15px var(--neon-color, #00f); }
        }

        .game-over-screen, .start-screen, .stage-clear-screen, .pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            z-index: 30;
            border-radius: 1.5rem;
        }

        .start-screen {
            background-image: url('https://i.ibb.co/JjxJVM6D/1753025379623.png'); /* NOVA IMAGEM DE TELA INICIAL */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .start-screen h1, .start-screen p {
            color: #f6e05e; /* Garante que o texto seja visível sobre a imagem */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); /* Adiciona sombra para legibilidade */
        }

        /* Estilo para o texto "PRESS START" piscando */
        #pressStartText {
            font-size: 1.5rem; /* Tamanho ajustado */
            color: #f6e05e;
            text-shadow: 0 0 8px rgba(246, 224, 94, 0.8);
            animation: blink 1s infinite;
            margin-top: 20px; /* Adiciona um pouco de espaço */
        }

        @keyframes blink {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .pause-screen {
            background-image: url('https://i.ibb.co/JjxJVM6D/1753025379623.png'); /* MESMA IMAGEM DA TELA INICIAL */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Estilo para o texto "CONTINUAR" na tela de pausa */
        #pauseContinueText {
            font-size: 1.5rem; /* Tamanho ajustado */
            color: #f6e05e;
            text-shadow: 0 0 8px rgba(246, 224, 94, 0.8);
            margin-bottom: 20px; /* Espaço para o botão */
        }


        .game-over-screen h1, .start-screen h1, .stage-clear-screen h1, .pause-screen h1 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #f6e05e;
            text-shadow: 0 0 10px rgba(246, 224, 94, 0.8);
        }

        .game-over-screen p, .stage-clear-screen p, .pause-screen p {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .restart-button, .start-button, .continue-button, .pause-button-style, .resume-button { /* Renomeado para evitar conflito com ID */
            background-color: #48bb78;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 12px rgba(72, 187, 120, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .restart-button:hover, .start-button:hover, .continue-button:hover, .pause-button-style:hover, .resume-button:hover {
            background-color: #38a169;
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(72, 187, 120, 0.6);
        }

        .restart-button:active, .start-button:active, .continue-button:active, .pause-button-style:active, .resume-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(72, 187, 120, 0.4);
        }

        .hidden {
            display: none;
        }

        .boss {
            position: absolute;
            top: 50px;
            width: 100px;
            height: 100px;
            background-image: url('https://i.ibb.co/WWJbQ2xC/file-0000000084d061f8ac4929730520d69e.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 8;
            transition: filter 0.1s ease-out;
        }

        .boss-health-bar-wrapper {
            position: absolute;
            width: 100px;
            z-index: 9;
        }

        .boss-health-bar {
            width: 100%;
            height: 15px;
            background-color: #555;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .boss-health-fill {
            height: 100%;
            background-color: #48bb78;
            width: 100%;
            transition: width 0.2s ease-out;
        }

        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 2;
            white-space: nowrap;
            line-height: 1;
        }

        .boss-bullet {
            position: absolute;
            background-image: url('https://placehold.co/15x15/ff0000/FFFFFF/png?text=B');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            box-shadow: 0 0 10px 3px rgba(255, 0, 0, 0.8);
            z-index: 4;
        }

        .enemy-bullet {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            z-index: 4;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .enemy-bullet-color {
            background-color: #ffcc00;
            box-shadow: 0 0 8px 2px rgba(255, 204, 0, 0.7);
        }

        .enemy-bullet.heavy-enemy-bullet {
            width: 24px; /* AUMENTADO PARA 24px */
            height: 24px; /* AUMENTADO PARA 24px */
        }
        .heavy-enemy-bullet-color {
            background-color: #FF4500; /* Laranja avermelhado vibrante */
            box-shadow: 0 0 15px 6px rgba(255, 69, 0, 0.9), 0 0 25px 10px rgba(255, 69, 0, 0.6); /* Brilho mais intenso */
        }

        .obstacle {
            position: absolute;
            top: -50px;
            width: 45px;
            height: 45px;
            background-image: url('https://i.ibb.co/GQNYF8tQ/file-000000007a5c61f7ab26c44fcda85d3b.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
            z-index: 3;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
        }

        /* Botão de pausa flutuante na área do jogo */
        .pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20; /* Acima dos elementos do jogo, mas abaixo das telas de menu */
            background-color: rgba(246, 224, 94, 0.8); /* Amarelo semi-transparente */
            color: #1a202c;
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
        }
        .pause-button:hover {
            background-color: #f6e05e;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
        }
    </style>
</head>
<body>
    <div class="game-master-wrapper">
        <div class="main-game-layout">
            <!-- Left Sidebar for Shield Bar -->
            <div class="sidebar-container left-sidebar">
                <i class="fas fa-shield-alt sidebar-icon"></i>
                <div class="sidebar-bar-wrapper">
                    <div class="vertical-bar" id="shieldHealthBar">
                        <div class="vertical-fill" id="shieldHealthFill"></div>
                        <span class="vertical-text" id="shieldHealthText"></span>
                    </div>
                </div>
            </div>

            <div class="game-area-wrapper">
                <!-- Top Info Container for Player Stats -->
                <div class="top-info-container">
                    <div class="info-item">
                        <i class="fas fa-fist-raised"></i>
                        <span>Dano: <span id="playerDamageDisplay">1</span></span>
                    </div>
                    <div class="info-item">
                        <i class="fas fa-medal"></i>
                        <span>Nível: <span id="playerLevelDisplay">1</span></span>
                    </div>
                    <div class="info-item">
                        <i class="fas fa-star"></i>
                        <span>Pontos: <span id="scoreValue">0</span></span>
                    </div>
                </div>

                <div class="game-container" id="gameContainer">
                    <div class="background-segment" id="bgSegment1"></div>
                    <div class="background-segment" id="bgSegment2"></div>

                    <div class="player" id="player">
                    </div>

                    <div class="start-screen" id="startScreen">
                        <!-- Removido: <h1>TIRO NO METRÔ</h1> -->
                        <!-- Removido: <p>Clique para iniciar e entrar em tela cheia!</p> -->
                        <p id="pressStartText">PRESS START</p> <!-- Texto "PRESS START" piscando -->
                        <!-- Removido: <button class="start-button" id="startButton">INICIAR JOGO</button> -->
                    </div>

                    <div class="game-over-screen hidden" id="gameOverScreen">
                        <h1>FIM DE JOGO!</h1>
                        <p>Sua Pontuação: <span id="finalScore">0</span></p>
                        <button class="restart-button" id="restartButton">JOGAR NOVAMENTE</button>
                    </div>

                    <div class="stage-clear-screen hidden" id="stageClearScreen">
                        <h1>ESTÁGIO CONCLUÍDO!</h1>
                        <p>Pontuação do Estágio: <span id="stageScore">0</span></p>
                        <button class="continue-button" id="continueButton">CONTINUAR</button>
                    </div>

                    <div class="pause-screen hidden" id="pauseScreen">
                        <!-- Removido: <h1>PAUSADO</h1> -->
                        <!-- Removido: <p>O jogo está pausado.</p> -->
                        <p id="pauseContinueText">CONTINUAR</p> <!-- Texto "CONTINUAR" -->
                        <!-- Removido: <button class="resume-button" id="resumeButton">CONTINUAR JOGO</button> -->
                    </div>

                    <!-- Botão de Pausa movido para dentro de game-container -->
                    <button class="pause-button" id="pauseButton">PAUSAR</button>
                </div>

                <!-- Bottom Info Container for Boss Progress -->
                <div class="bottom-info-container">
                    <div class="boss-progress-container">
                        <i class="fas fa-dungeon"></i>
                        <span>Boss: <span id="bossProgressText">0 / 50</span></span>
                        <div class="boss-progress-bar">
                            <div class="boss-progress-fill" id="bossProgressFill"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar for Health Bar -->
            <div class="sidebar-container right-sidebar">
                <i class="fas fa-heart sidebar-icon"></i>
                <div class="sidebar-bar-wrapper">
                    <div class="vertical-bar" id="playerHealthBar">
                        <div class="vertical-fill" id="healthFill"></div>
                        <div class="vertical-overshield-fill" id="overshieldFill"></div> <!-- NOVO: Barra de sobrevida -->
                        <span class="vertical-text" id="playerHealthText"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Referências aos elementos DOM
        const gameContainer = document.getElementById('gameContainer');
        const player = document.getElementById('player');
        const scoreValueDisplay = document.getElementById('scoreValue'); 
        const playerDamageDisplay = document.getElementById('playerDamageDisplay'); 
        const playerLevelDisplay = document.getElementById('playerLevelDisplay'); 
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const startScreen = document.getElementById('startScreen');
        // const startButton = document.getElementById('startButton'); // REMOVIDO
        const stageClearScreen = document.getElementById('stageClearScreen'); 
        const continueButton = document.getElementById('continueButton');   
        const pauseButton = document.getElementById('pauseButton'); 
        const pauseScreen = document.getElementById('pauseScreen'); 
        // const resumeButton = document.getElementById('resumeButton'); // REMOVIDO

        // Referências aos novos elementos da UI
        const playerHealthBar = document.getElementById('playerHealthBar'); 
        const healthFill = document.getElementById('healthFill'); 
        const overshieldFill = document.getElementById('overshieldFill'); 
        const playerHealthText = document.getElementById('playerHealthText'); 

        const shieldHealthBar = document.getElementById('shieldHealthBar'); 
        const shieldHealthFill = document.getElementById('shieldHealthFill');
        const shieldHealthText = document.getElementById('shieldHealthText');

        const bossProgressText = document.getElementById('bossProgressText');
        const bossProgressFill = document.getElementById('bossProgressFill');

        // Referências aos novos elementos de texto da UI
        const pressStartText = document.getElementById('pressStartText'); 
        const pauseContinueText = document.getElementById('pauseContinueText'); 

        // Segmentos de fundo
        const bgSegment1 = document.getElementById('bgSegment1');
        const bgSegment2 = document.getElementById('bgSegment2');
        const backgroundSegments = [bgSegment1, bgSegment2];
        
        // Variáveis de estado do jogo
        let score = 0;
        let health = 0; 
        let maxHealth = 100; 
        let maxOvershieldHealth = 200; 
        let gameRunning = false;
        let playerX; 
        let playerY; 
        let playerSpeed = 8; 
        let gamePaused = false; 
        
        // Velocidades base e ajustadas
        const baseEnemyMovementSpeed = 5; 
        const baseEnemyBulletSpeed = 5;   
        const baseObstacleSpawnInterval = 2500; 
        let backgroundScrollSpeed = 2; 

        // Velocidades e intervalos ajustados (podem ser modificados pela dificuldade)
        let currentEnemyMovementSpeed = baseEnemyMovementSpeed * 0.8 * 0.7; 
        let currentEnemyBulletSpeed = baseEnemyBulletSpeed * 1.4;     
        let collectibleMovementSpeed = 0; 
        let currentObstacleSpawnInterval = baseObstacleSpawnInterval; 

        let objectSpawnInterval = 1500; 
        let lastObjectSpawnTime = 0;
        let fallingObjects = []; 
        let obstacles = []; 
        let animationFrameId;

        // Variáveis de tiro do jogador
        let bullets = []; 
        let bulletSpeed = 10; 
        let shootInterval = 300; 
        let lastShotTime = 0;
        let bulletDamage = 1; 
        let slantedBulletsActive = false; 
        let sideShotsLevel = 0; 

        // Variáveis de coletáveis
        let collectibles = []; 
        let collectibleDropChance = 0.07; 
        const collectibleStationaryDuration = 5000; 

        // Variáveis do Boss
        let boss = null;
        let bossHealth = 0;
        const initialBossHealth = 200; 
        let bossBullets = [];
        let bossShootInterval = 3000; 
        let lastBossShotTime = 0;
        let isBossFightActive = false;
        let bossMovementDirection = 1; 
        const bossMovementSpeed = 2.5; 
        const bossPadding = 10; 
        let bossLevel = 0; 
        const initialBossBulletDamage = 20; 
        let currentBossBulletDamage = initialBossBulletDamage; 
        let nextBossScoreThreshold = 50; 
        let bossRageThreshold = 0; 
        let bossRageActive = false; 
        let lastBossPowerUpDropTime = 0; 
        const bossFightPowerUpInterval = 10000; 

        // Valores de rotação de matiz do Boss para diferentes níveis
        const bossHueRotations = [0, 90, 180, 270, 30]; 

        // Variável de nível do jogador
        let playerLevel = 1;

        // Variáveis de bala do inimigo
        let enemyBullets = []; 

        // Variáveis de obstáculo
        const obstacleDamage = 20; 
        let lastObstacleSpawnTime = 0;

        // Variáveis do Escudo
        let shieldActive = false;
        let shieldHealth = 0;
        const maxShieldHealth = 100;

        // Variável para controlar se um heavy enemy está na tela
        let isHeavyEnemyOnScreen = false; 

        // Definição do novo inimigo pesado
        const heavyEnemyDefinition = {
            type: 'heavy_enemy',
            hits: 100, 
            sprite: 'https://i.ibb.co/LztRMfLf/file-000000003cc4622f93ccd51271bb76c1.png', 
            width: 72, 
            height: 72, 
            speed: 1.95, 
            shootInterval: 1000, 
            baseBulletDamage: 20, /* AUMENTADO PARA 20 */
            hueRotations: [0, 90, 180] 
        };

        // Dano base das balas inimigas (para escalonamento)
        const baseEnemyBulletDamage = 10; 

        // Tipos de power-ups com cores neon
        const powerUpTypes = [
            { type: 'damage_1', text: '+1', color: '#00FFFF', damageIncrease: 1, sprite: 'https://i.ibb.co/tpmGNwnx/file-00000000c23c61f79d81df79065596e4.png', hueRotate: 140 }, // Ciano neon
            { type: 'side_bullets', text: '>>', color: '#FF00FF', damageIncrease: 0, sprite: 'https://i.ibb.co/6JGv0Nk7/file-00000000f4c461f7a9330c93bf5d848c.png', hueRotate: 50 }, // Magenta neon
            { type: 'shield', text: 'ESC', color: '#00FF00', damageIncrease: 0, sprite: 'https://i.ibb.co/HfN8Wkv3/file-00000000553861f78733587cf43f0566.png', hueRotate: 240 }, // Verde neon
        ];
        // Novo tipo de power-up de vida (adicionado separadamente para controle de spawn)
        const healthPowerUpType = { type: 'health_up', text: '❤️', color: '#FFFF00', healthIncrease: 20, sprite: 'https://i.ibb.co/RpmCgPyD/file-00000000fdf061f59a3de32e7e743922-1.png', hueRotate: 50 }; // Amarelo neon

        // Tipo de debuff
        const debuffType = { type: 'damage_down', text: '-1', color: '#FF4500', damageDecrease: 1, sprite: 'https://i.ibb.co/FbvqcCqK/file-000000007ee861fdb4cec6e89e0ac0ba.png', hueRotate: 30 }; // Laranja avermelhado

        // Tipos de inimigos e suas propriedades (hits necessários, cor base, rotação de matiz)
        const enemyTypes = [
            { scoreThreshold: 0, hits: 1, hueRotate: 0, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 20, hits: 2, hueRotate: 60, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 40, hits: 3, hueRotate: 120, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 60, hits: 4, hueRotate: 180, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 80, hits: 5, hueRotate: 240, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }  
        ];

        // Cores de fundo do cenário para indicar níveis avançados (mais coloridas)
        const backgroundPresets = [
            'linear-gradient(to bottom, #4a90e2 0%, #2e6cb8 100%)', 
            'linear-gradient(to bottom, #7ed321 0%, #5cb82e 100%)', 
            'linear-gradient(to bottom, #f5a623 0%, #d08b1a 100%)', 
            'linear-gradient(to bottom, #bd10e0 0%, #9a0db8 100%)', 
            'linear-gradient(to bottom, #50e3c2 0%, #3bb29c 100%)', 
            'linear-gradient(to bottom, #f8e71c 0%, #d0c015 100%)', 
            'linear-gradient(to bottom, #9013fe 0%, #6b0bc4 100%)'  
        ];
        let currentColorIndex = 0;
        let currentStageHueRotation = 0; 
        const stageHueRotationIncrement = 60; 

        // Variáveis para controle de toque
        let touchStartX = 0;
        let touchStartY = 0; 
        let playerMoving = false;

        // Referência ao elemento de áudio
        const backgroundMusic = new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3'); 
        backgroundMusic.loop = true; 
        backgroundMusic.volume = 0.5; 

        const playerShotSound = new Audio('https://cdn.pixabay.com/download/audio/2022/03/10/audio_f8319f0956.mp3?filename=gun-gun-shot-6133.mp3'); 
        playerShotSound.volume = 0.3;

        const enemyShotSound = new Audio('https://cdn.pixabay.com/download/audio/2022/03/15/audio_2435555416.mp3?filename=laser-gun-8178.mp3'); 
        enemyShotSound.volume = 0.2;

        const bossMusic = new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3'); 
        bossMusic.loop = true;
        bossMusic.volume = 0.6;

        /**
         * Solicita o modo tela cheia para o documento.
         */
        function toggleFullScreen() {
            const element = document.documentElement; 

            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) { 
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) { 
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { 
                element.msRequestFullscreen();
            }
        }

        /**
         * Atualiza as estatísticas do jogador com base no nível atual.
         */
        function updatePlayerStatsBasedOnLevel() {
            maxHealth = 100 + (playerLevel - 1) * 20; 
            maxOvershieldHealth = maxHealth * 2; // O máximo da sobrevida é o dobro da vida máxima
            bulletDamage = 1 + (playerLevel - 1); 
        }

        /**
         * Inicializa o estado do jogo para um novo jogo.
         */
        function initializeGame() {
            score = 0;
            playerLevel = 1; 
            bossLevel = 0; 
            nextBossScoreThreshold = 50; 
            currentStageHueRotation = 0; 
            document.documentElement.style.setProperty('--stage-hue-rotation', `${currentStageHueRotation}deg`); 

            updatePlayerStatsBasedOnLevel(); 
            health = maxHealth; // Começa com vida cheia, sem sobrevida
            slantedBulletsActive = false; 
            sideShotsLevel = 0; 

            // Reseta variáveis do escudo
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 
            
            // Reseta variáveis do Boss
            bossRageActive = false;
            lastBossPowerUpDropTime = 0;
            isHeavyEnemyOnScreen = false; 

            scoreValueDisplay.textContent = score; 
            updateHealthBarDisplay(); 
            updatePlayerDamageDisplay(); 
            playerLevelDisplay.textContent = playerLevel; 
            updateBossProgressBar(); 

            // Reinicializa as velocidades e intervalos para os valores base ajustados
            currentEnemyMovementSpeed = baseEnemyMovementSpeed * 0.8 * 0.7; 
            currentEnemyBulletSpeed = baseEnemyBulletSpeed * 1.4;
            currentObstacleSpawnInterval = baseObstacleSpawnInterval; 
            objectSpawnInterval = 1500; 
            
            currentBossBulletDamage = initialBossBulletDamage;

            clearGameElements(); 
            isBossFightActive = false; 
            
            gameOverScreen.classList.add('hidden');
            startScreen.classList.add('hidden'); 
            stageClearScreen.classList.add('hidden'); 
            pauseScreen.classList.add('hidden'); 

            playerX = gameContainer.offsetWidth / 2 - player.offsetWidth / 2;
            playerY = gameContainer.offsetHeight - player.offsetHeight - 20; 
            player.style.left = `${playerX}px`;
            player.style.bottom = `${20}px`; 

            // Inicializa os segmentos de fundo
            backgroundSegments[0].style.top = '0px';
            backgroundSegments[1].style.top = `${-gameContainer.offsetHeight}px`; 
            backgroundSegments[0].classList.remove('rotated-180');
            backgroundSegments[1].classList.add('rotated-180'); 
            
            gameRunning = true;
            gamePaused = false; 
            lastObjectSpawnTime = performance.now(); 
            lastShotTime = performance.now(); 
            lastObstacleSpawnTime = performance.now(); 
            startGameLoop();
            console.log('initializeGame: isBossFightActive =', isBossFightActive); 

            backgroundMusic.play().catch(e => console.log("Erro ao tentar tocar música:", e)); 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
        }

        /**
         * Prepara o jogo para o próximo estágio.
         */
        function startNextStage() {
            isBossFightActive = false; 
            console.log('startNextStage: isBossFightActive set to', isBossFightActive); 
            clearGameElements(); 
            
            health = maxHealth; // Começa o próximo estágio com vida cheia, sem sobrevida
            // Reseta variáveis do escudo
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 

            // Reseta variáveis do Boss
            bossRageActive = false;
            lastBossPowerUpDropTime = 0;
            isHeavyEnemyOnScreen = false; 
            
            updateHealthBarDisplay();
            updatePlayerDamageDisplay();
            playerLevelDisplay.textContent = playerLevel;
            updateBossProgressBar(); 

            currentEnemyMovementSpeed = baseEnemyMovementSpeed * (0.8 + (bossLevel * 0.1)); 
            currentEnemyBulletSpeed = baseEnemyBulletSpeed * (1.4 + (bossLevel * 0.2)); 
            objectSpawnInterval = Math.max(400, 1500 - (bossLevel * 100)); 
            currentObstacleSpawnInterval = Math.max(1000, baseObstacleSpawnInterval - (bossLevel * 200)); 

            currentStageHueRotation = (currentStageHueRotation + stageHueRotationIncrement) % 360;
            document.documentElement.style.setProperty('--stage-hue-rotation', `${currentStageHueRotation}deg`); 

            stageClearScreen.classList.add('hidden'); 
            gameRunning = true;
            gamePaused = false; 
            lastObjectSpawnTime = performance.now(); 
            lastShotTime = performance.now(); 
            lastObstacleSpawnTime = performance.now(); 
            startGameLoop();

            backgroundMusic.play().catch(e => console.log("Erro ao tentar tocar música:", e)); 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
        }

        /**
         * Limpa todos os elementos de jogo (inimigos, balas, coletáveis, etc.).
         */
        function clearGameElements() {
            fallingObjects.forEach(obj => obj.remove());
            fallingObjects = [];
            bullets.forEach(bullet => bullet.remove());
            bullets = [];
            collectibles.forEach(col => col.remove());
            collectibles = [];
            enemyBullets.forEach(b => b.remove()); 
            enemyBullets = [];
            obstacles.forEach(o => o.remove()); 
            obstacles = [];

            if (boss) {
                boss.remove();
                boss = null;
            }
            const existingBossHealthBarWrapper = document.getElementById('bossHealthBarWrapper');
            if (existingBossHealthBarWrapper) {
                existingBossHealthBarWrapper.remove();
            }
            bossBullets.forEach(b => b.remove());
            bossBullets = [];
            console.log('clearGameElements called. isBossFightActive before removal:', isBossFightActive); 
        }

        /**
         * Atualiza a posição do jogador.
         */
        function updatePlayerPosition() {
            player.style.left = `${playerX}px`;
            player.style.bottom = `${gameContainer.offsetHeight - playerY - player.offsetHeight}px`;
        }

        /**
         * Verifica se dois retângulos se sobrepõem.
         * @param {Object} rect1 - Primeiro retângulo {left, top, width, height}.
         * @param {Object} rect2 - Segundo retângulo {left, top, width, height}.
         * @returns {boolean} True se houver sobreposição, false caso contrário.
         */
        function isOverlapping(rect1, rect2) {
            return rect1.left < rect2.left + rect2.width &&
                   rect1.left + rect1.width > rect2.left &&
                   rect1.top < rect2.top + rect2.height &&
                   rect1.top + rect1.height > rect2.top;
        }

        /**
         * Cria um novo objeto em caída (inimigo) com dificuldade variável.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         * @param {boolean} [isBossSummon=false] - Indica se o inimigo está sendo sumonado pelo boss.
         * @param {Object} [bossStats=null] - Contém {health, damage} do boss se for sumonado por ele.
         */
        function createFallingObject(currentTime, isBossSummon = false, bossStats = null) {
            if (isHeavyEnemyOnScreen && !isBossSummon) {
                console.log("Heavy enemy already on screen (normal spawn attempt), skipping.");
                return;
            }
            if (isBossSummon && isHeavyEnemyOnScreen) {
                console.log("Boss attempted to summon heavy enemy, but one is already on screen, skipping.");
                return;
            }

            const object = document.createElement('div');
            object.classList.add('falling-object');
            
            let selectedEnemyType;
            let isHeavyEnemy = false;
            let spawned = false;
            let maxAttempts = 10;

            let tempLeft, tempTop, tempWidth, tempHeight; 

            if (isBossSummon) {
                selectedEnemyType = heavyEnemyDefinition;
                isHeavyEnemy = true;
                object.classList.add('heavy-enemy');
                object.dataset.movementDirection = (Math.random() < 0.5 ? 1 : -1);
                tempWidth = selectedEnemyType.width * 0.8; 
                tempHeight = selectedEnemyType.height * 0.8; 
                tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                tempTop = 50; 

                object.dataset.hitsRemaining = Math.max(1, Math.round(bossStats.health * 0.10)); 
                object.dataset.initialHits = Math.max(1, Math.round(bossStats.health * 0.10));
                object.dataset.baseBulletDamage = selectedEnemyType.baseBulletDamage; // Usa o dano base do heavy enemy
                object.dataset.isBossSummoned = 'true'; 

                const chosenHueIndex = Math.floor(Math.random() * selectedEnemyType.hueRotations.length);
                selectedEnemyType.hueRotate = selectedEnemyType.hueRotations[chosenHueIndex];

            } else if (bossLevel >= 1 && Math.random() < 0.075) { 
                selectedEnemyType = heavyEnemyDefinition;
                isHeavyEnemy = true;
                object.classList.add('heavy-enemy');
                object.dataset.movementDirection = (Math.random() < 0.5 ? 1 : -1);
                tempWidth = selectedEnemyType.width;
                tempHeight = selectedEnemyType.height;
                tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                tempTop = 50; 

                const chosenHueIndex = Math.floor(Math.random() * selectedEnemyType.hueRotations.length);
                selectedEnemyType.hueRotate = selectedEnemyType.hueRotations[chosenHueIndex];

            } else { 
                tempWidth = 60;
                tempHeight = 60;
                tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                tempTop = -tempHeight;

                let availableEnemyLevels = [];
                for (let j = 0; j < enemyTypes.length; j++) {
                    if (score >= enemyTypes[j].scoreThreshold) {
                        availableEnemyLevels.push(enemyTypes[j]);
                    }
                }

                if (availableEnemyLevels.length === 0) {
                    availableEnemyLevels.push(enemyTypes[0]);
                }

                const enemiesToSpawnFrom = availableEnemyLevels.slice(Math.max(0, availableEnemyLevels.length - 3));
                selectedEnemyType = enemiesToSpawnFrom[Math.floor(Math.random() * enemiesToSpawnFrom.length)];
            }

            for (let i = 0; i < maxAttempts; i++) {
                if (isHeavyEnemy) {
                    tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                } else { 
                    tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                    tempTop = -tempHeight;
                }

                const hypotheticalRect = {
                    left: tempLeft,
                    top: tempTop,
                    width: tempWidth,
                    height: tempHeight
                };

                let overlap = false;
                for (const existingObj of fallingObjects) {
                    const existingRect = {
                        left: parseFloat(existingObj.style.left),
                        top: parseFloat(existingObj.style.top),
                        width: existingObj.offsetWidth,
                        height: existingObj.offsetHeight
                    };
                    const padding = 5;
                    if (isOverlapping(
                        {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                        {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                    )) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    for (const existingObstacle of obstacles) {
                        const existingRect = {
                            left: parseFloat(existingObstacle.style.left),
                            top: parseFloat(existingObstacle.style.top),
                            width: existingObstacle.offsetWidth,
                            height: existingObstacle.offsetHeight
                        };
                        const padding = 5;
                        if (isOverlapping(
                            {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                            {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                        )) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (!overlap) {
                    object.style.left = `${tempLeft}px`;
                    object.style.top = `${tempTop}px`;
                    object.style.width = `${tempWidth}px`;
                    object.style.height = `${tempHeight}px`;
                    spawned = true;
                    break;
                }
            }

            if (!spawned) {
                console.warn("Não foi possível spawnar inimigo sem sobreposição após tentativas.");
                return; 
            }

            if (!isBossSummon) {
                const strengthMultiplier = 1 + (bossLevel * 0.25);
                const additionalHeavyStrength = isHeavyEnemy && Math.random() < 0.1 ? 1.1 : 1;
                object.dataset.hitsRemaining = selectedEnemyType.hits * strengthMultiplier * additionalHeavyStrength;
                object.dataset.initialHits = selectedEnemyType.hits * strengthMultiplier * additionalHeavyStrength;
                object.dataset.baseBulletDamage = selectedEnemyType.baseBulletDamage;
            } 
            object.dataset.hitsRemaining = Math.round(object.dataset.hitsRemaining);
            object.dataset.initialHits = Math.round(object.dataset.initialHits);
            object.dataset.baseBulletDamage = Math.round(object.dataset.baseBulletDamage); 
            
            object.style.backgroundImage = `url('${selectedEnemyType.sprite}')`;
            object.style.backgroundColor = 'transparent';
            object.style.backgroundSize = 'contain';
            object.style.backgroundRepeat = 'no-repeat';
            object.style.backgroundPosition = 'center';
            object.style.filter = `hue-rotate(${selectedEnemyType.hueRotate}deg)`;

            const enemyHealthBarWrapper = document.createElement('div');
            enemyHealthBarWrapper.classList.add('enemy-health-bar-wrapper');
            const enemyHealthBar = document.createElement('div');
            enemyHealthBar.classList.add('enemy-health-bar');
            const enemyHealthFill = document.createElement('div');
            enemyHealthFill.classList.add('enemy-health-fill');
            enemyHealthBar.appendChild(enemyHealthFill);
            enemyHealthBarWrapper.appendChild(enemyHealthBar);
            object.appendChild(enemyHealthBarWrapper);

            object.dataset.hasShot = 'false';
            object.dataset.shootTimer = currentTime + (isHeavyEnemy ? selectedEnemyType.shootInterval : 1000);
            object.dataset.shootType = isHeavyEnemy ? 'straight' : (Math.random() < 0.5 ? 'straight' : 'diagonal');
            object.dataset.isHeavy = isHeavyEnemy;

            gameContainer.appendChild(object);
            fallingObjects.push(object);

            if (isHeavyEnemy) {
                isHeavyEnemyOnScreen = true;
                console.log("Heavy enemy spawned. isHeavyEnemyOnScreen = true");
            }
        }

        /**
         * Cria uma nova bala do jogador.
         */
        function createBullet() {
            const bulletBottom = gameContainer.offsetHeight - playerY - player.offsetHeight + 10;
            const bulletWidth = 8; 
            const bulletHeight = 20; 

            const createSingleBullet = (xOffset, initialDx) => {
                const bullet = document.createElement('div');
                bullet.classList.add('bullet');
                bullet.style.left = `${playerX + player.offsetWidth / 2 - bulletWidth / 2 + xOffset}px`;
                bullet.style.bottom = `${bulletBottom}px`; 
                
                let dx = initialDx;
                bullet.dataset.dx = dx;
                bullet.dataset.dy = bulletSpeed; 
                gameContainer.appendChild(bullet);
                bullets.push(bullet);
                playerShotSound.currentTime = 0; 
                playerShotSound.play().catch(e => console.log("Erro ao tocar som de tiro do player:", e));
            };

            createSingleBullet(0, 0); 

            if (sideShotsLevel >= 1) { 
                createSingleBullet(-15, 0); 
                createSingleBullet(15, 0);  
            }
            if (sideShotsLevel >= 2) { 
                createSingleBullet(-30, 0); 
                createSingleBullet(30, 0);  
            }

            if (slantedBulletsActive) { 
                createSingleBullet(-20, -2); 
                createSingleBullet(20, 2);  
            }
        }

        /**
         * Converte um valor hexadecimal de cor para RGBA.
         * @param {string} hex - A cor em formato hexadecimal (ex: '#RRGGBB' ou '#RGB').
         * @param {number} alpha - O valor do canal alfa (0 a 1).
         * @returns {string} A cor em formato RGBA (ex: 'rgba(255, 0, 0, 0.7)').
         */
        function hexToRgba(hex, alpha = 1) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            }
            else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        /**
         * Cria um coletável (power-up ou debuff).
         * @param {number} x - Posição X para spawnar o coletável.
         * @param {number} y - Posição Y para spawnar o coletável.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         * @param {string} [forcedType=null] - Tipo de power-up a ser forçado (ex: 'health_up').
         */
        function createCollectible(x, y, currentTime, forcedType = null) {
            const collectible = document.createElement('div');
            const powerUpSize = 30 * 1.2; 
            collectible.style.width = `${powerUpSize}px`;
            collectible.style.height = `${powerUpSize}px`;
            collectible.style.left = `${x}px`;
            collectible.style.top = `${y}px`; 
            collectible.dataset.spawnTime = currentTime; 
            collectible.dataset.isStationary = 'true'; 

            let selectedCollectibleType;

            if (forcedType) { 
                selectedCollectibleType = [...powerUpTypes, healthPowerUpType, debuffType].find(type => type.type === forcedType);
                if (!selectedCollectibleType) { 
                    selectedCollectibleType = powerUpTypes[0]; 
                }
            } else { 
                const healthDropProbability = 0.30; 
                const debuffDropProbability = 0.10; 
                const rand = Math.random();

                if (rand < healthDropProbability) { 
                    selectedCollectibleType = healthPowerUpType;
                } else if (rand < healthDropProbability + debuffDropProbability) { 
                    selectedCollectibleType = debuffType;
                } else { 
                    const otherPowerUps = powerUpTypes.filter(type => type.type !== 'health_up' && type.type !== 'damage_down' && type.type !== 'shield'); 
                    selectedCollectibleType = otherPowerUps[Math.floor(Math.random() * otherPowerUps.length)];
                }
            }
            
            collectible.dataset.type = selectedCollectibleType.type; 
            if (selectedCollectibleType.type === 'debuff') {
                collectible.classList.add('debuff');
            } else {
                collectible.classList.add('power-up');
            }
            collectible.style.backgroundImage = `url('${selectedCollectibleType.sprite}')`; 
            collectible.style.backgroundColor = 'transparent'; 
            collectible.style.backgroundSize = 'contain';
            collectible.style.backgroundRepeat = 'no-repeat';
            collectible.style.backgroundPosition = 'center';
            collectible.innerHTML = ''; 

            // Aplica o brilho neon e saturação
            collectible.style.setProperty('--neon-color', selectedCollectibleType.color);
            // Removido: hue-rotate(${-currentStageHueRotation}deg) para não ser afetado pelo filtro do estágio
            collectible.style.filter = `saturate(200%) brightness(150%)`; 

            gameContainer.appendChild(collectible);
            collectibles.push(collectible);
        }

        /**
         * Cria um obstáculo.
         */
        function createObstacle() {
            const obstacle = document.createElement('div');
            obstacle.classList.add('obstacle');
            
            const baseSize = 45;
            let tempWidth = baseSize + Math.random() * baseSize; 
            let tempHeight = tempWidth; 
            let spawned = false;
            let maxAttempts = 10;

            for (let i = 0; i < maxAttempts; i++) {
                let tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth); 
                let tempTop = -tempHeight; 

                const hypotheticalRect = {
                    left: tempLeft,
                    top: tempTop,
                    width: tempWidth,
                    height: tempHeight
                };

                let overlap = false;
                for (const existingObstacle of obstacles) {
                    const existingRect = {
                        left: parseFloat(existingObstacle.style.left),
                        top: parseFloat(existingObstacle.style.top),
                        width: existingObstacle.offsetWidth,
                        height: existingObstacle.offsetHeight
                    };
                    if (isOverlapping(hypotheticalRect, existingRect)) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    for (const existingObj of fallingObjects) {
                        const existingRect = {
                            left: parseFloat(existingObj.style.left),
                            top: parseFloat(existingObj.style.top),
                            width: existingObj.offsetWidth,
                            height: existingObj.offsetHeight
                        };
                        if (isOverlapping(hypotheticalRect, existingRect)) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (!overlap) {
                    obstacle.style.left = `${tempLeft}px`;
                    obstacle.style.top = `${tempTop}px`;
                    obstacle.style.width = `${tempWidth}px`;
                    obstacle.style.height = `${tempHeight}px`;
                    spawned = true;
                    break;
                }
            }

            if (!spawned) {
                console.warn("Não foi possível spawnar obstáculo sem sobreposição após tentativas.");
                return; 
            }

            const randomHue = Math.floor(Math.random() * 360);
            obstacle.style.filter = `hue-rotate(${randomHue}deg) var(--stage-hue-rotation)`; /* APLICADO AQUI */

            gameContainer.appendChild(obstacle);
            obstacles.push(obstacle);
        }

        /**
         * Cria um projétil de um inimigo normal ou pesado.
         * @param {HTMLElement} enemyObject - O elemento DOM do inimigo que está atirando.
         * @param {boolean} [isHeavyBullet=false] - Indica se é uma bala de inimigo pesado.
         */
        function createEnemyBullet(enemyObject, isHeavyBullet = false) {
            const enemyBullet = document.createElement('div');
            enemyBullet.classList.add('enemy-bullet');
            if (isHeavyBullet) {
                enemyBullet.classList.add('heavy-enemy-bullet'); 
                enemyBullet.classList.add('heavy-enemy-bullet-color'); 
            } else {
                enemyBullet.classList.add('enemy-bullet-color'); 
            }
            let enemyLeft = parseFloat(enemyObject.style.left);
            if (isNaN(enemyLeft)) { enemyLeft = 0; enemyObject.style.left = `${enemyLeft}px`; }
            let enemyTop = parseFloat(enemyObject.style.top);
            if (isNaN(enemyTop)) { enemyTop = -60; enemyObject.style.top = `${enemyTop}px`; }

            const bulletSize = isHeavyBullet ? 24 : 12; /* AUMENTADO PARA 24px */
            enemyBullet.style.left = `${enemyLeft + (enemyObject.offsetWidth / 2) - (bulletSize / 2)}px`;
            enemyBullet.style.top = `${enemyTop + enemyObject.offsetHeight}px`;
            
            let dx = 0;
            let dy = isHeavyBullet ? heavyEnemyDefinition.speed * 2 : currentEnemyBulletSpeed; 

            if (!isHeavyBullet && enemyObject.dataset.shootType === 'diagonal') { 
                dx = (Math.random() < 0.5 ? -1 : 1) * (currentEnemyBulletSpeed * 0.5); 
                dy = currentEnemyBulletSpeed * 0.866; 
            }
            enemyBullet.dataset.dx = dx;
            enemyBullet.dataset.dy = dy;
            enemyBullet.dataset.isHeavyBullet = isHeavyBullet; 

            gameContainer.appendChild(enemyBullet);
            enemyBullets.push(enemyBullet);
            enemyShotSound.currentTime = 0; 
            enemyShotSound.play().catch(e => console.log("Erro ao tocar som de tiro do inimigo:", e));
        }

        /**
         * Atualiza a posição dos objetos em caída e seus estados.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateFallingObjects(currentTime) {
            try {
                for (let i = 0; i < fallingObjects.length; i++) {
                    const object = fallingObjects[i];
                    let currentTop = parseFloat(object.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; object.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(object.style.left); 

                    if (object.dataset.isHeavy === 'true') {
                        let direction = parseFloat(object.dataset.movementDirection);
                        currentLeft += direction * heavyEnemyDefinition.speed; 

                        if (currentLeft <= 0 || currentLeft + object.offsetWidth >= gameContainer.offsetWidth) {
                            direction *= -1;
                            object.dataset.movementDirection = direction;
                            currentLeft = Math.max(0, Math.min(currentLeft, gameContainer.offsetWidth - object.offsetWidth)); 
                        }
                        object.style.left = `${currentLeft}px`;

                        if (currentTime >= parseFloat(object.dataset.shootTimer)) {
                            createEnemyBullet(object, true); 
                            object.dataset.shootTimer = currentTime + heavyEnemyDefinition.shootInterval; 
                        }
                    } else {
                        object.style.top = `${currentTop + currentEnemyMovementSpeed}px`;

                        if (object.dataset.hasShot === 'false' && currentTime >= parseFloat(object.dataset.shootTimer)) {
                            createEnemyBullet(object, false); 
                            object.dataset.hasShot = 'true';
                        }

                        if (currentTop > gameContainer.offsetHeight) {
                            object.remove();
                            fallingObjects.splice(i, 1);
                            i--;
                            continue;
                        }
                    }

                    const enemyHealthBarWrapper = object.querySelector('.enemy-health-bar-wrapper');
                    if (enemyHealthBarWrapper) {
                        if (object.dataset.isHeavy === 'true') {
                            enemyHealthBarWrapper.style.top = `${-20}px`; 
                        } else {
                            enemyHealthBarWrapper.style.top = `${-15}px`;
                        }
                    }
                }
            } catch (error) {
                console.error("Erro em updateFallingObjects:", error);
            }
        }

        /**
         * Atualiza a posição das balas do jogador e verifica colisões com objetos em caída.
         */
        function updateBullets() {
            try {
                for (let i = 0; i < bullets.length; i++) {
                    const bullet = bullets[i];
                    let currentBottom = parseFloat(bullet.style.bottom);
                    if (isNaN(currentBottom)) { currentBottom = 0; bullet.style.bottom = `${currentBottom}px`; }
                    let currentLeft = parseFloat(bullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; bullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(bullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(bullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentBottom += dy;
                    currentLeft += dx;

                    bullet.style.bottom = `${currentBottom}px`;
                    bullet.style.left = `${currentLeft}px`;

                    if (currentBottom > gameContainer.offsetHeight || currentBottom < -bullet.offsetHeight) {
                        bullet.remove();
                        bullets.splice(i, 1);
                        i--; 
                        continue; 
                    }

                    if (isBossFightActive && boss) {
                        const bulletRect = bullet.getBoundingClientRect();
                        const bossRect = boss.getBoundingClientRect();

                        if (
                            bulletRect.bottom > bossRect.top &&
                            bulletRect.top < bossRect.bottom &&
                            bulletRect.right > bossRect.left &&
                            bulletRect.left < bossRect.right
                        ) {
                            bullet.remove();
                            bullets.splice(i, 1);
                            i--;
                            
                            bossHealth = Math.max(0, bossHealth - bulletDamage);
                            updateBossHealthBar();
                            if (bossHealth <= 0) {
                                handleBossDefeated(); 
                                return; 
                            }
                            continue; 
                        }
                    }

                    const bulletRect = bullet.getBoundingClientRect();
                    for (let j = 0; j < fallingObjects.length; j++) {
                        const object = fallingObjects[j];
                        const objectRect = object.getBoundingClientRect();

                        if (
                            bulletRect.bottom > objectRect.top &&
                            bulletRect.top < objectRect.bottom &&
                            bulletRect.right > objectRect.left &&
                            bulletRect.left < objectRect.right
                        ) {
                            bullet.remove(); 
                            bullets.splice(i, 1);
                            i--; 
                            
                            let hitsRemaining = parseInt(object.dataset.hitsRemaining);
                            hitsRemaining -= bulletDamage; 
                            object.dataset.hitsRemaining = hitsRemaining;

                            const enemyHealthFill = object.querySelector('.enemy-health-fill');
                            if (enemyHealthFill) {
                                const healthPercentage = (hitsRemaining / parseInt(object.dataset.initialHits)) * 100;
                                enemyHealthFill.style.width = `${healthPercentage}%`;
                                if (healthPercentage > 60) {
                                    enemyHealthFill.style.backgroundColor = '#48bb78'; 
                                } else if (healthPercentage > 30) {
                                    enemyHealthFill.style.backgroundColor = '#f6ad55'; 
                                } else {
                                    enemyHealthFill.style.backgroundColor = '#e53e3e'; 
                                }
                            }

                            if (hitsRemaining > 0) {
                                object.classList.add('enemy-hit-effect');
                                setTimeout(() => {
                                    object.classList.remove('enemy-hit-effect');
                                }, 100); 
                            } else {
                                object.remove();
                                fallingObjects.splice(j, 1);
                                j--; 
                                
                                if (object.dataset.isHeavy === 'true') {
                                    isHeavyEnemyOnScreen = false; 
                                    console.log("Heavy enemy defeated. isHeavyEnemyOnScreen = false");
                                    score += 10; 
                                    const gameRect = gameContainer.getBoundingClientRect();
                                    const positivePowerUps = powerUpTypes.filter(type => type.type !== 'damage_down');
                                    const forcedPowerUp = positivePowerUps[Math.floor(Math.random() * positivePowerUps.length)];
                                    createCollectible(objectRect.left - gameRect.left, objectRect.top - gameRect.top, performance.now(), forcedPowerUp.type);
                                } else {
                                    score++; 
                                    if (Math.random() < collectibleDropChance) { 
                                        const gameRect = gameContainer.getBoundingClientRect(); 
                                        createCollectible(objectRect.left - gameRect.left, objectRect.top - gameRect.top, performance.now()); 
                                    }
                                }
                                scoreValueDisplay.textContent = score; 
                                increaseDifficulty(); 
                            }
                            if (bullet.parentNode === null) break; 
                        }
                    }
                }
            } catch (error) {
                console.error("Erro em updateBullets:", error);
            }
        }

        /**
         * Atualiza a posição dos coletáveis e verifica colisões com o jogador.
         */
        function updateCollectibles(currentTime) {
            try {
                for (let i = 0; i < collectibles.length; i++) {
                    const collectible = collectibles[i];
                    let currentTop = parseFloat(collectible.style.top);
                    if (isNaN(currentTop)) {
                        currentTop = 0; 
                        collectible.style.top = `${currentTop}px`;
                    }

                    if (collectible.dataset.isStationary === 'true') {
                        if (currentTime - parseFloat(collectible.dataset.spawnTime) > collectibleStationaryDuration) {
                            collectible.dataset.isStationary = 'false'; 
                        }
                    } else {
                        collectible.style.top = `${currentTop + currentEnemyMovementSpeed}px`;
                    }

                    if (currentTop > gameContainer.offsetHeight) {
                        collectible.remove();
                        collectibles.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const collectibleRect = collectible.getBoundingClientRect();

                    if (
                        collectibleRect.bottom > playerRect.top &&
                        collectibleRect.top < playerRect.bottom &&
                        collectibleRect.right > playerRect.left &&
                        collectibleRect.left < playerRect.right
                    ) {
                        if (collectible.classList.contains('power-up')) {
                            collectPowerUp(collectible);
                        } else if (collectible.classList.contains('debuff')) {
                            collectDebuff(collectible);
                        }
                        collectible.remove();
                        collectibles.splice(i, 1);
                        i--;
                        return; 
                    }
                }
            } catch (error) {
                console.error("Erro em updateCollectibles:", error);
            }
        }

        /**
         * Atualiza a posição dos projéteis inimigos e verifica colisões com o jogador.
         */
        function updateEnemyBullets() {
            try {
                for (let i = 0; i < enemyBullets.length; i++) {
                    const eBullet = enemyBullets[i];
                    let currentTop = parseFloat(eBullet.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; eBullet.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(eBullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; eBullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(eBullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(eBullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentTop += dy;
                    currentLeft += dx;

                    eBullet.style.top = `${currentTop}px`;
                    eBullet.style.left = `${currentLeft}px`;

                    if (currentTop > gameContainer.offsetHeight || currentLeft < -eBullet.offsetWidth || currentLeft > gameContainer.offsetWidth) {
                        eBullet.remove();
                        enemyBullets.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const eBulletRect = eBullet.getBoundingClientRect();

                    if (
                        eBulletRect.bottom > playerRect.top &&
                        eBulletRect.top < playerRect.bottom &&
                        eBulletRect.right > playerRect.left &&
                        eBulletRect.left < playerRect.right
                    ) {
                        eBullet.remove();
                        enemyBullets.splice(i, 1);
                        i--;

                        // Correção: Pega o dano base da bala do inimigo (se for heavy, usa o baseBulletDamage do dataset)
                        let damageToApply;
                        if (eBullet.dataset.isHeavyBullet === 'true') {
                            // Pega o dano base diretamente do dataset da bala do heavy enemy
                            damageToApply = parseFloat(eBullet.dataset.baseBulletDamage);
                        } else {
                            // Usa o dano base para inimigos normais
                            damageToApply = baseEnemyBulletDamage;
                        }
                        // Aplica o escalonamento de nível do boss ao dano
                        damageToApply *= (1 + bossLevel * 0.10);

                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateEnemyBullets. Defaulting to 0.");
                            damageToApply = 0;
                        }
                        
                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); // Aplica o dano restante na vida/sobrevida
                            }
                        } else { // Sem escudo, aplica na vida/sobrevida
                            health = Math.max(0, health - damageToApply);
                        }
                        
                        updateHealthBarDisplay();
                        console.log("Atingido por inimigo! Vida restante: " + health + ", Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect'); /* CORRIGIDO: Era player-hit-effect, deve ser enemy-hit-effect */
                        }, 150); 
                    }
                }
            } catch (error) {
                console.error("Erro em updateEnemyBullets:", error);
            }
        }

        /**
         * Atualiza a posição dos obstáculos e verifica colisões com o jogador.
         */
        function updateObstacles() {
            try {
                for (let i = 0; i < obstacles.length; i++) {
                    const obstacle = obstacles[i];
                    let currentTop = parseFloat(obstacle.style.top);
                    if (isNaN(currentTop)) {
                        currentTop = -45; 
                        obstacle.style.top = `${currentTop}px`; 
                    }
                    obstacle.style.top = `${currentTop + currentEnemyMovementSpeed}px`; 

                    if (currentTop > gameContainer.offsetHeight) {
                        obstacle.remove();
                        obstacles.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const obstacleRect = obstacle.getBoundingClientRect();

                    if (
                        obstacleRect.bottom > playerRect.top &&
                        obstacleRect.top < playerRect.bottom &&
                        obstacleRect.right > playerRect.left &&
                        obstacleRect.left < playerRect.right
                    ) {
                        obstacle.remove();
                        obstacles.splice(i, 1);
                        i--;

                        let damageToApply = obstacleDamage; 
                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateObstacles. Defaulting to 0.");
                            damageToApply = 0;
                        }

                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); // Aplica o dano restante na vida/sobrevida
                            }
                        } else { // Sem escudo, aplica na vida/sobrevida
                            health = Math.max(0, health - damageToApply);
                        }

                        updateHealthBarDisplay();
                        console.log("Atingido por obstáculo! Vida restante: " + health + ", Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect'); 
                        }, 150); 
                    }
                }
            } catch (error) {
                console.error("Erro em updateObstacles:", error);
            }
        }

        /**
         * Aumenta a dificuldade do jogo.
         */
        function increaseDifficulty() {
            if (score >= nextBossScoreThreshold && !isBossFightActive) {
                startBossFight(); 
            }
        }

        /**
         * Função para coletar um power-up.
         * @param {HTMLElement} powerUp - O elemento DOM do power-up coletado.
         */
        function collectPowerUp(powerUp) {
            const type = powerUp.dataset.type;
            console.log(`Power-up coletado: ${type}`); 

            if (type === 'damage_1') {
                bulletDamage = Math.max(1, bulletDamage + 1); 
                console.log("Power-up de dano +1! Dano atual: " + bulletDamage);
            } else if (type === 'side_bullets') {
                sideShotsLevel = Math.min(2, sideShotsLevel + 1); 
                console.log("Power-up de tiros laterais ativado! Nível: " + sideShotsLevel);
            } else if (type === 'health_up') {
                // Ao coletar vida, sempre aumenta 'health' até o limite de maxOvershieldHealth
                health = Math.min(maxOvershieldHealth, health + healthPowerUpType.healthIncrease);
                console.log("Power-up de vida coletado! Vida atual: " + health);
            } else if (type === 'shield') { 
                if (!shieldActive) { 
                    // Se o escudo não estava ativo, ativa e preenche
                    shieldHealth = maxShieldHealth; 
                    shieldActive = true; 
                    player.classList.add('player-shield-active'); 
                } else {
                    // Se o escudo já está ativo, apenas recarrega
                    shieldHealth = maxShieldHealth;
                }
                console.log("Power-up de escudo coletado! Vida do escudo: " + shieldHealth);
            }
            updatePlayerDamageDisplay();
            updateHealthBarDisplay(); 
        }

        /**
         * Função para coletar um debuff.
         * @param {HTMLElement} debuff - O elemento DOM do debuff coletado.
         */
        function collectDebuff(debuff) {
            const type = debuff.dataset.type;
            console.log(`Debuff coletado: ${type}`); 

            if (type === 'damage_down') {
                bulletDamage = Math.max(1, bulletDamage - 1); 
                sideShotsLevel = Math.max(0, sideShotsLevel - 1); 
                slantedBulletsActive = false; 
                console.log("Debuff de dano -1! Dano atual: " + bulletDamage + ". Tiros laterais Nível: " + sideShotsLevel); 
            }
            updatePlayerDamageDisplay();
        }

        /**
         * Desativa o escudo do jogador.
         */
        function deactivateShield() {
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 
            
            // A variável 'health' já contém o valor correto após o dano ter sido aplicado a ela.
            health = Math.max(0, health); // Garante que a vida não fique negativa
            
            console.log("Escudo desativado! Vida do jogador: " + health);
            updateHealthBarDisplay(); 
        }

        /**
         * Atualiza a exibição de dano do jogador (na barra de status).
         */
        function updatePlayerDamageDisplay() {
            if (playerDamageDisplay) {
                let damageText = `${bulletDamage}`;
                if (slantedBulletsActive) damageText += ` (//)`;
                if (sideShotsLevel > 0) damageText += ` (S${sideShotsLevel})`; 
                
                playerDamageDisplay.textContent = damageText;
            }
        }

        /**
         * Atualiza a barra de vida do jogador (agora com suporte a escudo e sobrevida).
         */
        function updateHealthBarDisplay() {
            if (healthFill && shieldHealthFill && overshieldFill) { 
                // A barra de vida do jogador (e sobrevida) está sempre visível
                // A barra de escudo é que alterna visibilidade
                if (shieldActive) {
                    shieldHealthBar.classList.remove('hidden');
                    const shieldPercentage = (shieldHealth / maxShieldHealth) * 100;
                    shieldHealthFill.style.height = `${shieldPercentage}%`; 
                    shieldHealthText.textContent = `${Math.round(shieldHealth)} / ${maxShieldHealth}`;
                } else {
                    shieldHealthBar.classList.add('hidden');
                }

                // Lógica para a barra de vida principal (incluindo sobrevida)
                if (health > maxHealth) {
                    const baseHealthPercentage = 100; // Vida base sempre cheia (100%)
                    const overshieldAmount = health - maxHealth;
                    // Calcula a porcentagem da sobrevida em relação ao total de sobrevida possível
                    const overshieldMaxPossible = maxOvershieldHealth - maxHealth; // Isso é 100 (200 - 100)
                    const overshieldPercentage = (overshieldAmount / overshieldMaxPossible) * 100;

                    healthFill.style.backgroundColor = '#48bb78'; /* Verde para vida base cheia */
                    healthFill.style.height = `${baseHealthPercentage}%`; 
                    overshieldFill.style.height = `${overshieldPercentage}%`; // Barra de sobrevida sobe
                    playerHealthText.textContent = `${Math.round(health)} / ${maxOvershieldHealth} (Sobrevida)`;
                } else {
                    // Lógica para vida normal (sem sobrevida)
                    overshieldFill.style.height = '0%'; // Garante que a sobrevida esteja oculta
                    const healthPercentage = (health / maxHealth) * 100;
                    healthFill.style.height = `${healthPercentage}%`; 
                    if (healthPercentage > 60) {
                        healthFill.style.backgroundColor = '#48bb78'; 
                    } else if (healthPercentage > 30) {
                        healthFill.style.backgroundColor = '#f6ad55'; 
                    } else {
                        healthFill.style.backgroundColor = '#e53e3e'; 
                    }
                    playerHealthText.textContent = `${Math.round(health)} / ${maxHealth}`; 
                }
            }
        }

        /**
         * Atualiza a barra de progresso do Boss.
         */
        function updateBossProgressBar() {
            const progress = Math.min(score, nextBossScoreThreshold);
            const progressPercentage = (progress / nextBossScoreThreshold) * 100;
            bossProgressFill.style.width = `${progressPercentage}%`;
            bossProgressText.textContent = `${score} / ${nextBossScoreThreshold}`;
        }

        /**
         * Inicia a batalha contra o boss.
         */
        function startBossFight() {
            console.log('startBossFight: Setting isBossFightActive = true'); 
            isBossFightActive = true;
            clearGameElements(); 
            
            bossHealth = initialBossHealth * Math.pow(2, bossLevel); 
            currentBossBulletDamage = initialBossBulletDamage * (1 + bossLevel * 0.10); 
            bossRageThreshold = bossHealth * 0.35; 
            bossRageActive = false; 
            lastBossPowerUpDropTime = performance.now(); 

            console.log(`Boss Level: ${bossLevel}, Boss Health: ${bossHealth}, Boss Bullet Damage: ${currentBossBulletDamage}, Rage Threshold: ${bossRageThreshold}`); 

            createBoss();
            lastBossShotTime = performance.now(); 

            backgroundMusic.pause(); 
            backgroundMusic.currentTime = 0; 
            bossMusic.play().catch(e => console.log("Erro ao tocar música do boss:", e)); 
        }

        /**
         * Cria o elemento do boss.
         */
        function createBoss() {
            boss = document.createElement('div');
            boss.classList.add('boss');
            boss.style.left = `${(gameContainer.offsetWidth / 2) - (100 / 2)}px`; 
            boss.style.top = '50px'; 
            bossMovementDirection = Math.random() < 0.5 ? 1 : -1; 
            const bossHue = bossHueRotations[bossLevel % bossHueRotations.length];
            boss.style.filter = `hue-rotate(${bossHue}deg)`; 
            gameContainer.appendChild(boss);

            const bossHealthBarWrapper = document.createElement('div');
            bossHealthBarWrapper.id = 'bossHealthBarWrapper'; 
            bossHealthBarWrapper.classList.add('boss-health-bar-wrapper');
            gameContainer.appendChild(bossHealthBarWrapper);

            const healthBar = document.createElement('div');
            healthBar.classList.add('boss-health-bar');
            bossHealthBarWrapper.appendChild(healthBar);

            const healthFillBoss = document.createElement('div'); 
            healthFillBoss.classList.add('boss-health-fill');
            healthBar.appendChild(healthFillBoss);

            const bossHealthText = document.createElement('span'); 
            bossHealthText.classList.add('boss-health-text');
            healthBar.appendChild(bossHealthText); 

            updateBossHealthBar(); 
        }

        /**
         * Atualiza a barra de vida do boss.
         */
        function updateBossHealthBar() {
            if (boss) {
                const bossHealthBarWrapper = document.getElementById('bossHealthBarWrapper');
                if (bossHealthBarWrapper) {
                    let bossLeft = parseFloat(boss.style.left);
                    if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (100 / 2); boss.style.left = `${bossLeft}px`; }
                    let bossTop = parseFloat(boss.style.top);
                    if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

                    bossHealthBarWrapper.style.left = `${bossLeft}px`;
                    bossHealthBarWrapper.style.top = `${bossTop + boss.offsetHeight + 5}px`; 
                }

                const healthFillBoss = bossHealthBarWrapper.querySelector('.boss-health-fill');
                const bossHealthText = bossHealthBarWrapper.querySelector('.boss-health-text');

                const currentMaxBossHealth = initialBossHealth * Math.pow(2, bossLevel); 
                const healthPercentage = (bossHealth / currentMaxBossHealth) * 100;
                healthFillBoss.style.width = `${healthPercentage}%`; 
                
                if (healthPercentage > 60) {
                    healthFillBoss.style.backgroundColor = '#48bb78'; 
                } else if (healthPercentage > 30) {
                    healthFillBoss.style.backgroundColor = '#f6ad55'; 
                } else {
                    healthFillBoss.style.backgroundColor = '#e53e3e'; 
                }
                bossHealthText.textContent = `${Math.round(bossHealth)} / ${Math.round(currentMaxBossHealth)}`; 
            }
        }

        /**
         * Atualiza a lógica do boss (movimento e tiro).
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateBoss(currentTime) {
            try {
                if (!boss) {
                    console.log("updateBoss: Boss object is null, cannot update."); 
                    return;
                }
                console.log("updateBoss: Executing Boss movement and shoot logic. Boss.style.left:", boss.style.left, "Boss.style.top:", boss.style.top, "Boss Health:", bossHealth);
                console.log("updateBoss: bossMovementDirection:", bossMovementDirection, "bossMovementSpeed:", bossMovementSpeed); 

                let bossX = parseFloat(boss.style.left);
                if (isNaN(bossX)) { 
                    bossX = (gameContainer.offsetWidth / 2) - (100 / 2);
                    boss.style.left = `${bossX}px`; 
                    console.log("updateBoss: bossX was NaN, reset to:", bossX); 
                }

                let newBossX = bossX + bossMovementDirection * bossMovementSpeed; 
                console.log("updateBoss: old bossX:", bossX, "newBossX calculated:", newBossX); 

                if (newBossX + boss.offsetWidth + bossPadding > gameContainer.offsetWidth) {
                    newBossX = gameContainer.offsetWidth - boss.offsetWidth - bossPadding;
                    bossMovementDirection *= -1; 
                    console.log("updateBoss: Hit right boundary, newBossX:", newBossX, "new bossMovementDirection:", bossMovementDirection); 
                } else if (newBossX < bossPadding) {
                    newBossX = bossPadding;
                    bossMovementDirection *= -1; 
                    console.log("updateBoss: Hit left boundary, newBossX:", newBossX, "new bossMovementDirection:", bossMovementDirection); 
                }
                boss.style.left = `${newBossX}px`; 
                console.log("updateBoss: boss.style.left updated to:", boss.style.left); 
                console.log("updateBoss: boss.getBoundingClientRect().left:", boss.getBoundingClientRect().left); 

                updateBossHealthBar(); 

                if (bossHealth <= bossRageThreshold && !bossRageActive) {
                    bossRageActive = true;
                    boss.style.filter = `hue-rotate(0deg) saturate(200%) brightness(1.2)`; 
                    currentBossBulletDamage *= 1.05; 
                    console.log("BOSS ENTROU EM MODO DE RAIVA! Dano aumentado.");
                }

                if (currentTime - lastBossShotTime > bossShootInterval) {
                    if (bossRageActive && Math.random() < 0.30) { 
                        createShotgunBossBullets();
                    } else {
                        const attackTypes = [createSingleBossBullet, createFanBossBullets, createRicochetBossBullet];
                        const selectedAttack = attackTypes[Math.floor(Math.random() * attackTypes.length)];
                        selectedAttack();
                    }
                    lastBossShotTime = currentTime;

                    if (bossLevel >= 0 && !isHeavyEnemyOnScreen && Math.random() < 0.20) { 
                        console.log("Boss attempting to summon heavy enemy...");
                        createFallingObject(currentTime, true, {health: bossHealth, damage: currentBossBulletDamage});
                    }
                }
            } catch (error) {
                console.error("Erro em updateBoss:", error);
            }
        }

        /**
         * Cria uma única bala do boss.
         */
        function createSingleBossBullet() {
            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            bossBullet.style.left = `${bossLeft + (boss.offsetWidth / 2) - (15 / 2)}px`;
            bossBullet.style.top = `${bossTop + boss.offsetHeight}px`;
            bossBullet.dataset.dx = 0; 
            bossBullet.dataset.dy = currentEnemyBulletSpeed; 
            gameContainer.appendChild(bossBullet);
            bossBullets.push(bossBullet);
        }

        /**
         * Cria balas do boss em leque.
         */
        function createFanBossBullets() {
            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            const startX = bossLeft + boss.offsetWidth / 2;
            const startY = bossTop + boss.offsetHeight;
            const spreadAngle = Math.PI / 6; 
            const numBullets = 3;
            const baseSpeed = currentEnemyBulletSpeed * 0.5; // REDUZIDO EM 50%

            for (let i = 0; i < numBullets; i++) {
                const angleOffset = (i - (numBullets - 1) / 2) * spreadAngle / (numBullets - 1);
                const angle = Math.PI / 2 + angleOffset; 

                const dx = Math.cos(angle) * baseSpeed;
                const dy = Math.sin(angle) * baseSpeed;

                const bossBullet = document.createElement('div');
                bossBullet.classList.add('boss-bullet');
                bossBullet.style.left = `${startX - (15 / 2)}px`;
                bossBullet.style.top = `${startY}px`;
                bossBullet.dataset.dx = dx;
                bossBullet.dataset.dy = dy;
                gameContainer.appendChild(bossBullet);
                bossBullets.push(bossBullet);
            }
        }

        /**
         * Cria uma bala ricochete do boss.
         */
        function createRicochetBossBullet() {
            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            bossBullet.style.left = `${bossLeft + (boss.offsetWidth / 2) - (15 / 2)}px`;
            bossBullet.style.top = `${bossTop + boss.offsetHeight}px`;
            
            bossBullet.dataset.dx = (Math.random() > 0.5 ? 1 : -1) * (currentEnemyBulletSpeed * 0.75); // REDUZIDO EM 50%
            bossBullet.dataset.dy = currentEnemyBulletSpeed * 0.5; // REDUZIDO EM 50%
            gameContainer.appendChild(bossBullet);
            bossBullets.push(bossBullet);
        }

        /**
         * Cria 10 balas do boss em todas as direções (ataque "shotgun").
         */
        function createShotgunBossBullets() {
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            const startX = bossLeft + boss.offsetWidth / 2;
            const startY = bossTop + boss.offsetHeight / 2; 
            const numBullets = 10;
            const angleIncrement = (Math.PI * 2) / numBullets; 
            const baseSpeed = currentEnemyBulletSpeed * 0.8; 

            for (let i = 0; i < numBullets; i++) {
                const angle = i * angleIncrement;

                const dx = Math.cos(angle) * baseSpeed;
                const dy = Math.sin(angle) * baseSpeed;

                const bossBullet = document.createElement('div');
                bossBullet.classList.add('boss-bullet');
                bossBullet.style.left = `${startX - (15 / 2)}px`;
                bossBullet.style.top = `${startY - (15 / 2)}px`; 
                bossBullet.dataset.dx = dx;
                bossBullet.dataset.dy = dy;
                bossBullet.dataset.isShotgun = 'true'; // MARCA COMO TIRO DE SHOTGUN
                gameContainer.appendChild(bossBullet);
                bossBullets.push(bossBullet);
            }
        }

        /**
         * Atualiza a posição dos projéteis do boss e verifica colisões com o jogador.
         */
        function updateBossBullets() {
            try {
                for (let i = 0; i < bossBullets.length; i++) {
                    const bBullet = bossBullets[i];
                    let currentTop = parseFloat(bBullet.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; bBullet.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(bBullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; bBullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(bBullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(bBullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentTop += dy;
                    currentLeft += dx;

                    // Lógica de ricochete APENAS para balas que NÃO SÃO de shotgun
                    if (bBullet.dataset.isShotgun !== 'true' && bBullet.dataset.dx !== '0') { 
                        if (currentLeft <= 0) {
                            currentLeft = 0; 
                            dx *= -1; 
                            bBullet.dataset.dx = dx; 
                        } else if (currentLeft + bBullet.offsetWidth >= gameContainer.offsetWidth) {
                            currentLeft = gameContainer.offsetWidth - bBullet.offsetWidth; 
                            dx *= -1; 
                            bBullet.dataset.dx = dx; 
                        }
                    }

                    bBullet.style.top = `${currentTop}px`;
                    bBullet.style.left = `${currentLeft}px`;

                    // Remove a bala se sair da tela (incluindo as de shotgun que não ricocheteiam)
                    if (currentTop > gameContainer.offsetHeight || currentLeft < -bBullet.offsetWidth || currentLeft > gameContainer.offsetWidth) {
                        bBullet.remove();
                        bossBullets.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const bBulletRect = bBullet.getBoundingClientRect();

                    if (
                        bBulletRect.bottom > playerRect.top &&
                        bBulletRect.top < playerRect.bottom &&
                        bBulletRect.right > playerRect.left &&
                        bBulletRect.left < playerRect.right
                    ) {
                        bBullet.remove();
                        bossBullets.splice(i, 1);
                        i--;

                        let damageToApply = currentBossBulletDamage; 
                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateBossBullets. Defaulting to 0.");
                            damageToApply = 0;
                        }
                        
                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); // Aplica o dano restante na vida/sobrevida
                            }
                        } else { // Sem escudo, aplica na vida/sobrevida
                            health = Math.max(0, health - damageToApply);
                        }
                        
                        updateHealthBarDisplay();
                        console.log("Atingido pelo boss! Vida restante: " + health + ", Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect');
                        }, 150); 
                    }
                }
            } catch (error) {
                console.error("Erro em updateBossBullets:", error);
            }
        }

        /**
         * Lida com a derrota do boss, exibindo a tela de "Stage Clear".
         */
        function handleBossDefeated() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            console.log('handleBossDefeated: gameRunning = false, isBossFightActive =', isBossFightActive); 

            score += 50; 
            scoreValueDisplay.textContent = score; 
            stageScoreDisplay.textContent = score; 

            bossLevel++; 
            playerLevel++; 
            updatePlayerStatsBasedOnLevel(); 
            
            nextBossScoreThreshold = score + Math.ceil(score * 0.5); 
            console.log("Próximo Boss em: " + nextBossScoreThreshold + " pontos.");

            stageClearScreen.classList.remove('hidden'); 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
        }

        /**
         * Atualiza a posição dos segmentos de fundo para criar rolagem infinita com rotação.
         */
        function updateBackgroundSegments() {
            try {
                const gameContainerHeight = gameContainer.offsetHeight;
                const scrollSpeed = backgroundScrollSpeed; 

                backgroundSegments.forEach(segment => {
                    let currentTop = parseFloat(segment.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; segment.style.top = `${currentTop}px`; }
                    currentTop += scrollSpeed;
                    segment.style.top = `${currentTop}px`;

                    if (currentTop >= gameContainer.offsetHeight) {
                        segment.style.top = `${currentTop - (gameContainerHeight * 2) - 1}px`; 
                        segment.classList.toggle('rotated-180'); 
                    }
                });
            } catch (error) {
                console.error("Erro em updateBackgroundSegments:", error);
            }
        }

        /**
         * Atualiza o estado do escudo.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateShield(currentTime) {
            // A lógica de desativação está nos métodos de dano.
        }
        
        /**
         * Loop principal do jogo.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function gameLoop(currentTime) {
            try {
                if (!gameRunning || gamePaused) return;

                console.log('gameLoop: isBossFightActive =', isBossFightActive); 
                updateBackgroundSegments(); 
                updateShield(currentTime); 

                updateFallingObjects(currentTime); 
                updateEnemyBullets(); 
                updateObstacles(); 

                if (!isBossFightActive) {
                    if (currentTime - lastObjectSpawnTime > objectSpawnInterval) {
                        createFallingObject(currentTime); 
                        lastObjectSpawnTime = currentTime;
                    }

                    if (currentTime - lastObstacleSpawnTime > currentObstacleSpawnInterval) { 
                        createObstacle();
                        lastObstacleSpawnTime = currentTime;
                    }
                } else { 
                    console.log('gameLoop: Executing BOSS logic'); 
                    updateBoss(currentTime);
                    updateBossBullets();
                    if (currentTime - lastBossPowerUpDropTime > bossFightPowerUpInterval) {
                        const dropType = Math.random() < 0.7 ? 'health_up' : 'shield'; 
                        const spawnX = Math.random() * (gameContainer.offsetWidth - 30); 
                        createCollectible(spawnX, 0, currentTime, dropType); 
                        lastBossPowerUpDropTime = currentTime;
                    }
                }

                updateCollectibles(currentTime);
                updateBossProgressBar(); 

                if (currentTime - lastShotTime > shootInterval) {
                    createBullet();
                    lastShotTime = currentTime;
                }

                updateBullets(); 
                updatePlayerPosition();
                animationFrameId = requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("Erro crítico no gameLoop:", error);
                showGameOverScreen(); 
            }
        }

        /**
         * Inicia o loop do jogo.
         */
        function startGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Exibe a tela de Fim de Jogo.
         */
        function showGameOverScreen() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            finalScoreDisplay.textContent = score;
            gameOverScreen.classList.remove('hidden');
            backgroundMusic.pause(); 
            backgroundMusic.currentTime = 0; 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
        }

        /**
         * Pausa o jogo.
         */
        function pauseGame() {
            if (gameRunning && !gamePaused) {
                gamePaused = true;
                cancelAnimationFrame(animationFrameId);
                pauseScreen.classList.remove('hidden');
                backgroundMusic.pause();
                bossMusic.pause();
            }
        }

        /**
         * Retoma o jogo.
         */
        function resumeGame() {
            if (gameRunning && gamePaused) {
                gamePaused = false;
                pauseScreen.classList.add('hidden');
                startGameLoop();
                if (isBossFightActive) {
                    bossMusic.play().catch(e => console.log("Erro ao tocar música do boss:", e));
                } else {
                    backgroundMusic.play().catch(e => console.log("Erro ao tocar música de fundo:", e));
                }
            }
        }

        // --- Eventos de Controle ---

        // Controle de Toque (Celular)
        gameContainer.addEventListener('touchstart', (e) => {
            if (!gameRunning || gamePaused) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY; 
            playerMoving = true;
        });

        gameContainer.addEventListener('touchmove', (e) => {
            if (!gameRunning || !playerMoving || gamePaused) return;
            const touchCurrentX = e.touches[0].clientX;
            const touchCurrentY = e.touches[0].clientY; 
            const deltaX = touchCurrentX - touchStartX;
            const deltaY = touchCurrentY - touchStartY; 
            
            playerX += deltaX * 1.0; 
            playerX = Math.max(0, Math.min(playerX, gameContainer.offsetWidth - player.offsetWidth));

            playerY += deltaY * 1.0; 
            playerY = Math.max(0, Math.min(playerY, gameContainer.offsetHeight - player.offsetHeight));

            updatePlayerPosition();
            touchStartX = touchCurrentX;
            touchStartY = touchCurrentY; 
        });

        gameContainer.addEventListener('touchend', () => {
            playerMoving = false;
        });

        // Controle de Teclado (Desktop)
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;
            if (e.key === 'ArrowLeft') {
                playerX = Math.max(0, playerX - playerSpeed * 2);
            } else if (e.key === 'ArrowRight') {
                playerX = Math.min(gameContainer.offsetWidth - player.offsetWidth, playerX + playerSpeed * 2);
            } else if (e.key === 'ArrowUp') { 
                playerY = Math.max(0, playerY - playerSpeed * 2); 
            } else if (e.key === 'ArrowDown') { 
                playerY = Math.min(gameContainer.offsetHeight - player.offsetHeight, playerY + playerSpeed * 2); 
            } else if (e.key === 'p' || e.key === 'P') { 
                pauseGame();
            }
            updatePlayerPosition();
        });

        // Botão Reiniciar
        restartButton.addEventListener('click', initializeGame);
        // Botão Iniciar para a tela inicial
        startScreen.addEventListener('click', () => { // Evento no div startScreen
            initializeGame();
            toggleFullScreen(); 
        }); 
        // Botão Continuar para a tela de Stage Clear
        continueButton.addEventListener('click', () => {
            startNextStage();
            toggleFullScreen(); 
        }); 

        // Botão de Pausa
        pauseButton.addEventListener('click', pauseGame);
        // Botão de Retomar na tela de pausa
        pauseScreen.addEventListener('click', () => { // Evento no div pauseScreen
            resumeGame();
        });

        // Exibe a tela inicial ao carregar
        window.onload = () => {
            startScreen.classList.remove('hidden');
            gameOverScreen.classList.add('hidden'); 
            stageClearScreen.classList.add('hidden'); 
            pauseScreen.classList.add('hidden'); 
            gameRunning = false; 
            gamePaused = false; 
        };
    </script>
</body>
</html>
