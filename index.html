<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navezinhas Doidas</title> <!-- Título do jogo atualizado -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Fonte padrão, mas Press Start 2P para elementos do jogo */
            background-color: #1a202c; /* Cor de fundo escura */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Evita barras de rolagem */
        }

        .game-master-wrapper {
            display: flex;
            flex-direction: column; /* Empilha os contêineres verticalmente */
            border-radius: 1.5rem; /* Cantos mais arredondados para o wrapper geral */
            overflow: hidden; /* Garante que o conteúdo respeite o border-radius */
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.7); /* Sombra mais forte para profundidade */
            border: 4px solid #4a5568; /* Borda mais grossa */
            width: 400px; /* Largura fixa para a área total do jogo */
            height: 700px; /* Altura fixa para a área total do jogo */
            max-width: 95vw; /* Garante que caiba em telas menores */
            max-height: 95vh; /* Garante que caiba em telas menores */
            background-color: #2d3748; /* Fundo para o próprio wrapper */
            position: relative; /* Para sobreposição da tela inicial */
        }

        /* Contêiner principal do jogo */
        .game-area-wrapper {
            flex-grow: 1; /* Ocupa o espaço central restante */
            display: flex;
            flex-direction: column;
            position: relative; /* Para posicionar elementos internos */
            width: 100%;
            height: 100%;
        }

        /* Contêiner do jogo em si (o que rolava antes) */
        .game-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Ocupa o espaço restante entre top e bottom info */
            overflow: hidden;
            pointer-events: auto; /* Permite que o game-container receba eventos de ponteiro */
        }

        /* Estilos existentes (mantidos e ajustados) */
        .background-segment {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('https://i.ibb.co/fYVsCnG4/file-000000003bdc622f9c39eafbf705cd33.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 0;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
            transition: filter 0.5s ease-in-out; /* Adicionado para transição suave */
        }

        .background-segment.rotated-180 {
            transform: rotate(180deg);
        }

        .player {
            position: absolute;
            bottom: 20px;
            width: 60px;
            height: 60px;
            background-image: url('https://i.ibb.co/mrgQRnPP/file-00000000bd8861f8b1feda6cccc966af.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            left: calc(50% - 30px);
            box-shadow: 0 0 15px 5px rgba(99, 179, 237, 0.9), 0 0 25px 10px rgba(99, 179, 237, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 7;
            transition: filter 0.1s ease-out;
            /* REMOVIDO: filter: hue-rotate(...) para não ser afetado pelo estágio */
        }

        .player.player-hit-effect {
            filter: invert(100%) hue-rotate(180deg);
        }

        .player.player-shield-active {
            filter: hue-rotate(200deg) brightness(1.2);
            box-shadow: 0 0 20px 8px rgba(0, 0, 255, 0.9), 0 0 30px 15px rgba(0, 0, 255, 0.5);
        }

        /* NOVO: Efeito visual para o debuff */
        .player.player-debuff-effect {
            filter: grayscale(100%) brightness(50%); /* Exemplo: cinza e escuro */
            box-shadow: 0 0 15px 5px rgba(255, 0, 0, 0.9), 0 0 25px 10px rgba(255, 0, 0, 0.5); /* Sombra vermelha */
        }

        .bullet {
            position: absolute;
            background-color: #f6e05e;
            width: 8px;
            height: 20px;
            border-radius: 0.25rem;
            box-shadow: 0 0 8px 3px rgba(246, 224, 94, 0.9), 0 0 15px 5px rgba(246, 224, 94, 0.5);
            z-index: 5;
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        /* Estilos para os novos tipos de bala */
        .upgraded-bullet { /* Bala azul */
            background-color: #00BFFF; /* Azul vibrante */
            border-radius: 50%; /* Torna-o redondo */
            width: 12px; /* Ligeiramente maior */
            height: 12px;
            box-shadow: 0 0 10px 4px rgba(0, 191, 255, 0.9), 0 0 20px 8px rgba(0, 191, 255, 0.5);
        }

        .advanced-bullet { /* Bala vermelha com brilho amarelo */
            background-color: #FF0000; /* Vermelho */
            border-radius: 50%;
            width: 15px; /* Ligeiramente maior que a azul */
            height: 15px;
            box-shadow: 0 0 10px 4px rgba(255, 0, 0, 0.9), 0 0 20px 8px rgba(255, 255, 0, 0.5); /* Vermelho com brilho amarelo */
        }

        .falling-object {
            position: absolute;
            top: -60px;
            width: 60px;
            height: 60px;
            background-image: url('https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: filter 0.1s ease-out;
            z-index: 2;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        .falling-object.heavy-enemy {
            width: 72px;
            height: 72px;
            z-index: 11; /* Aumentado para garantir que fique visível acima do boss */
            /* border: 2px solid yellow; /* Temporário para depuração */
        }

        .falling-object.heavy-tank-enemy { /* NOVO: Estilo para o inimigo tanque */
            width: 120px; /* Aumentado em 30px */
            height: 120px; /* Aumentado em 30px */
            z-index: 12; /* Acima do heavy enemy */
            background-image: url('https://i.ibb.co/KzBByq4g/Chat-GPT-Image-23-de-jul-de-2025-16-23-34-removebg-preview.png');
        }

        /* NOVO: Estilo para o super inimigo */
        .super-enemy-glow {
            animation: superHueRotate 0.8s infinite linear; /* Apenas rotação de matiz */
            filter: saturate(200%) brightness(150%) hue-rotate(var(--super-hue-rotate, 0deg)); /* Mantém a saturação e brilho */
            /* Removido box-shadow para evitar o "quadrado" */
        }

        @keyframes superHueRotate { /* Renomeado para clareza */
            0% { filter: saturate(200%) brightness(150%) hue-rotate(0deg); }
            25% { filter: saturate(200%) brightness(150%) hue-rotate(90deg); }
            50% { filter: saturate(200%) brightness(150%) hue-rotate(180deg); }
            75% { filter: saturate(200%) brightness(150%) hue-rotate(270deg); }
            100% { filter: saturate(200%) brightness(150%) hue-rotate(360deg); }
        }


        .enemy-health-bar-wrapper {
            position: absolute;
            width: 100%;
            top: -15px;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3;
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        .enemy-health-bar {
            width: 80%;
            height: 5px;
            background-color: #555;
            border-radius: 2.5px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .enemy-health-fill {
            height: 100%;
            background-color: #48bb78;
            width: 100%;
            transition: width 0.1s ease-out, background-color 0.1s ease-out;
        }

        .power-up, .debuff {
            position: absolute;
            width: 36px; /* 20% maior */
            height: 36px; /* 20% maior */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            z-index: 6;
            animation: pulse 1s infinite alternate, neon-glow 1.5s infinite alternate; /* Efeito neon */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /* filter será aplicado via JS para cores específicas */
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        @keyframes pulse {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes neon-glow {
            0% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px var(--neon-color, #00f), 0 0 15px var(--neon-color, #00f); }
            50% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px var(--neon-color, #00f), 0 0 30px var(--neon-color, #00f); }
            100% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px var(--neon-color, #00f), 0 0 15px var(--neon-color, #00f); }
        }

        .game-over-screen, .start-screen, .stage-clear-screen, .pause-screen, .ranking-screen, .settings-screen { /* Adicionado .settings-screen */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            z-index: 30;
            border-radius: 1.5rem;
        }

        .start-screen {
            background-image: url('https://i.ibb.co/JjxJVM6D/1753025379623.png'); /* NOVA IMAGEM DE TELA INICIAL */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .start-screen h1, .start-screen p {
            color: #f6e05e; /* Garante que o texto seja visível sobre a imagem */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); /* Adiciona sombra para legibilidade */
        }

        /* Estilo para o texto "PRESS START" piscando */
        #pressStartText {
            font-size: 1.5rem; /* Tamanho ajustado */
            color: #f6e05e;
            text-shadow: 0 0 8px rgba(246, 224, 94, 0.8);
            animation: blink 1s infinite;
            margin-top: 20px; /* Adiciona um pouco de espaço */
        }

        @keyframes blink {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; } /* CORRIGIDO: Era 'opacity = 0;' */
        }

        .pause-screen, .ranking-screen, .settings-screen { /* Adicionado .settings-screen */
            background-image: url('https://i.ibb.co/JjxJVM6D/1753025379623.png'); /* MESMA IMAGEM DA TELA INICIAL */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Estilo para o texto "CONTINUAR" na tela de pausa */
        #pauseContinueText {
            font-size: 1.5rem; /* Tamanho ajustado */
            color: #f6e05e;
            text-shadow: 0 0 8px rgba(246, 224, 94, 0.8);
            margin-bottom: 20px; /* Espaço para o botão */
        }

        /* Estilos para a tela de Ranking */
        .ranking-screen h1, .ranking-menu-container h2 { /* Ajustado seletor para o novo container */
            font-size: 1.8rem; /* Reduzido para caber melhor */
            margin-bottom: 1.5rem;
            color: #48bb78; /* Verde para o título do ranking */
            text-shadow: 0 0 10px rgba(72, 187, 120, 0.8);
        }

        .ranking-screen ul, .ranking-menu-container ul { /* Ajustado seletor para o novo container */
            list-style: none;
            padding: 0;
            margin: 1rem 0 2rem 0;
            width: 80%;
            max-width: 300px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
        }

        .ranking-screen li, .ranking-menu-container li { /* Ajustado seletor para o novo container */
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #cbd5e0;
            border-bottom: 1px solid rgba(74, 85, 104, 0.5);
        }

        .ranking-screen li:last-child, .ranking-menu-container li:last-child { /* Ajustado seletor para o novo container */
            border-bottom: none;
        }

        .ranking-input-form {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            align-items: center;
            margin-top: 1rem;
        }

        .ranking-input-form input[type="text"] {
            background-color: #2d3748;
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            padding: 0.6rem 1rem;
            color: #cbd5e0;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            text-align: center;
            outline: none;
        }

        .ranking-input-form input::placeholder {
            color: #a0aec0;
        }

        .ranking-input-form button {
            background-color: #f6e05e;
            color: #1a202c;
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .ranking-input-form button:hover {
            background-color: #d69e2e;
            transform: translateY(-2px);
        }


        .game-over-screen h1, .start-screen h1, .stage-clear-screen h1, .pause-screen h1, .settings-screen h1 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #f6e05e;
            text-shadow: 0 0 10px rgba(246, 224, 94, 0.8);
        }

        .game-over-screen p, .stage-clear-screen p, .pause-screen p, .settings-screen p {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .restart-button, .start-button, .continue-button, .pause-button-style, .resume-button, .submit-score-button, .ranking-play-again-button, .back-button, .settings-button { /* Adicionado settings-button */
            background-color: #48bb78;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 12px rgba(72, 187, 120, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .restart-button:hover, .start-button:hover, .continue-button:hover, .pause-button-style:hover, .resume-button:hover, .submit-score-button:hover, .ranking-play-again-button:hover, .back-button:hover, .settings-button:hover {
            background-color: #38a169;
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(72, 187, 120, 0.6);
        }

        .restart-button:active, .start-button:active, .continue-button:active, .pause-button-style:active, .resume-button:active, .submit-score-button:active, .ranking-play-again-button:active, .back-button:active, .settings-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(72, 187, 120, 0.4);
        }

        .hidden {
            display: none !important; /* Adicionado !important para garantir que a tela de carregamento seja escondida */
        }

        .boss {
            position: absolute;
            top: 50px;
            width: 110px; /* 10% maior */
            height: 110px; /* 10% maior */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 10; /* Aumentado para ficar acima de tudo */
            transition: filter 0.1s ease-out;
            pointer-events: none; /* Permite interação com o jogo por baixo */
            animation: bossHueRotate 1.5s infinite linear; /* Animação de cor mais lenta */
        }

        @keyframes bossHueRotate {
            0% { filter: hue-rotate(0deg); }
            25% { filter: hue-rotate(90deg); }
            50% { filter: hue-rotate(180deg); }
            75% { filter: hue-rotate(270deg); }
            100% { filter: hue-rotate(360deg); }
        }


        /* Removida a antiga barra de vida do boss que era filha do boss */
        /* .boss-health-bar-wrapper, .boss-health-bar, .boss-health-fill, .boss-health-text */

        .boss-bullet {
            position: absolute;
            background-image: url('https://placehold.co/15x15/ff0000/FFFFFF/png?text=B');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            box-shadow: 0 0 10px 3px rgba(255, 0, 0, 0.8);
            z-index: 4;
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        .enemy-bullet {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            z-index: 4;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }
        .enemy-bullet-color {
            background-color: #ffcc00;
            box-shadow: 0 0 8px 2px rgba(255, 204, 0, 0.7);
        }

        .enemy-bullet.heavy-enemy-bullet {
            width: 24px; /* AUMENTADO PARA 24px */
            height: 24px; /* AUMENTADO PARA 24px */
        }
        .heavy-enemy-bullet-color {
            background-color: #FF4500; /* Laranja avermelhado vibrante */
            box-shadow: 0 0 15px 6px rgba(255, 69, 0, 0.9), 0 0 25px 10px rgba(255, 69, 0, 0.6); /* Brilho mais intenso */
        }

        .obstacle {
            position: absolute;
            top: -50px;
            width: 45px;
            height: 45px;
            background-image: url('https://i.ibb.co/GQNYF8tQ/file-000000007a5c61f7ab26c44fcda85d3b.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
            z-index: 3;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        /* Estilos para o sistema de partículas de explosão */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Garante que o container de partículas não interfira com eventos do mouse/touch */
            z-index: 15; /* Acima dos inimigos, mas abaixo das telas de menu */
            overflow: hidden; /* Garante que as partículas não saiam do container */
        }

        .particle {
            position: absolute;
            background-color: var(--particle-color); /* Usar variável CSS para a cor da partícula */
            border-radius: 50%;
            opacity: 1;
            transform: scale(1);
            animation: explode 0.8s forwards; /* Duração e preenchimento para manter o estado final */
            box-shadow: 0 0 5px 2px rgba(255, 255, 255, 0.5); /* Brilho discreto (branco semi-transparente) */
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translate(var(--particle-dx), var(--particle-dy)) scale(0);
                opacity: 0;
            }
        }

        /* NOVO: Estilos para as partículas de acerto (hit) */
        .hit-particle {
            position: absolute;
            background-color: var(--particle-color); /* Usa a mesma variável de cor */
            border-radius: 50%;
            opacity: 1;
            /* Z-index ligeiramente maior para garantir visibilidade */
            z-index: 16; 
            animation: hit-spark 0.3s forwards; /* Animação mais rápida */
            box-shadow: 0 0 3px 1px rgba(255, 255, 255, 0.7); /* Brilho mais forte para destaque */
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        @keyframes hit-spark {
            0% {
                transform: translate(0, 0) scale(0.8); /* Começa com tamanho maior para ser visível */
                opacity: 1;
            }
            100% {
                transform: translate(var(--particle-dx), var(--particle-dy)) scale(0); /* Desaparece */
                opacity: 0;
            }
        }

        /* Tela de Carregamento */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a202c; /* Fundo escuro */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #f6e05e;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            text-align: center; /* Centraliza o texto dentro do flex container */
            z-index: 50; /* Acima de tudo */
        }

        #loadingProgressBar {
            width: 80%;
            max-width: 300px;
            height: 20px;
            background-color: #4a5568;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 20px;
            border: 2px solid #a0aec0;
        }

        #loadingProgressFill {
            width: 0%;
            height: 100%;
            background-color: #48bb78;
            border-radius: 8px;
            transition: width 0.1s linear;
        }

        /* Estilos para os checkboxes na tela de configurações */
        .settings-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 80%;
            max-width: 250px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #cbd5e0;
        }

        .settings-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            /* Estilos básicos para o checkbox para que seja visível */
            appearance: none; /* Remove o estilo padrão do navegador */
            background-color: #4a5568;
            border: 2px solid #cbd5e0;
            border-radius: 4px;
            position: relative;
            outline: none;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .settings-option input[type="checkbox"]:checked {
            background-color: #48bb78; /* Cor quando marcado */
            border-color: #48bb78;
        }

        .settings-option input[type="checkbox"]::after {
            content: '\2713'; /* Símbolo de checkmark */
            font-size: 16px;
            color: #1a202c;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.2s ease-in-out;
        }

        .settings-option input[type="checkbox"]:checked::after {
            transform: translate(-50%, -50%) scale(1);
        }

        /* --- NOVOS ESTILOS PARA A NOVA UI --- */

        /* Top UI Panel (Player Image and Status Bars) */
        .top-ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Alinha o topo dos elementos */
            padding: 0.5rem;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 20;
            pointer-events: none; /* Permite interação com o jogo por baixo */
            flex-wrap: wrap; /* Permite que os itens quebrem linha em telas menores */
        }

        /* Player Image Container */
        .player-image-container {
            width: 80px;
            height: 80px;
            background-color: rgba(74, 85, 104, 0.7); /* Fundo semi-transparente */
            border: 2px solid #f6e05e; /* Borda amarela */
            box-shadow: 0 0 10px rgba(246, 224, 94, 0.5); /* Sombra amarela */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .player-image {
            width: 90%;
            height: 90%;
            background-image: url('https://i.ibb.co/JWNLLWbk/imagem-2025-07-23-184522402.png'); /* Imagem da nave do jogador */
            background-size: cover; /* Garante que a imagem preencha o container */
            background-position: center;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); /* Recorta a imagem na forma do losango */
        }

        /* Container para as barras de status (Vida, Estágio, Escudo) */
        .top-bars-container { /* NOVO: Para agrupar as 3 barras e centralizar o player image */
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Alinha as barras à direita */
            gap: 8px; /* Espaçamento entre as barras */
            width: calc(100% - 100px); /* Largura total do game-container - largura do player-image-container - margens */
            max-width: 250px; /* Limita a largura para não ficar muito grande */
        }

        /* Ajuste para centralizar o player-image-container verticalmente */
        .top-ui-panel {
            align-items: center; /* Centraliza verticalmente os itens no top-ui-panel */
        }


        .status-bar-wrapper {
            width: 100%; /* Ocupa a largura total calculada do status-bars-panel */
            height: 18px; /* Altura fixa das barras */
            background-color: rgba(85, 85, 85, 0.7); /* Fundo semi-transparente */
            border-radius: 9px; /* Metade da altura para cantos arredondados */
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
        }

        .status-bar-fill {
            height: 100%;
            width: 100%; /* Será ajustado via JS */
            border-radius: 8px; /* Ligeiramente menor que o wrapper */
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
        }

        .status-bar-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-size: 0.6rem; /* Aumentado para 0.6rem */
            z-index: 2;
            white-space: nowrap; /* Garante que o texto não quebre linha */
            line-height: 1; /* Garante que o texto ocupe apenas uma linha verticalmente */
        }

        /* Cores específicas para as barras */
        #healthBarFill { background-color: #48bb78; } /* Verde */
        #shieldBarFill { background-color: #00BFFF; } /* Azul para o escudo */
        #bossActualHealthBarFill { background-color: #FF0000; } /* Vermelho para a barra de vida do boss */


        /* Estilo para a barra de sobrevida (overshield) */
        #overshieldBarFill {
            position: absolute;
            height: 100%;
            width: 0%; /* Será ajustado via JS */
            background-color: #8A2BE2; /* Roxo vibrante */
            border-radius: 8px;
            transition: width 0.2s ease-out;
            z-index: 1; /* Acima da barra de vida normal */
        }

        /* NOVA BARRA DE VIDA DO BOSS VERTICAL (mantida para a transição, mas será horizontal) */
        .boss-health-bar-vertical-wrapper {
            position: absolute;
            right: 10px; /* Alinha à direita */
            top: 50%; /* Centraliza verticalmente */
            transform: translateY(-50%); /* Ajusta para centralização exata */
            width: 20px; /* Largura da barra vertical */
            height: 40%; /* Altura da barra vertical (aumentado para ser mais visível) */
            background-color: rgba(85, 85, 85, 0.7);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            flex-direction: column-reverse; /* Preenche de baixo para cima */
            align-items: center;
            justify-content: flex-start;
            z-index: 25; /* Acima de outros elementos da UI */
            pointer-events: none;
        }

        .boss-health-bar-vertical-fill {
            width: 100%;
            height: 0%; /* Começa vazia, preenche de baixo para cima */
            background-color: #FF0000; /* Vermelho */
            transition: height 0.2s ease-out;
            border-radius: 9px;
            /* Efeito neon para a barra de vida do boss */
            box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.7), 0 0 15px 8px rgba(255, 0, 0, 0.4);
        }

        .boss-health-bar-vertical-text {
            display: none; /* Removido o texto numérico da barra de vida do boss */
        }


        /* NOVO: Game Footer (Rodapé) */
        .game-footer {
            display: flex;
            flex-direction: column; /* Empilha os itens verticalmente */
            justify-content: flex-end; /* Alinha itens ao final do contêiner flex */
            align-items: center; /* Centraliza itens horizontalmente */
            padding: 0.75rem 1rem; /* Padding ajustado */
            width: 100%;
            background-color: rgba(45, 55, 72, 0.7); /* Fundo escuro semi-transparente */
            border-top: 2px solid #4a5568;
            border-bottom-left-radius: 1.5rem; /* Cantos arredondados do wrapper mestre */
            border-bottom-right-radius: 1.5rem;
            z-index: 20;
            font-family: 'Press Start 2P', cursive;
            color: #cbd5e0;
            font-size: 0.7rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: auto; /* Permite que os elementos do rodapé recebam eventos */
            position: relative; /* Adicionado para posicionamento absoluto dos filhos */
        }

        /* Nova linha para os stats do jogador e botão de pausa */
        .footer-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Ocupa toda a largura do footer */
            padding-top: 0.5rem; /* Espaçamento entre a barra de boss e esta linha */
        }

        .player-stats-footer {
            display: flex;
            align-items: center;
            justify-content: center; /* Centraliza Lv e Dmg */
            flex-grow: 1; /* Permite que ocupe espaço disponível para centralizar */
            gap: 1.5rem; /* Espaçamento entre Lv e Dmg */
        }

        /* Estilo para o botão de pausa no rodapé */
        .pause-button-style {
            background-color: rgba(246, 224, 94, 0.8); /* Amarelo semi-transparente */
            color: #1a202c;
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
        }
        .pause-button-style:hover {
            background-color: #f6e05e;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
        }

        /* Media query para esconder o botão de pausa no desktop */
        @media (min-width: 769px) {
            .pause-button-style {
                display: none; /* Esconde o botão de pausa em desktop */
            }
        }

        /* Estilo para a barra de progresso do estágio no top-ui-panel (antiga barra de escudo) */
        .stage-progress-bar { /* Nova classe para o posicionamento no top-ui-panel */
            width: 100%; /* Ocupa a largura total */
            height: 18px; /* Altura da barra */
            background-color: rgba(85, 85, 85, 0.7);
            border-radius: 9px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            color: #cbd5e0;
            font-size: 0.5rem; /* Reduzido para caber no espaço */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 21; /* Acima do top-ui-panel */
            pointer-events: none;
            /* Removido margin-top, o gap do status-bars-panel cuidará do espaçamento */
        }

        .stage-progress-bar .status-bar-fill {
            background-color: #FF69B4; /* Rosa */
        }

        .stage-progress-bar .status-bar-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-size: 0.5rem;
            z-index: 2;
            white-space: nowrap;
            line-height: 1;
        }

        /* Estilo para a barra de vida do boss horizontal no rodapé */
        .boss-health-bar-horizontal-wrapper {
            width: 100%; /* Ocupa a largura total do footer */
            height: 18px; /* Altura da barra */
            background-color: rgba(85, 85, 85, 0.7);
            border-radius: 9px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Preenche da esquerda para a direita */
            z-index: 25;
            pointer-events: none;
            margin-bottom: 0.5rem; /* Espaçamento entre a barra e a linha de baixo */
        }

        .boss-health-bar-horizontal-fill {
            width: 0%; /* Começa vazia */
            height: 100%;
            background-color: #FF0000; /* Vermelho */
            transition: width 0.2s ease-out;
            border-radius: 9px;
            box-shadow: 0 0 8px 4px rgba(255, 0, 0, 0.7), 0 0 15px 8px rgba(255, 0, 0, 0.4);
        }

        .boss-health-bar-horizontal-text {
            position: absolute; /* Para posicionar o texto sobre a barra */
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-size: 0.6rem; /* Mesma fonte das outras barras */
            z-index: 2;
            white-space: nowrap;
            line-height: 1;
        }

        /* Estilos para o container do menu de pausa e ranking */
        .menu-container { /* Classe genérica para menus centralizados */
            background-color: rgba(0, 0, 0, 0.7); /* Fundo preto com transparência */
            padding: 2rem;
            border-radius: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
            margin-top: 20px; /* Espaço do topo */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #f6e05e; /* Borda amarela */
        }

        .menu-item { /* Classe genérica para itens de menu */
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: #f6e05e; /* Amarelo */
            text-shadow: 0 0 8px rgba(246, 224, 94, 0.8);
            cursor: pointer;
            transition: transform 0.1s ease, color 0.1s ease;
        }

        .menu-item:hover {
            transform: scale(1.05);
            color: #fff; /* Brilho ao passar o mouse */
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.9), 0 0 20px rgba(246, 224, 94, 0.8);
        }

        /* Estilos específicos para o ranking dentro do menu-container */
        .ranking-menu-container ul { /* Ajusta a lista de ranking dentro do novo container */
            margin-top: 1rem; /* Espaçamento do título */
            margin-bottom: 1rem; /* Espaçamento para os botões */
            width: 100%; /* Ocupa a largura total do container */
        }

        .ranking-menu-container li {
            font-size: 0.9rem; /* Um pouco maior para melhor leitura */
            padding: 0.4rem 0.8rem;
        }

        /* NOVO: Estilo para o display de falas do chefe */
        #bossTauntDisplay {
            position: absolute;
            top: 20%; /* Posição ajustável */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #f6e05e;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #f6e05e;
            text-align: center;
            max-width: 80%;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 40; /* Acima de tudo, mas abaixo das telas de menu */
            pointer-events: none; /* Permite interação com o jogo por baixo */
        }

        #bossTauntDisplay.visible {
            opacity: 1;
        }

    </style>
</head>
<body>
    <div class="game-master-wrapper">
        <!-- Tela de Carregamento -->
        <div id="loadingScreen">
            <p>Carregando Recursos...</p>
            <div id="loadingProgressBar">
                <div id="loadingProgressFill"></div>
            </div>
        </div>

        <div class="game-area-wrapper">
            <!-- Top UI Panel -->
            <div class="top-ui-panel">
                <div class="player-image-container">
                    <div class="player-image"></div>
                </div>

                <!-- Container para as barras de status (Vida, Escudo, Estágio) -->
                <div class="top-bars-container">
                    <!-- Health Bar -->
                    <div class="status-bar-wrapper" id="healthBarWrapper">
                        <div class="status-bar-fill" id="healthBarFill"></div>
                        <div class="status-bar-fill" id="overshieldBarFill"></div> <!-- Nova barra para overshield -->
                        <span class="status-bar-text">Vida: <span id="playerHealthText">100/100</span></span> <!-- CORREÇÃO: Removido "Vida: " duplicado -->
                    </div>

                    <!-- Shield Bar (NOVA) -->
                    <div class="status-bar-wrapper hidden" id="shieldBarWrapper">
                        <div class="status-bar-fill" id="shieldBarFill"></div>
                        <span class="status-bar-text">Escudo: <span id="shieldHealthText">0/100</span></span>
                    </div>

                    <!-- Stage Progress Bar -->
                    <div class="status-bar-wrapper stage-progress-bar" id="stageProgressBarWrapper">
                        <div class="status-bar-fill" id="stageProgressBarFill"></div>
                        <span class="status-bar-text">Stage: <span id="stageProgressValue">0/50</span></span>
                    </div>
                </div>
            </div>

            <!-- NOVO: Display de falas do chefe -->
            <div id="bossTauntDisplay" class="hidden"></div>

            <div class="game-container" id="gameContainer">
                <div class="background-segment" id="bgSegment1"></div>
                <div class="background-segment" id="bgSegment2"></div>

                <div class="player" id="player">
                </div>

                <div class="particle-container" id="particleContainer"></div>

                <div class="start-screen" id="startScreen">
                    <p id="pressStartText">PRESS START</p>
                    <!-- Botão de configurações removido da tela inicial -->
                </div>

                <div class="game-over-screen hidden" id="gameOverScreen">
                    <h1>FIM DE JOGO!</h1>
                    <p>Sua Pontuação: <span id="finalScore">0</span></p>
                    <button class="restart-button" id="restartButton">JOGAR NOVAMENTE</button>
                    <button class="screen-button" id="showRankingButton">VER RANKING</button> </div>

                <div class="stage-clear-screen hidden" id="stageClearScreen">
                    <h1>ESTÁGIO CONCLUÍLDO!</h1>
                    <p>Pontuação do Estágio: <span id="stageScore">0</span></p>
                    <button class="continue-button" id="continueButton">CONTINUAR</button>
                </div>

                <div class="pause-screen hidden" id="pauseScreen">
                    <div class="menu-container">
                        <div class="menu-item" id="resumeGameMenuItem">Resumir Jogo</div>
                        <div class="menu-item" id="settingsMenuItem">Configurações</div>
                        <div class="menu-item" id="restartGameMenuItem">Reiniciar</div>
                        <div class="menu-item" id="viewRankingMenuItem">Ver Ranking</div>
                    </div>
                </div>

                <div class="ranking-screen hidden" id="rankingScreen">
                    <div class="menu-container ranking-menu-container">
                        <h1>TOP 10 PONTUAÇÕES</h1>
                        <ul id="highScoresList">
                            </ul>
                        <div class="ranking-input-form hidden" id="nameInputForm">
                            <p>Parabéns! Você entrou no Top 10!</p>
                            <input type="text" id="playerNameInput" placeholder="Seu nome" maxlength="10">
                            <button id="submitScoreButton">Enviar Pontuação</button>
                        </div>
                        <div class="menu-item" id="rankingPlayAgainMenuItem">JOGAR NOVAMENTE</div>
                        <div class="menu-item" id="backFromRankingMenuItem">VOLTAR</div>
                    </div>
                </div>
                
                <!-- Nova Tela de Configurações -->
                <div class="settings-screen hidden" id="settingsScreen">
                    <div class="menu-container"> <!-- NOVO: Container para o menu de configurações -->
                        <h1>CONFIGURAÇÕES DE SOM</h1>
                        <div class="settings-option">
                            <span>Som do Tiro:</span>
                            <input type="checkbox" id="toggleShotSound">
                        </div>
                        <div class="settings-option">
                            <span>Música do Ambiente:</span>
                            <input type="checkbox" id="toggleAmbientMusic">
                        </div>
                        <div class="settings-option">
                            <span>Som de Explosão:</span>
                            <input type="checkbox" id="toggleExplosionSound">
                        </div>
                        <div class="menu-item" id="backToPreviousScreenFromSettings">VOLTAR</div> <!-- Usando menu-item -->
                    </div>
                </div>
            </div>

            <!-- NOVO: Game Footer -->
            <div class="game-footer">
                <!-- Barra de Vida do Boss Horizontal (agora no rodapé) -->
                <div class="status-bar-wrapper boss-health-bar-horizontal-wrapper hidden" id="bossHealthBarHorizontalWrapper">
                    <div class="status-bar-fill" id="bossHealthBarHorizontalFill"></div>
                    <span class="boss-health-bar-horizontal-text" id="bossHealthBarHorizontalText"></span> <!-- Texto reintroduzido da barra -->
                </div>
                <!-- Player Stats (Lv and Dmg) e Botão de Pausa -->
                <div class="footer-bottom-row">
                    <div class="player-stats-footer">
                        <div>Lv <span id="playerLevelDisplay">1</span></div>
                        <div>Dmg: <span id="playerDamageDisplay">1</span></div>
                    </div>
                    <!-- Pause Button -->
                    <button class="pause-button-style" id="pauseButton">||</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyAv0ptf_r0wd4smm24uJBIpUtKuSNVr5iY",
            authDomain: "navizinhas.firebaseapp.com",
            projectId: "navizinhas",
            storageBucket: "navizinhas.firebasestorage.app",
            messagingSenderId: "890224253385",
            appId: "1:890224253385:web:34f00091c09694aab43018",
            measurementId: "G-GE8MVDE7TV"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId = null;
        // __app_id é fornecido pelo ambiente Canvas, se disponível.
        // Caso contrário, usamos o projectId do FirebaseConfig como um fallback seguro.
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;


        // Authenticate anonymously
        // onAuthStateChanged will be triggered automatically on Firebase init
        // We ensure signInAnonymously is called if no token is provided.
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("Firebase authenticated. User ID:", userId);
            } else {
                try {
                    // __initial_auth_token é fornecido pelo ambiente Canvas para autenticação customizada.
                    // Se não estiver disponível, fazemos login anonimamente.
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token !== null) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                    userId = auth.currentUser.uid;
                    console.log("Firebase authenticated anonymously. User ID:", userId);
                } catch (error) {
                    console.error("Firebase authentication error:", error);
                    // Log the specific Firebase error for debugging
                    console.error("Firebase authentication error details:", error.code, error.message);
                    // Even if authentication fails, the game should try to run, just without ranking.
                }
            }
        });


        // Referências aos elementos DOM (declaradas no escopo global para serem acessíveis)
        let gameContainer;
        let player;
        let playerDamageDisplay;
        let playerLevelDisplay;
        // let playerPowerDisplay; // Removido, não é mais exibido diretamente

        let gameOverScreen;
        let finalScoreDisplay;
        let restartButton;
        let startScreen;
        let stageClearScreen;
        let continueButton;
        let pauseButton;
        let pauseScreen;

        // Referências aos elementos da nova UI de barras
        let healthBarFill;
        let overshieldBarFill;
        let playerHealthText;
        // NOVO: Referências para a barra de escudo
        let shieldBarWrapper;
        let shieldBarFill;
        let shieldHealthText;

        // NOVAS REFERÊNCIAS PARA A BARRA DE VIDA DO BOSS (agora horizontal)
        let bossHealthBarHorizontalWrapper;
        let bossHealthBarHorizontalFill;
        let bossHealthBarHorizontalText; // REINTRODUZIDO: Texto numérico da barra do boss

        // NOVAS REFERÊNCIAS PARA A BARRA DE PROGESSO DO ESTÁGIO (antiga barra de escudo)
        let stageProgressBarWrapper;
        let stageProgressBarFill;
        let stageProgressValue;


        let pressStartText;
        // let pauseContinueText; // REMOVIDO: Texto "CONTINUAR" da tela de pausa
        let rankingScreen;
        let highScoresList;
        let nameInputForm;
        let playerNameInput;
        let submitScoreButton;
        let rankingPlayAgainButton;
        let showRankingButton;
        // let backToStartScreenButton; // REMOVIDO: Botão "VOLTAR AO INÍCIO"

        // NOVO: Referências para os itens do menu de pausa
        let resumeGameMenuItem;
        let settingsMenuItem;
        let restartGameMenuItem;
        let viewRankingMenuItem;

        // NOVO: Referências para os itens do menu de ranking
        let rankingPlayAgainMenuItem;
        let backFromRankingMenuItem;


        let stageScoreDisplay;

        // Referência ao novo contêiner de partículas
        let particleContainer;

        // Referências para a tela de carregamento
        let loadingScreen;
        let loadingProgressFill;

        // Referências para os elementos da tela de configurações
        // let settingsButton; // REMOVIDO: Botão de configurações da tela inicial
        let settingsScreen;
        let toggleShotSoundCheckbox;
        let toggleAmbientMusicCheckbox;
        let toggleExplosionSoundCheckbox;
        let backToPreviousScreenFromSettings; // Renomeado para evitar conflito com o elemento HTML

        // Variável para rastrear a tela anterior antes de ir para as configurações
        let previousScreen = null;

        // NOVO: Referência para o display de falas do chefe
        let bossTauntDisplay;


        // Segmentos de fundo
        const bgSegment1 = document.getElementById('bgSegment1');
        const bgSegment2 = document.getElementById('bgSegment2');
        const backgroundSegments = [bgSegment1, bgSegment2];
        
        // Variáveis de estado do jogo
        let score = 0;
        let health = 0; 
        let maxHealth = 100; 
        let maxOvershieldHealth = 200; 
        let gameRunning = false;
        let playerX; 
        let playerY; 
        let playerSpeed = 8; 
        let gamePaused = false; 
        
        // Velocidades base e ajustadas
        const baseEnemyMovementSpeed = 5; 
        const baseEnemyBulletSpeed = 5;   
        const baseObstacleSpawnInterval = 2500; 
        let backgroundScrollSpeed = 2; 

        // Velocidades e intervalos ajustados (podem ser modificados pela dificuldade)
        let currentEnemyMovementSpeed = baseEnemyMovementSpeed * 0.8 * 0.7; 
        let currentEnemyBulletSpeed = baseEnemyBulletSpeed * 1.4;     
        let collectibleMovementSpeed = 0; 
        let currentObstacleSpawnInterval = baseObstacleSpawnInterval; 

        let objectSpawnInterval = 1500; 
        let lastObjectSpawnTime = 0;
        let fallingObjects = []; 
        let obstacles = []; 
        let animationFrameId;

        // Variáveis de tiro do jogador
        let bullets = []; 
        let bulletSpeed = 10; 
        let shootInterval = 300; 
        let lastShotTime = 0;
        let bulletDamage = 1; // Dano de uma única bala, será calculado com base no estágio
        let slantedBulletsActive = false; 
        
        // NOVAS VARIÁVEIS PARA O SISTEMA DE TIROS
        let currentBulletStage = 0; // 0: normal, 1: azul, 2: vermelho/amarelo
        let currentSideShotsLevel = 0; // 0: 1 tiro, 1: 2 tiros, 2: 3 tiros
        let damage1Bonus = 0; // Bônus de dano do power-up '+1'

        // Configurações dos estágios de bala
        const bulletConfigurations = [
            // Estágio 0: Bala Normal (Amarela)
            {
                type: 'normal',
                baseDamage: 1,
                className: 'bullet',
                bulletSize: { width: 8, height: 20 },
                powerText: 'Normal'
            },
            // Estágio 1: Bala Aprimorada (Azul)
            {
                type: 'upgraded-blue',
                baseDamage: 3, // Dano base para este estágio (somado ao nível e bônus)
                className: 'upgraded-bullet',
                bulletSize: { width: 12, height: 12 },
                powerText: 'Azul'
            },
            // Estágio 2: Bala Avançada (Vermelha/Amarela)
            {
                type: 'advanced-red',
                baseDamage: 5, // Dano base para este estágio (somado ao nível e bônus)
                className: 'advanced-bullet',
                bulletSize: { width: 15, height: 15 },
                powerText: 'Vermelha'
            }
        ];


        // Variáveis de coletáveis
        let collectibles = []; 
        let collectibleDropChance = 0.07; 
        const collectibleStationaryDuration = 5000; 

        // Variáveis do Boss
        let boss = null;
        let bossHealth = 0;
        const initialBossHealth = 400; // Alterado para 400
        let bossBullets = [];
        let bossShootInterval = 3000; 
        let lastBossShotTime = 0;
        let isBossFightActive = false;
        let bossMovementDirection = 1; 
        let bossVerticalDirection = 1; // Novo: para movimento vertical do boss
        const bossMovementSpeed = 2.5; 
        const bossRageMovementSpeed = 3.5; // Nova velocidade para modo de raiva
        const bossPadding = 10; 
        let bossLevel = 0; 
        const initialBossBulletDamage = 20; 
        let currentBossBulletDamage = initialBossBulletDamage; 
        let nextBossScoreThreshold = 50; 
        let bossRageThreshold = 0; 
        let bossRageActive = false; 
        let lastBossPowerUpDropTime = 0; 
        const bossFightPowerUpInterval = 10000; 

        // Valores de rotação de matiz do Boss para diferentes níveis
        const bossHueRotations = [0, 90, 180, 270, 30]; 
        const enemySprites = [ // Sprites para o boss aleatório
            'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png', // Normal enemy
            'https://i.ibb.co/LztRMfLf/file-000000003cc4622f93ccd51271bb76c1.png', // Heavy enemy
            'https://i.ibb.co/KzBByq4g/Chat-GPT-Image-23-de-jul-de-2025-16-23-34-removebg-preview.png' // Heavy Tank enemy
        ];


        // Variável de nível do jogador
        let playerLevel = 1;

        // Variáveis de bala do inimigo
        let enemyBullets = []; 

        // Variáveis de obstáculo
        const obstacleDamage = 20; 
        let lastObstacleSpawnTime = 0;

        // Variáveis do Escudo
        let shieldActive = false;
        let shieldHealth = 0;
        const maxShieldHealth = 100;

        // Variável para controlar se um heavy enemy está na tela
        let isHeavyEnemyOnScreen = false; 

        // Definição do novo inimigo pesado
        const heavyEnemyDefinition = {
            type: 'heavy_enemy',
            hits: 100, 
            sprite: 'https://i.ibb.co/LztRMfLf/file-000000003cc4622f93ccd51271bb76c1.png', 
            width: 72, 
            height: 72, 
            speed: 1.95, // Horizontal speed
            verticalSpeed: 0.75, // NEW: Vertical oscillation speed
            verticalMovementRangePercentage: 0.18, // NEW: 18% of gameContainer height for vertical movement
            shootInterval: 1000, 
            baseBulletDamage: 20, /* AUMENTADO PARA 20 */
            hueRotations: [0, 90, 180],
            bulletSpeed: 10 // NOVO: Velocidade da bala do heavy enemy
        };

        // NOVO: Definição do inimigo tanque
        const heavyTankEnemyDefinition = {
            type: 'heavy_tank_enemy',
            hits: 400, // HP inicial (aumentado em 100%)
            sprite: 'https://i.ibb.co/KzBByq4g/Chat-GPT-Image-23-de-jul-de-2025-16-23-34-removebg-preview.png',
            width: 120, // Aumentado em 30
            height: 120, // Aumentado em 30
            speed: 1.0, // Velocidade horizontal mais lenta
            verticalSpeed: 0.5, // Velocidade vertical mais lenta
            verticalMovementRangePercentage: 0.15, // Menor alcance vertical
            shootInterval: 1500, // Frequência de ataque (reduzido para 1.5s)
            baseBulletDamage: 10, // Metade do dano do heavy enemy (20 / 2)
            hueRotations: [0, 45, 90], // 3 versões de croma
            bulletSpeed: 10 // NOVO: Velocidade da bala do heavy tank
        };

        // Dano base das balas inimigas (para escalonamento)
        const baseEnemyBulletDamage = 10; 

        // Tipos de power-ups com cores neon e rotação de matiz
        const powerUpTypes = [
            { type: 'damage_1', text: '+1', color: '#FF4500', damageIncrease: 1, sprite: 'https://i.ibb.co/tpmGNwnx/file-00000000c23c61f79d81df79065596e4.png', hueRotate: 0 }, // Laranja
            { type: 'side_bullets', text: '>>', color: '#FFFF00', damageIncrease: 0, sprite: 'https://i.ibb.co/6JGv0Nk7/file-00000000f4c461f7a9330c93bf5d848c.png', hueRotate: 0 }, // Amarelo
            { type: 'shield', text: 'ESC', color: '#0000FF', damageIncrease: 0, sprite: 'https://i.ibb.co/HfN8Wkv3/file-00000000553861f787335877cf43f0566.png', hueRotate: 0 }, // Azul
        ];
        // Novo tipo de power-up de vida (adicionado separadamente para controle de spawn)
        const healthPowerUpType = { type: 'health_up', text: '❤️', color: '#00FF00', healthIncrease: 20, sprite: 'https://i.ibb.co/RpmCgPyD/file-00000000fdf061f59a3de32e7e743922-1.png', hueRotate: 0 }; // Verde

        // Tipo de debuff
        const debuffType = { type: 'damage_down', text: '-1', color: '#FF0000', damageDecrease: 1, sprite: 'https://i.ibb.co/FbvqcCqK/file-000000007ee861fdb4cec6e89e0ac0ba.png', hueRotate: 0 }; // Vermelho

        // Tipos de inimigos e suas propriedades (hits necessários, cor base, rotação de matiz)
        const enemyTypes = [
            { scoreThreshold: 0, hits: 1, hueRotate: 0, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 20, hits: 2, hueRotate: 60, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 40, hits: 3, hueRotate: 120, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 60, hits: 4, hueRotate: 180, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 80, hits: 5, hueRotate: 240, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }  
        ];

        // Cores de fundo do cenário para indicar níveis avançados (mais coloridas)
        const backgroundPresets = [
            'linear-gradient(to bottom, #4a90e2 0%, #2e6cb8 100%)', 
            'linear-gradient(to bottom, #7ed321 0%, #5cb82e 100%)', 
            'linear-gradient(to bottom, #f5a623 0%, #d08b1a 100%)', 
            'linear-gradient(to bottom, #bd10e0 0%, #9a0db8 100%)', 
            'linear-gradient(to bottom, #50e3c2 0%, #3bb29c 100%)', 
            'linear-gradient(to bottom, #f8e71c 0%, #d0c015 100%)', 
            'linear-gradient(to bottom, #9013fe 0%, #6b0bc4 100%)'  
        ];
        let currentColorIndex = 0;
        let currentStageHueRotation = 0; 
        const stageHueRotationIncrement = 60; 

        // Variáveis para controle de toque
        let touchStartX = 0;
        let touchStartY = 0; 
        let playerMoving = false;

        // Referência aos recursos de áudio e imagem para pré-carregamento (APENAS IMAGENS E MÚSICAS DE FUNDO/BOSS)
        const ASSETS_TO_PRELOAD = [
            'https://i.ibb.co/fYVsCnG4/file-000000003bdc622f9c39eafbf705cd33.png', // background-segment
            'https://i.ibb.co/mrgQRnPP/file-00000000bd8861f8b1feda6cccc966af.png', // player
            'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png', // falling-object (inimigo normal)
            'https://i.ibb.co/WWJbQ2xC/file-0000000084d061f8ac4929730520d69e.png', // boss
            'https://i.ibb.co/LztRMfLf/file-000000003cc4622f93ccd51271bb76c1.png', // heavy_enemy
            'https://i.ibb.co/GQNYF8tQ/file-000000007a5c61f7ab26c44fcda85d3b.png', // obstacle
            'https://i.ibb.co/tpmGNwnx/file-00000000c23c61f79d81df79065596e4.png', // power-up damage_1
            'https://i.ibb.co/6JGv0Nk7/file-00000000f4c461f7a9330c93bf5d848c.png', // power-up side_bullets
            'https://i.ibb.co/HfN8Wkv3/file-00000000553861f787335877cf43f0566.png', // power-up shield
            'https://i.ibb.co/RpmCgPyD/file-00000000fdf061f59a3de32e7e743922-1.png', // power-up health_up
            'https://i.ibb.co/FbvqcCqK/file-000000007ee861fdb4cec6e89e0ac0ba.png', // debuff
            'https://i.ibb.co/JjxJVM6D/1753025379623.png', // start-screen background
            'https://cdn.pixabay.com/audio/2025/05/29/audio_dc0f9df613.mp3', // backgroundMusic (NOVO URL)
            'https://cdn.pixabay.com/audio/2021/10/08/audio_293093f302.mp3', // bossMusic (NOVO URL)
            'https://cdn.pixabay.com/audio/2025/05/12/audio_93c74aa0b8.mp3', // enemyExplosionSound (NOVO URL)
            'https://i.ibb.co/KzBByq4g/Chat-GPT-Image-23-de-jul-de-2025-16-23-34-removebg-preview.png', // heavy_tank_enemy
            'https://i.ibb.co/JWNLLWbk/imagem-2025-07-23-184522402.png' // player_profile_image
        ];

        // Referência ao elemento de áudio
        const backgroundMusic = new Audio(); 
        backgroundMusic.loop = true; 
        backgroundMusic.volume = 0.5; 

        // Sons de tiro serão carregados dinamicamente
        const playerShotSound = new Audio(); 
        playerShotSound.volume = 0.3;

        const enemyShotSound = new Audio(); 
        enemyShotSound.volume = 0.2;

        const bossMusic = new Audio(); 
        bossMusic.loop = true;
        bossMusic.volume = 0.6;
        
        // Novo som de explosão de inimigo
        const enemyExplosionSound = new Audio();
        enemyExplosionSound.volume = 0.4;

        // Variáveis de controle de som
        let isShotSoundEnabled = true;
        let isAmbientMusicEnabled = true;
        let isExplosionSoundEnabled = true; // Nova variável para o som de explosão
        const SOUND_SETTINGS_KEY = 'tiroNoMetrôSoundSettings';

        /**
         * Carrega as configurações de som do localStorage.
         */
        function loadSoundSettings() {
            const savedSettings = localStorage.getItem(SOUND_SETTINGS_KEY);
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                isShotSoundEnabled = settings.isShotSoundEnabled;
                isAmbientMusicEnabled = settings.isAmbientMusicEnabled;
                isExplosionSoundEnabled = settings.isExplosionSoundEnabled; // Carrega a nova configuração
            }
        }

        /**
         * Salva as configurações de som no localStorage.
         */
        function saveSoundSettings() {
            const settings = {
                isShotSoundEnabled: isShotSoundEnabled,
                isAmbientMusicEnabled: isAmbientMusicEnabled,
                isExplosionSoundEnabled: isExplosionSoundEnabled // Salva a nova configuração
            };
            localStorage.setItem(SOUND_SETTINGS_KEY, JSON.stringify(settings));
        }

        /**
         * Atualiza o estado dos checkboxes de som na tela de configurações.
         */
        function updateSoundSettingsUI() {
            if (toggleShotSoundCheckbox) {
                toggleShotSoundCheckbox.checked = isShotSoundEnabled;
            }
            if (toggleAmbientMusicCheckbox) {
                toggleAmbientMusicCheckbox.checked = isAmbientMusicEnabled;
            }
            if (toggleExplosionSoundCheckbox) { // Atualiza o novo checkbox
                toggleExplosionSoundCheckbox.checked = isExplosionSoundEnabled;
            }
        }

        /**
         * Realiza um fade-out suave em um elemento de áudio.
         * @param {HTMLAudioElement} audio - O elemento de áudio a ser desvanecido.
         * @param {function} callback - Função a ser chamada após o fade-out.
         */
        function fadeOut(audio, callback) {
            const fadeDuration = 500; // ms
            const fadeInterval = 50; // ms
            const originalVolume = audio.volume; // Salva o volume original
            let currentVolume = audio.volume;

            const fadeAudio = setInterval(() => {
                currentVolume -= originalVolume * (fadeInterval / fadeDuration);
                if (currentVolume <= 0) {
                    audio.volume = 0;
                    audio.pause();
                    audio.currentTime = 0; // Reseta a música
                    clearInterval(fadeAudio);
                    if (callback) callback();
                } else {
                    audio.volume = currentVolume;
                }
            }, fadeInterval);
        }

        /**
         * Realiza um fade-in suave em um elemento de áudio.
         * @param {HTMLAudioElement} audio - O elemento de áudio a ser desvanecido.
         * @param {number} targetVolume - O volume final desejado.
         * @param {function} callback - Função a ser chamada após o fade-in.
         */
        function fadeIn(audio, targetVolume, callback) {
            const fadeDuration = 500; // ms
            const fadeInterval = 50; // ms
            let currentVolume = 0;
            audio.volume = 0;
            audio.play().catch(e => console.log("Erro ao tentar tocar música (fadeIn):", e));

            const fadeAudio = setInterval(() => {
                currentVolume += targetVolume * (fadeInterval / fadeDuration);
                if (currentVolume >= targetVolume) {
                    audio.volume = targetVolume;
                    clearInterval(fadeAudio);
                    if (callback) callback();
                } else {
                    audio.volume = currentVolume;
                }
            }, fadeInterval);
        }

        /**
         * Aplica as configurações de música imediatamente.
         */
        function applyMusicSettings() {
            if (isAmbientMusicEnabled) {
                if (gameRunning && !gamePaused) { // Só toca se o jogo estiver rodando e não pausado
                    if (isBossFightActive) {
                        // Se a música de fundo estiver tocando, faça fadeOut antes de tocar a do boss
                        if (!backgroundMusic.paused && backgroundMusic.volume > 0) {
                            fadeOut(backgroundMusic, () => {
                                fadeIn(bossMusic, 0.6); 
                            });
                        } else {
                            fadeIn(bossMusic, 0.6); 
                        }
                    } else {
                        // Se a música do boss estiver tocando, faça fadeOut antes de tocar a de fundo
                        if (!bossMusic.paused && bossMusic.volume > 0) {
                            fadeOut(bossMusic, () => {
                                fadeIn(backgroundMusic, 0.5); 
                            });
                        } else {
                            fadeIn(backgroundMusic, 0.5); 
                        }
                    }
                }
            } else {
                backgroundMusic.pause();
                bossMusic.pause();
            }
        }


        /**
         * Pré-carrega todos os assets do jogo e os armazena no Cache Storage.
         * Atualiza uma barra de progresso durante o carregamento.
         * @returns {Promise<void>} Uma promessa que resolve quando todos os assets estão carregados.
         */
        async function preloadAssets() {
            const cacheName = 'tiro-no-metro-assets-v1'; // Nome do cache
            let loadedCount = 0;
            const totalAssets = ASSETS_TO_PRELOAD.length;

            try {
                const cache = await caches.open(cacheName); // Abre ou cria o cache

                const fetchPromises = ASSETS_TO_PRELOAD.map(async (url) => { 
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.warn(`Falha ao carregar asset: ${url}. Status: ${response.status}`);
                        return; 
                    }
                    await cache.put(url, response.clone()); 

                    // Para áudios que DEVEM ser pré-carregados (músicas de fundo/boss/explosão)
                    if (url.includes('audio_dc0f9df613.mp3')) { 
                        backgroundMusic.src = url;
                        await backgroundMusic.load();
                    } else if (url.includes('audio_293093f302.mp3')) { 
                        bossMusic.src = url;
                        await bossMusic.load();
                    } else if (url.includes('audio_93c74aa0b8.mp3')) { 
                        enemyExplosionSound.src = url;
                        await enemyExplosionSound.load();
                    }

                    loadedCount++;
                    const progress = (loadedCount / totalAssets) * 100;
                    if (loadingProgressFill) {
                        loadingProgressFill.style.width = `${progress}%`;
                    }
                    console.log(`Carregado: ${url} (${loadedCount}/${totalAssets})`);
                });

                await Promise.all(fetchPromises);
                console.log("Todos os assets pré-carregados e cacheados!");

            } catch (error) {
                console.error("Erro durante o pré-carregamento de assets:", error);
                console.warn("Tentando carregar assets diretamente devido a erro no cache ou CORS.");
                // Fallback: carregar diretamente sem cache, usando as URLs atualizadas
                ASSETS_TO_PRELOAD.forEach(url => {
                    if (url.endsWith('.mp3')) {
                        if (url.includes('audio_dc0f9df613.mp3')) backgroundMusic.src = url;
                        else if (url.includes('audio_293093f302.mp3')) bossMusic.src = url;
                        else if (url.includes('audio_93c74aa0b8.mp3')) enemyExplosionSound.src = url;
                    } else {
                        const img = new Image();
                        img.src = url;
                    }
                });
            }
        }


        /**
         * Solicita o modo tela cheia para o documento.
         */
        function toggleFullScreen() {
            const element = document.documentElement; 

            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) { 
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) { 
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { 
                element.msRequestFullscreen();
            }
        }

        /**
         * Atualiza as estatísticas do jogador com base no nível atual.
         */
        function updatePlayerStatsBasedOnLevel() {
            maxHealth = 100 + (playerLevel - 1) * 20; 
            maxOvershieldHealth = maxHealth * 2; 

            // Calcula o dano da bala: Dano base do estágio + Dano do nível do jogador + Bônus de dano +1
            // O dano do nível do jogador é o dano mínimo e não pode ser diminuído.
            const levelDamage = playerLevel - 1; 
            bulletDamage = bulletConfigurations[currentBulletStage].baseDamage + levelDamage + damage1Bonus;
            bulletDamage = Math.max(1, bulletDamage); 
        }

        /**
         * Inicializa o estado do jogo para um novo jogo.
         */
        function initializeGame() {
            score = 0;
            playerLevel = 1; 
            bossLevel = 0; 
            nextBossScoreThreshold = 50; 
            currentStageHueRotation = 0; 
            document.documentElement.style.setProperty('--stage-hue-rotation', `${currentStageHueRotation}deg`); 

            // Reseta as variáveis do novo sistema de tiros
            currentBulletStage = 0;
            currentSideShotsLevel = 0;
            damage1Bonus = 0;

            updatePlayerStatsBasedOnLevel(); 
            health = maxHealth; 
            slantedBulletsActive = false; 
            
            // Reseta variáveis do escudo
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 
            
            updateHealthBarDisplay(); 
            updateShieldBarDisplay(); 
            updatePlayerDamageDisplay(); 
            playerLevelDisplay.textContent = playerLevel; 
            updateStageProgressBar(); 
            bossHealthBarHorizontalWrapper.classList.add('hidden'); 

            // Reinicializa as velocidades e intervalos para os valores base ajustados
            currentEnemyMovementSpeed = baseEnemyMovementSpeed * 0.8 * 0.7; 
            currentEnemyBulletSpeed = baseEnemyBulletSpeed * 1.4;
            currentObstacleSpawnInterval = baseObstacleSpawnInterval; 
            objectSpawnInterval = 1500; 
            
            currentBossBulletDamage = initialBossBulletDamage;

            clearGameElements(); 
            isBossFightActive = false; 
            
            gameOverScreen.classList.add('hidden');
            startScreen.classList.add('hidden'); 
            stageClearScreen.classList.add('hidden'); 
            pauseScreen.classList.add('hidden'); 
            rankingScreen.classList.add('hidden'); 
            nameInputForm.classList.add('hidden'); 
            settingsScreen.classList.add('hidden'); 

            playerX = gameContainer.offsetWidth / 2 - player.offsetWidth / 2;
            playerY = gameContainer.offsetHeight - player.offsetHeight - 20; 
            player.style.left = `${playerX}px`;
            player.style.bottom = `${20}px`; 

            // Inicializa os segmentos de fundo
            backgroundSegments[0].style.top = '0px';
            backgroundSegments[1].style.top = `${-gameContainer.offsetHeight}px`; 
            backgroundSegments[0].classList.remove('rotated-180');
            backgroundSegments[1].classList.add('rotated-180'); 
            
            gameRunning = true;
            gamePaused = false; 
            lastObjectSpawnTime = performance.now(); 
            lastShotTime = performance.now(); 
            lastObstacleSpawnTime = performance.now(); 
            startGameLoop();
            console.log('initializeGame: isBossFightActive =', isBossFightActive); 

            applyMusicSettings(); 
        }

        /**
         * Prepara o jogo para o próximo estágio.
         */
        function startNextStage() {
            console.log('startNextStage started.'); 
            isBossFightActive = false; 
            console.log('startNextStage: isBossFightActive set to', isBossFightActive); 
            clearGameElements(); 
            
            health = maxHealth; 
            // Reseta variáveis do escudo
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 

            // Reseta variáveis do Boss
            bossRageActive = false;
            lastBossPowerUpDropTime = 0;
            isHeavyEnemyOnScreen = false; 
            
            // O estágio e nível de tiros laterais NÃO são resetados aqui.

            updateHealthBarDisplay();
            updateShieldBarDisplay(); 
            updatePlayerDamageDisplay();
            playerLevelDisplay.textContent = playerLevel;
            updateStageProgressBar(); 
            bossHealthBarHorizontalWrapper.classList.add('hidden'); 

            // Aumenta a dificuldade dos inimigos em 10% por nível do boss (que é o próximo estágio)
            currentEnemyMovementSpeed = baseEnemyMovementSpeed * (0.8 + (bossLevel * 0.1)); 
            currentEnemyBulletSpeed = baseEnemyBulletSpeed * (1.4 + (bossLevel * 0.2)); 
            objectSpawnInterval = Math.max(400, 1500 - (bossLevel * 100)); 
            currentObstacleSpawnInterval = Math.max(1000, baseObstacleSpawnInterval - (bossLevel * 200)); 

            currentStageHueRotation = (currentStageHueRotation + stageHueRotationIncrement) % 360;
            document.documentElement.style.setProperty('--stage-hue-rotation', `${currentStageHueRotation}deg`); 

            stageClearScreen.classList.add('hidden'); 
            gameRunning = true;
            gamePaused = false; 
            lastObjectSpawnTime = performance.now(); 
            lastShotTime = performance.now(); 
            lastObstacleSpawnTime = performance.now(); 
            startGameLoop();
            console.log('startNextStage: Game loop restarted.'); 

            applyMusicSettings(); 
        }

        /**
         * Limpa todos os elementos de jogo (inimigos, balas, coletáveis, etc.).
         */
        function clearGameElements() {
            // Remove elementos do DOM e limpa arrays
            fallingObjects.forEach(obj => { if(obj.parentNode) obj.parentNode.removeChild(obj); });
            fallingObjects = [];
            bullets.forEach(bullet => { if(bullet.parentNode) bullet.parentNode.removeChild(bullet); }); 
            bullets = [];
            collectibles.forEach(col => { if(col.parentNode) col.parentNode.removeChild(col); });
            collectibles = [];
            enemyBullets.forEach(b => { if(b.parentNode) b.parentNode.removeChild(b); }); 
            enemyBullets = [];
            obstacles.forEach(o => { if(o.parentNode) o.parentNode.removeChild(o); }); 
            obstacles = [];

            if (boss) {
                if(boss.parentNode) boss.parentNode.removeChild(boss);
                boss = null;
            }
            // A barra de vida do boss real não é mais filha do boss, então não precisa ser removida aqui.
            // Apenas escondida.
            // const existingBossHealthBarWrapper = document.getElementById('bossHealthBarWrapper');
            // if (existingBossHealthBarWrapper) {
            //     if(existingBossHealthBarWrapper.parentNode) existingBossHealthBarWrapper.parentNode.removeChild(existingBossHealthBarWrapper); 
            // }
            bossBullets.forEach(b => { if(b.parentNode) b.parentNode.removeChild(b); });
            bossBullets = [];
            console.log('clearGameElements called. isBossFightActive before removal:', isBossFightActive); 
        }

        /**
         * Atualiza a posição do jogador.
         */
        function updatePlayerPosition() {
            player.style.left = `${playerX}px`;
            player.style.bottom = `${gameContainer.offsetHeight - playerY - player.offsetHeight}px`;
        }

        /**
         * Verifica se dois retângulos se sobrepõem.
         * @param {Object} rect1 - Primeiro retângulo {left, top, width, height}.
         * @param {Object} rect2 - Segundo retângulo {left, top, width, height}.
         * @returns {boolean} True se houver sobreposição, false caso contrário.
         */
        function isOverlapping(rect1, rect2) {
            return rect1.left < rect2.left + rect2.width &&
                   rect1.left + rect1.width > rect2.left &&
                   rect1.top < rect2.top + rect2.height &&
                   rect1.top + rect1.height > rect2.top;
        }

        /**
         * Cria um novo objeto em caída (inimigo) com dificuldade variável.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         * @param {boolean} [isBossSummon=false] - Indica se o inimigo está sendo sumonado pelo boss.
         * @param {Object} [bossStats=null] - Contém {health, damage} do boss se for sumonado por ele.
         */
        function createFallingObject(currentTime, isBossSummon = false, bossStats = null) {
            if (isHeavyEnemyOnScreen && !isBossSummon) {
                // Se já há um heavy enemy ou heavy tank e não é uma invocação do boss,
                // tenta criar um inimigo normal em vez de um heavy enemy/tank.
                // Isso garante que inimigos comuns continuem surgindo.
            }
            if (isBossSummon && isHeavyEnemyOnScreen) {
                console.log("Boss attempted to summon heavy enemy, but one is already on screen, skipping.");
                return; 
            }

            const object = document.createElement('div');
            object.classList.add('falling-object');
            
            let selectedEnemyType;
            let isHeavyEnemy = false;
            let isHeavyTankEnemy = false;
            let isSuperEnemy = false; 
            let spawned = false;
            let maxAttempts = 20; 

            let tempLeft, tempTop, tempWidth, tempHeight; 

            if (isBossSummon) {
                selectedEnemyType = heavyEnemyDefinition; 
                isHeavyEnemy = true;
                object.classList.add('heavy-enemy');
                object.dataset.movementDirection = (Math.random() < 0.5 ? 1 : -1);
                tempWidth = selectedEnemyType.width * 0.8; 
                tempHeight = selectedEnemyType.height * 0.8; 
                tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                tempTop = 50; 
                object.dataset.verticalMovementDirection = (Math.random() < 0.5 ? 1 : -1); 
                object.dataset.initialTop = tempTop; 

                object.dataset.hitsRemaining = Math.max(1, Math.round(bossStats.health * 0.10));
                object.dataset.initialHits = Math.max(1, Math.round(bossStats.health * 0.10));
                object.dataset.baseBulletDamage = heavyEnemyDefinition.baseBulletDamage; 
                object.dataset.isBossSummoned = 'true'; 
                object.dataset.speedMultiplier = 1; 

                const chosenHueIndex = Math.floor(Math.random() * selectedEnemyType.hueRotations.length);
                selectedEnemyType.hueRotate = selectedEnemyType.hueRotations[chosenHueIndex];

            } else { 
                const specialEnemySpawnChance = 0.07; 
                const superEnemyChance = 0.10; 

                if (bossLevel >= 1 && Math.random() < specialEnemySpawnChance && !isHeavyEnemyOnScreen) {
                    if (bossLevel >= 2 && Math.random() < 0.5) { 
                        selectedEnemyType = heavyTankEnemyDefinition;
                        isHeavyTankEnemy = true;
                        object.classList.add('heavy-tank-enemy');
                    } else { 
                        selectedEnemyType = heavyEnemyDefinition;
                        isHeavyEnemy = true;
                        object.classList.add('heavy-enemy');
                    }

                    // NOVO: Lógica para Super Inimigo (só a partir do estágio 4)
                    if (bossLevel >= 3 && Math.random() < superEnemyChance) { // Estágio 4 é bossLevel 3
                        isSuperEnemy = true;
                        object.classList.add('super-enemy-glow'); 
                        object.dataset.isSuper = 'true';
                        console.log("SUPER INIMIGO SPAWNADO!");
                    }

                    object.dataset.movementDirection = (Math.random() < 0.5 ? 1 : -1);
                    tempWidth = selectedEnemyType.width;
                    tempHeight = selectedEnemyType.height;
                    tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                    tempTop = 50; 
                    object.dataset.verticalMovementDirection = (Math.random() < 0.5 ? 1 : -1); 
                    object.dataset.initialTop = tempTop; 

                    const chosenHueIndex = Math.floor(Math.random() * selectedEnemyType.hueRotations.length);
                    selectedEnemyType.hueRotate = selectedEnemyType.hueRotations[chosenHueIndex];

                    let strengthMultiplier = 1;
                    if (isHeavyTankEnemy) {
                        strengthMultiplier = 1 + (bossLevel * 0.1);
                    } else if (isHeavyEnemy) {
                        strengthMultiplier = 1 + (bossLevel * 0.25);
                        const additionalHeavyStrength = Math.random() < 0.1 ? 1.1 : 1;
                        strengthMultiplier *= additionalHeavyStrength;
                    }
                    
                    // Aplica multiplicadores de Super Inimigo
                    if (isSuperEnemy) {
                        object.dataset.hitsRemaining = selectedEnemyType.hits * strengthMultiplier * 10; 
                        object.dataset.initialHits = selectedEnemyType.hits * strengthMultiplier * 10;
                        object.dataset.baseBulletDamage = selectedEnemyType.baseBulletDamage * 2; 
                        object.dataset.speedMultiplier = 1.2; 
                    } else {
                        object.dataset.hitsRemaining = selectedEnemyType.hits * strengthMultiplier;
                        object.dataset.initialHits = selectedEnemyType.hits * strengthMultiplier;
                        object.dataset.baseBulletDamage = selectedEnemyType.baseBulletDamage;
                        object.dataset.speedMultiplier = 1;
                    }
                    
                } else { 
                    tempWidth = 60;
                    tempHeight = 60;
                    tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                    tempTop = -tempHeight;

                    let availableEnemyLevels = [];
                    for (let j = 0; j < enemyTypes.length; j++) {
                        if (score >= enemyTypes[j].scoreThreshold) {
                            availableEnemyLevels.push(enemyTypes[j]);
                        }
                    }

                    if (availableEnemyLevels.length === 0) {
                        availableEnemyLevels.push(enemyTypes[0]);
                    }

                    const enemiesToSpawnFrom = availableEnemyLevels.slice(Math.max(0, availableEnemyLevels.length - 3));
                    selectedEnemyType = enemiesToSpawnFrom[Math.floor(Math.random() * enemiesToSpawnFrom.length)];

                    const strengthMultiplier = 1 + (bossLevel * 0.20);
                    object.dataset.hitsRemaining = selectedEnemyType.hits * strengthMultiplier;
                    object.dataset.initialHits = selectedEnemyType.hits * strengthMultiplier;
                    object.dataset.baseBulletDamage = baseEnemyBulletDamage; 
                    object.dataset.speedMultiplier = 1;
                }
            }

            for (let i = 0; i < maxAttempts; i++) {
                let currentAttemptLeft = Math.random() * (gameContainer.offsetWidth - tempWidth); 
                let currentAttemptTop = -tempHeight; 
                if (isHeavyEnemy || isHeavyTankEnemy) { 
                    currentAttemptTop = tempTop; 
                }

                const hypotheticalRect = {
                    left: currentAttemptLeft,
                    top: currentAttemptTop,
                    width: tempWidth,
                    height: tempHeight
                };

                let overlap = false;
                for (const existingObj of fallingObjects) {
                    const existingRect = {
                        left: parseFloat(existingObj.style.left),
                        top: parseFloat(existingObj.style.top),
                        width: existingObj.offsetWidth,
                        height: existingObj.offsetHeight
                    };
                    const padding = 5;
                    if (isOverlapping(
                        {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                        {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                    )) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    for (const existingObstacle of obstacles) {
                        const existingRect = {
                            left: parseFloat(existingObstacle.style.left),
                            top: parseFloat(existingObstacle.style.top),
                            width: existingObstacle.offsetWidth,
                            height: existingObstacle.offsetHeight
                        };
                        const padding = 5;
                        if (isOverlapping(
                            {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                            {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                        )) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (!overlap) {
                    object.style.left = `${currentAttemptLeft}px`;
                    object.style.top = `${currentAttemptTop}px`;
                    object.style.width = `${tempWidth}px`;
                    object.style.height = `${tempHeight}px`;
                    spawned = true;
                    break;
                }
            }

            if (!spawned) {
                console.warn("Não foi possível spawnar inimigo sem sobreposição após tentativas.");
                return; 
            }

            object.dataset.hitsRemaining = Math.round(object.dataset.hitsRemaining);
            object.dataset.initialHits = Math.round(object.dataset.initialHits);
            object.dataset.baseBulletDamage = Math.round(object.dataset.baseBulletDamage);
            object.dataset.speedMultiplier = parseFloat(object.dataset.speedMultiplier);

            object.style.backgroundImage = `url('${selectedEnemyType.sprite}')`;
            object.style.backgroundColor = 'transparent';
            object.style.backgroundSize = 'contain';
            object.style.backgroundRepeat = 'no-repeat';
            object.style.backgroundPosition = 'center';
            object.style.filter = `hue-rotate(${selectedEnemyType.hueRotate}deg)`;

            const enemyHealthBarWrapper = document.createElement('div');
            enemyHealthBarWrapper.classList.add('enemy-health-bar-wrapper');
            const enemyHealthBar = document.createElement('div');
            enemyHealthBar.classList.add('enemy-health-bar');
            const enemyHealthFill = document.createElement('div');
            enemyHealthFill.classList.add('enemy-health-fill');
            enemyHealthBar.appendChild(enemyHealthFill);
            enemyHealthBarWrapper.appendChild(enemyHealthBar);
            object.appendChild(enemyHealthBarWrapper);

            object.dataset.hasShot = 'false';
            object.dataset.shootTimer = currentTime + (isHeavyEnemy || isHeavyTankEnemy ? selectedEnemyType.shootInterval : 1000); 
            object.dataset.shootType = isHeavyEnemy ? 'straight' : (isHeavyTankEnemy ? 'shotgun' : (Math.random() < 0.5 ? 'straight' : 'diagonal')); 
            object.dataset.isHeavy = isHeavyEnemy ? 'true' : 'false'; 
            object.dataset.isHeavyTank = isHeavyTankEnemy ? 'true' : 'false'; 

            gameContainer.appendChild(object);
            fallingObjects.push(object);

            if (isHeavyEnemy || isHeavyTankEnemy) { 
                isHeavyEnemyOnScreen = true; 
                console.log(`Heavy ${isHeavyTankEnemy ? 'Tank' : 'Enemy'} spawned. isHeavyEnemyOnScreen = true. Position: Left:`, object.style.left, "Top:", object.style.top);
            }
        }

        /**
         * Cria uma nova bala do jogador.
         */
        function createBullet() {
            const bulletBottom = gameContainer.offsetHeight - playerY - player.offsetHeight + 10;
            const currentConfig = bulletConfigurations[currentBulletStage];
            
            const createSingleBullet = (xOffset, initialDx) => {
                const bullet = document.createElement('div');
                bullet.classList.add('bullet', currentConfig.className); 
                
                // Define o tamanho da bala com base na configuração do estágio
                bullet.style.width = `${currentConfig.bulletSize.width}px`;
                bullet.style.height = `${currentConfig.bulletSize.height}px`;

                bullet.style.left = `${playerX + player.offsetWidth / 2 - currentConfig.bulletSize.width / 2 + xOffset}px`;
                bullet.style.bottom = `${bulletBottom}px`; 
                
                let dx = initialDx;
                bullet.dataset.dx = dx;
                bullet.dataset.dy = bulletSpeed; 
                gameContainer.appendChild(bullet);
                bullets.push(bullet);
                // Carrega e toca o som de tiro do player dinamicamente
                if (isShotSoundEnabled) { 
                    playerShotSound.src = 'https://cdn.pixabay.com/audio/2024/08/30/audio_68d83e5b2d.mp3'; 
                    playerShotSound.currentTime = 0; 
                    playerShotSound.play().catch(e => console.log("Erro ao tocar som de tiro do player:", e));
                }
            };

            // Bala central
            createSingleBullet(0, 0); 

            // Tiros laterais baseados no nível atual de tiros laterais
            if (currentSideShotsLevel >= 1) { 
                createSingleBullet(-20, 0); 
            }
            if (currentSideShotsLevel >= 2) { 
                createSingleBullet(20, 0);  
            }

            // Tiros inclinados (se ativos) - esta lógica não foi alterada
            if (slantedBulletsActive) { 
                createSingleBullet(-20, -2); 
                createSingleBullet(20, 2);  
            }
        }

        /**
         * Converte um valor hexadecimal de cor para RGBA.
         * @param {string} hex - A cor em formato hexadecimal (ex: '#RRGGBB' ou '#RGB').
         * @param {number} alpha - O valor do canal alfa (0 a 1).
         * @returns {string} A cor em formato RGBA (ex: 'rgba(255, 0, 0, 0.7)').
         */
        function hexToRgba(hex, alpha = 1) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            }
            else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        /**
         * Cria um coletável (power-up ou debuff).
         * @param {number} x - Posição X para spawnar o coletável.
         * @param {number} y - Posição Y para spawnar o coletável.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         * @param {string} [forcedType=null] - Tipo de power-up a ser forçado (ex: 'health_up').
         */
        function createCollectible(x, y, currentTime, forcedType = null) {
            const collectible = document.createElement('div');
            const powerUpSize = 36; 
            collectible.style.width = `${powerUpSize}px`;
            collectible.style.height = `${powerUpSize}px`;
            collectible.style.left = `${x}px`;
            collectible.style.top = `${y}px`; 
            collectible.dataset.spawnTime = currentTime; 
            collectible.dataset.isStationary = 'true'; 
            collectible.style.pointerEvents = 'none';

            let selectedCollectibleType;

            if (forcedType) { 
                selectedCollectibleType = [...powerUpTypes, healthPowerUpType, debuffType].find(type => type.type === forcedType);
                if (!selectedCollectibleType) { 
                    selectedCollectibleType = powerUpTypes[0]; 
                }
            } else { 
                const healthDropProbability = 0.30; 
                const debuffDropProbability = 0.40; 
                const rand = Math.random();

                if (rand < healthDropProbability) { 
                    selectedCollectibleType = healthPowerUpType;
                } else if (rand < healthDropProbability + debuffDropProbability) { 
                    selectedCollectibleType = debuffType;
                } else { 
                    const otherPowerUps = powerUpTypes.filter(type => type.type !== 'health_up' && type.type !== 'damage_down' && type.type !== 'shield'); 
                    selectedCollectibleType = otherPowerUps[Math.floor(Math.random() * otherPowerUps.length)];
                }
            }
            
            collectible.dataset.type = selectedCollectibleType.type; 
            if (collectible.classList.contains('debuff')) {
                collectible.classList.add('debuff');
            } else {
                collectible.classList.add('power-up');
            }
            collectible.style.backgroundImage = `url('${selectedCollectibleType.sprite}')`; 
            collectible.style.backgroundColor = 'transparent'; 
            collectible.style.backgroundSize = 'contain';
            collectible.style.backgroundRepeat = 'no-repeat';
            collectible.style.backgroundPosition = 'center';
            collectible.innerHTML = ''; 

            // Aplica o brilho neon e saturação com filtro de color
            collectible.style.setProperty('--neon-color', selectedCollectibleType.color);
            // Aplica o filtro de color para o power-up
            let hueRotateValue = 0;
            switch(selectedCollectibleType.type) {
                case 'health_up': hueRotateValue = 120; break; 
                case 'side_bullets': hueRotateValue = 60; break; 
                case 'damage_1': hueRotateValue = 30; break; 
                case 'shield': hueRotateValue = 240; break; 
                case 'damage_down': hueRotateValue = 0; break; 
            }
            collectible.style.filter = `saturate(200%) brightness(150%) hue-rotate(${hueRotateValue}deg)`; 

            gameContainer.appendChild(collectible);
            collectibles.push(collectible);
        }

        /**
         * Cria um obstáculo.
         */
        function createObstacle() {
            const obstacle = document.createElement('div');
            obstacle.classList.add('obstacle');
            obstacle.style.pointerEvents = 'none';
            
            const baseSize = 45;
            let tempWidth = baseSize + Math.random() * baseSize; 
            let tempHeight = tempWidth; 
            let spawned = false;
            let maxAttempts = 10;

            for (let i = 0; i < maxAttempts; i++) {
                let tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth); 
                let tempTop = -tempHeight; 

                const hypotheticalRect = {
                    left: tempLeft,
                    top: tempTop,
                    width: tempWidth,
                    height: tempHeight
                };

                let overlap = false;
                for (const existingObstacle of obstacles) {
                    const existingRect = {
                        left: parseFloat(existingObstacle.style.left),
                        top: parseFloat(existingObstacle.style.top),
                        width: existingObstacle.offsetWidth,
                        height: existingObstacle.offsetHeight
                    };
                    const padding = 5;
                    if (isOverlapping(
                        {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                        {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                    )) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    for (const existingObj of fallingObjects) {
                        const existingRect = {
                            left: parseFloat(existingObj.style.left),
                            top: parseFloat(existingObj.style.top),
                            width: existingObj.offsetWidth,
                            height: existingObj.offsetHeight
                        };
                        const padding = 5;
                        if (isOverlapping(
                            {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                            {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                        )) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (!overlap) {
                    obstacle.style.left = `${tempLeft}px`;
                    obstacle.style.top = `${tempTop}px`;
                    obstacle.style.width = `${tempWidth}px`;
                    obstacle.style.height = `${tempHeight}px`;
                    spawned = true;
                    break;
                }
            }

            if (!spawned) {
                console.warn("Não foi possível spawnar obstáculo sem sobreposição após tentativas.");
                return; 
            }

            const randomHue = Math.floor(Math.random() * 360);
            obstacle.style.filter = `hue-rotate(${randomHue}deg) var(--stage-hue-rotation)`; 

            gameContainer.appendChild(obstacle);
            obstacles.push(obstacle);
        }

        /**
         * Cria um projétil de um inimigo normal ou pesado.
         * @param {HTMLElement} enemyObject - O elemento DOM do inimigo que está atirando.
         * @param {boolean} [isHeavyBullet=false] - Indica se é uma bala de inimigo pesado.
         */
        function createEnemyBullet(enemyObject, isHeavyBullet = false) {
            const enemyBullet = document.createElement('div');
            enemyBullet.classList.add('enemy-bullet');
            
            let bulletSpeed = currentEnemyBulletSpeed; // Velocidade padrão

            if (isHeavyBullet) {
                enemyBullet.classList.add('heavy-enemy-bullet'); 
                enemyBullet.classList.add('heavy-enemy-bullet-color'); 
                enemyBullet.dataset.baseBulletDamage = enemyObject.dataset.baseBulletDamage;
                bulletSpeed = heavyEnemyDefinition.bulletSpeed; // Usa a bulletSpeed do heavy enemy
            } else if (enemyObject.dataset.isHeavyTank === 'true') { 
                enemyBullet.classList.add('heavy-enemy-bullet'); 
                enemyBullet.classList.add('heavy-enemy-bullet-color'); 
                enemyBullet.dataset.baseBulletDamage = enemyObject.dataset.baseBulletDamage;
                bulletSpeed = heavyTankEnemyDefinition.bulletSpeed; // Usa a bulletSpeed do heavy tank
            } else {
                enemyBullet.classList.add('enemy-bullet-color'); 
            }
            
            let enemyLeft = parseFloat(enemyObject.style.left);
            if (isNaN(enemyLeft)) { enemyLeft = 0; enemyObject.style.left = `${enemyLeft}px`; }
            let enemyTop = parseFloat(enemyObject.style.top);
            if (isNaN(enemyTop)) { enemyTop = -60; enemyObject.style.top = `${enemyTop}px`; }

            const bulletSize = (isHeavyBullet || enemyObject.dataset.isHeavyTank === 'true') ? 24 : 12; 
            enemyBullet.style.left = `${enemyLeft + (enemyObject.offsetWidth / 2) - (bulletSize / 2)}px`;
            enemyBullet.style.top = `${enemyTop + enemyObject.offsetHeight}px`;
            enemyBullet.style.pointerEvents = 'none';
            
            let dx = 0;
            // A velocidade vertical agora usa a bulletSpeed definida e o multiplicador de velocidade do inimigo
            let dy = bulletSpeed * (parseFloat(enemyObject.dataset.speedMultiplier || 1)); 

            // Aplica a redução de 60% para balas de inimigos pesados/tanques
            if (isHeavyBullet || enemyObject.dataset.isHeavyTank === 'true') {
                dy *= 0.40; // Reduz a velocidade em 60%
            }

            if (enemyObject.dataset.shootType === 'shotgun') { 
                createShotgunEnemyBullets(enemyObject); 
                return; 
            }
            else if (!isHeavyBullet && enemyObject.dataset.shootType === 'diagonal') { 
                dx = (Math.random() < 0.5 ? -1 : 1) * (currentEnemyBulletSpeed * 0.5); 
                dy = currentEnemyBulletSpeed * 0.866; 
            }
            enemyBullet.dataset.dx = dx;
            enemyBullet.dataset.dy = dy;
            enemyBullet.dataset.isHeavyBullet = isHeavyBullet; 
            enemyBullet.dataset.isHeavyTank = enemyObject.dataset.isHeavyTank; 
            gameContainer.appendChild(enemyBullet);
            enemyBullets.push(enemyBullet);
            if (isShotSoundEnabled) { 
                enemyShotSound.src = 'https://cdn.pixabay.com/audio/2024/08/30/audio_68d83e5b2d.mp3'; 
                enemyShotSound.currentTime = 0; 
                enemyShotSound.play().catch(e => console.log("Erro ao tocar som de tiro do inimigo:", e));
            }
        }

        /**
         * NOVO: Cria 10 balas do inimigo em todas as direções (ataque "shotgun").
         * @param {HTMLElement} enemyObject - O elemento DOM do inimigo que está atirando.
         */
        function createShotgunEnemyBullets(enemyObject) {
            let enemyLeft = parseFloat(enemyObject.style.left);
            let enemyTop = parseFloat(enemyObject.style.top);

            const startX = enemyLeft + enemyObject.offsetWidth / 2;
            const startY = enemyTop + enemyObject.offsetHeight / 2; 
            const numBullets = 8; 
            const angleIncrement = (Math.PI * 2) / numBullets; 
            // A velocidade base agora usa a bulletSpeed definida para o tipo de inimigo e o multiplicador de velocidade
            let baseSpeed = (enemyObject.dataset.isHeavyTank === 'true' ? heavyTankEnemyDefinition.bulletSpeed : heavyEnemyDefinition.bulletSpeed) * parseFloat(enemyObject.dataset.speedMultiplier || 1); 
            baseSpeed *= 0.40; // Aplica a redução de 60%

            for (let i = 0; i < numBullets; i++) {
                const angle = i * angleIncrement;

                const dx = Math.cos(angle) * baseSpeed;
                const dy = Math.sin(angle) * baseSpeed;

                const enemyBullet = document.createElement('div');
                enemyBullet.classList.add('enemy-bullet', 'heavy-enemy-bullet', 'heavy-enemy-bullet-color'); 
                enemyBullet.style.left = `${startX - (24 / 2)}px`; 
                enemyBullet.style.top = `${startY - (24 / 2)}px`; 
                enemyBullet.dataset.dx = dx;
                enemyBullet.dataset.dy = dy;
                enemyBullet.dataset.isHeavyBullet = 'true'; 
                enemyBullet.dataset.baseBulletDamage = heavyTankEnemyDefinition.baseBulletDamage; 
                enemyBullet.style.pointerEvents = 'none';
                gameContainer.appendChild(enemyBullet);
                enemyBullets.push(enemyBullet);
            }
            if (isShotSoundEnabled) { 
                enemyShotSound.src = 'https://cdn.pixabay.com/audio/2024/08/30/audio_68d83e5b2d.mp3'; 
                enemyShotSound.currentTime = 0; 
                enemyShotSound.play().catch(e => console.log("Erro ao tocar som de tiro do inimigo:", e));
            }
        }


        /**
         * Cria e anima partículas de explosão no local de um inimigo derrotado.
         * @param {number} x - Posição X do inimigo.
         * @param {number} y - Posição Y do inimigo.
         * @param {string} color - Cor base das partículas (ex: '#FF0000').
         */
        function createParticles(x, y, color) {
            const numberOfParticles = 15;
            const particleSize = 5 + Math.random() * 10; 

            for (let i = 0; i < numberOfParticles; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                
                // Posição inicial da partícula no centro do inimigo
                particle.style.left = `${x + (Math.random() * 20 - 10)}px`; 
                particle.style.top = `${y + (Math.random() * 20 - 10)}px`;
                particle.style.width = `${particleSize}px`;
                particle.style.height = `${particleSize}px`;
                // Define a cor da partícula usando a variável CSS --particle-color
                particle.style.setProperty('--particle-color', color);
                particle.style.pointerEvents = 'none';

                // Direção e distância aleatórias para a animação
                const angle = Math.random() * Math.PI * 2; 
                const distance = 30 + Math.random() * 50; 
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;

                particle.style.setProperty('--particle-dx', `${dx}px`);
                particle.style.setProperty('--particle-dy', `${dy}px`);

                particleContainer.appendChild(particle);

                // Remove a partícula após a animação
                particle.addEventListener('animationend', () => {
                    particle.remove();
                });
            }
            if (isExplosionSoundEnabled) { 
                enemyExplosionSound.currentTime = 0;
                enemyExplosionSound.play().catch(e => console.log("Erro ao tocar som de explosão:", e));
            }
        }

        /**
         * NOVO: Cria e anima pequenas partículas de acerto (hit) no local de um inimigo atingido.
         * @param {number} x - Posição X do objeto (inimigo/player).
         * @param {number} y - Posição Y do objeto (inimigo/player).
         * @param {string} color - Cor base das partículas (ex: '#FF0000').
         * @param {number} [baseSize=60] - Tamanho base do objeto para proporcionalidade (60px para inimigos normais, 100px para boss, 60px para player)
         */
        function createHitParticles(x, y, color, baseSize = 60) {
            const numberOfParticles = 7; 
            // Tamanho das partículas é proporcional ao tamanho do objeto atingido
            const particleSizeMultiplier = baseSize / 60; 
            const particleSize = (5 + Math.random() * 10) * particleSizeMultiplier; 

            for (let i = 0; i < numberOfParticles; i++) {
                const particle = document.createElement('div');
                particle.classList.add('hit-particle'); 
                
                // Posição inicial da partícula no centro do impacto, com uma pequena variação
                particle.style.left = `${x + (Math.random() * 10 - 5)}px`; 
                particle.style.top = `${y + (Math.random() * 10 - 5)}px`;
                particle.style.width = `${particleSize}px`;
                particle.style.height = `${particleSize}px`;
                particle.style.setProperty('--particle-color', color);
                particle.style.pointerEvents = 'none';

                // Direção e distância aleatórias para a animação (mais curtas)
                const angle = Math.random() * Math.PI * 2;
                const distance = (10 + Math.random() * 20) * particleSizeMultiplier; 
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;

                particle.style.setProperty('--particle-dx', `${dx}px`);
                particle.style.setProperty('--particle-dy', `${dy}px`);

                particleContainer.appendChild(particle);

                // Remove a partícula após a animação
                particle.addEventListener('animationend', () => {
                    particle.remove();
                });
            }
        }

        /**
         * Atualiza a posição dos objetos em caída e seus estados.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateFallingObjects(currentTime) {
            try {
                for (let i = 0; i < fallingObjects.length; i++) {
                    const object = fallingObjects[i];
                    let currentTop = parseFloat(object.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; object.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(object.style.left); 

                    let currentSpeedMultiplier = parseFloat(object.dataset.speedMultiplier || 1); 

                    if (object.dataset.isHeavy === 'true' || object.dataset.isHeavyTank === 'true') { 
                        let directionX = parseFloat(object.dataset.movementDirection);
                        currentLeft += directionX * (object.dataset.isHeavyTank === 'true' ? heavyTankEnemyDefinition.speed : heavyEnemyDefinition.speed) * currentSpeedMultiplier; 

                        if (currentLeft <= 0 || currentLeft + object.offsetWidth >= gameContainer.offsetWidth) {
                            directionX *= -1;
                            object.dataset.movementDirection = directionX;
                            currentLeft = Math.max(0, Math.min(currentLeft, gameContainer.offsetWidth - object.offsetWidth)); 
                        }
                        object.style.left = `${currentLeft}px`;

                        const initialTop = parseFloat(object.dataset.initialTop);
                        const verticalRange = gameContainer.offsetHeight * (object.dataset.isHeavyTank === 'true' ? heavyTankEnemyDefinition.verticalMovementRangePercentage : heavyEnemyDefinition.verticalMovementRangePercentage);
                        const minVerticalY = initialTop;
                        const maxVerticalY = initialTop + verticalRange;

                        let directionY = parseFloat(object.dataset.verticalMovementDirection);
                        currentTop += directionY * (object.dataset.isHeavyTank === 'true' ? heavyTankEnemyDefinition.verticalSpeed : heavyEnemyDefinition.verticalSpeed) * currentSpeedMultiplier;

                        if (currentTop > maxVerticalY) {
                            currentTop = maxVerticalY;
                            directionY = -1;
                        } else if (currentTop < minVerticalY) {
                            currentTop = minVerticalY;
                            directionY = 1;
                        }
                        object.style.top = `${currentTop}px`;
                        object.dataset.verticalMovementDirection = directionY; 

                        if (currentTime >= parseFloat(object.dataset.shootTimer)) {
                            createEnemyBullet(object, object.dataset.isHeavy === 'true'); 
                            object.dataset.shootTimer = currentTime + (object.dataset.isHeavyTank === 'true' ? heavyTankEnemyDefinition.shootInterval : heavyEnemyDefinition.shootInterval); 
                        }
                    } else { 
                        object.style.top = `${currentTop + currentEnemyMovementSpeed}px`;

                        if (object.dataset.hasShot === 'false' && currentTime >= parseFloat(object.dataset.shootTimer)) {
                            createEnemyBullet(object, false); 
                            object.dataset.hasShot = 'true';
                        }

                        if (currentTop > gameContainer.offsetHeight) {
                            object.remove();
                            fallingObjects.splice(i, 1);
                            i--;
                            continue;
                        }
                    }

                    const enemyHealthBarWrapper = object.querySelector('.enemy-health-bar-wrapper');
                    if (enemyHealthBarWrapper) {
                        if (object.dataset.isHeavy === 'true' || object.dataset.isHeavyTank === 'true') { 
                            enemyHealthBarWrapper.style.top = `${-20}px`; 
                        } else {
                            enemyHealthBarWrapper.style.top = `${-15}px`;
                        }
                    }
                }
            } catch (error) {
                console.error("Erro em updateFallingObjects:", error);
            }
        }

        /**
         * Atualiza a posição das balas do jogador e verifica colisões com objetos em caída.
         */
        function updateBullets() {
            try {
                for (let i = 0; i < bullets.length; i++) {
                    const bullet = bullets[i];
                    let currentBottom = parseFloat(bullet.style.bottom);
                    if (isNaN(currentBottom)) { currentBottom = 0; bullet.style.bottom = `${currentBottom}px`; }
                    let currentLeft = parseFloat(bullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; bullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(bullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(bullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentBottom += dy;
                    currentLeft += dx;

                    bullet.style.bottom = `${currentBottom}px`;
                    bullet.style.left = `${currentLeft}px`;

                    if (currentBottom > gameContainer.offsetHeight || currentBottom < -bullet.offsetHeight) {
                        bullet.remove();
                        bullets.splice(i, 1);
                        i--; 
                        continue; 
                    }

                    if (isBossFightActive && boss) {
                        const bulletRect = bullet.getBoundingClientRect();
                        const bossRect = boss.getBoundingClientRect();

                        if (
                            bulletRect.bottom > bossRect.top &&
                            bulletRect.top < bossRect.bottom &&
                            bulletRect.right > bossRect.left &&
                            bulletRect.left < bossRect.right
                        ) {
                            bullet.remove();
                            bullets.splice(i, 1);
                            i--;
                            
                            bossHealth = Math.max(0, bossHealth - bulletDamage);
                            updateBossActualHealthBar(); 
                            if (bossHealth <= 0) {
                                handleBossDefeated(); 
                                return; 
                            } else {
                                const bossX = parseFloat(boss.style.left) + boss.offsetWidth / 2;
                                const bossY = parseFloat(boss.style.top) + boss.offsetHeight / 2;
                                createHitParticles(bossX, bossY, '#ffffff', boss.offsetWidth); 
                            }
                            continue; 
                        }
                    }

                    const bulletRect = bullet.getBoundingClientRect();
                    for (let j = 0; j < fallingObjects.length; j++) {
                        const object = fallingObjects[j];
                        const objectRect = object.getBoundingClientRect();

                        if (
                            bulletRect.bottom > objectRect.top &&
                            bulletRect.top < objectRect.bottom &&
                            bulletRect.right > objectRect.left &&
                            bulletRect.left < objectRect.right
                        ) {
                            bullet.remove(); 
                            bullets.splice(i, 1);
                            i--; 
                            
                            let hitsRemaining = parseInt(object.dataset.hitsRemaining);
                            hitsRemaining -= bulletDamage; 
                            object.dataset.hitsRemaining = hitsRemaining;

                            const enemyHealthFill = object.querySelector('.enemy-health-fill');
                            if (enemyHealthFill) {
                                const healthPercentage = (hitsRemaining / parseInt(object.dataset.initialHits)) * 100;
                                enemyHealthFill.style.width = `${healthPercentage}%`;
                                if (healthPercentage > 60) {
                                    enemyHealthFill.style.backgroundColor = '#48bb78'; 
                                } else if (healthPercentage > 30) {
                                    enemyHealthFill.style.backgroundColor = '#f6ad55'; 
                                } else {
                                    enemyHealthFill.style.backgroundColor = '#e53e3e'; 
                                }
                            }

                            const enemyX = parseFloat(object.style.left) + object.offsetWidth / 2;
                            const enemyY = parseFloat(object.style.top) + object.offsetHeight / 2;
                            let particleColor = '#f6e05e'; 
                            if (object.dataset.isHeavy === 'true') {
                                particleColor = '#FF4500'; 
                            } else if (object.dataset.isHeavyTank === 'true') { 
                                particleColor = '#00FFFF'; 
                            }
                            else {
                                const hueRotateMatch = object.style.filter.match(/hue-rotate\((\d+)deg\)/);
                                if (hueRotateMatch && hueRotateMatch[1]) {
                                    const hue = parseInt(hueRotateMatch[1]);
                                    if (hue >= 0 && hue < 60) particleColor = '#f6e05e'; 
                                    else if (hue >= 60 && hue < 120) particleColor = '#7ed321'; 
                                    else if (hue >= 120 && hue < 180) particleColor = '#00BFFF'; 
                                    else if (hue >= 180 && hue < 240) particleColor = '#bd10e0'; 
                                    else if (hue >= 240 && hue < 300) particleColor = '#FF69B4'; 
                                    else particleColor = '#f6e05e'; 
                                }
                            }

                            if (hitsRemaining > 0) {
                                object.classList.add('enemy-hit-effect');
                                setTimeout(() => {
                                    object.classList.remove('enemy-hit-effect');
                                }, 100); 
                                createHitParticles(enemyX, enemyY, particleColor, object.offsetWidth);
                            } else {
                                createParticles(enemyX, enemyY, particleColor);

                                object.remove();
                                fallingObjects.splice(j, 1);
                                j--; 
                                
                                if (object.dataset.isHeavy === 'true') {
                                    isHeavyEnemyOnScreen = false; 
                                    console.log("Heavy enemy defeated. isHeavyEnemyOnScreen = false");
                                    score += 10; 
                                    const gameRect = gameContainer.getBoundingClientRect();
                                    const powerUpDropChance = object.dataset.isSuper === 'true' ? 1.0 : 0.40; 
                                    if (Math.random() < powerUpDropChance) {
                                        const positivePowerUps = powerUpTypes.filter(type => type.type !== 'damage_down');
                                        const forcedPowerUp = positivePowerUps[Math.floor(Math.random() * positivePowerUps.length)];
                                        createCollectible(objectRect.left - gameRect.left, objectRect.top - gameRect.top, performance.now(), forcedPowerUp.type);
                                    }
                                } else if (object.dataset.isHeavyTank === 'true') { 
                                    isHeavyEnemyOnScreen = false; 
                                    console.log("Heavy Tank defeated. isHeavyEnemyOnScreen = false");
                                    score += 15; 
                                    const gameRect = gameContainer.getBoundingClientRect();
                                    const powerUpDropChance = object.dataset.isSuper === 'true' ? 1.0 : 0.40; 
                                    if (Math.random() < powerUpDropChance) {
                                        const positivePowerUps = powerUpTypes.filter(type => type.type !== 'damage_down');
                                        const forcedPowerUp = positivePowerUps[Math.floor(Math.random() * positivePowerUps.length)];
                                        createCollectible(objectRect.left - gameRect.left, objectRect.top - gameRect.top, performance.now(), forcedPowerUp.type);
                                    }
                                }
                                else {
                                    const scoreMultiplier = 1 + (bossLevel * 0.20);
                                    score += Math.floor(1 * scoreMultiplier); 
                                    if (Math.random() < collectibleDropChance) { 
                                        const gameRect = gameContainer.getBoundingClientRect(); 
                                        createCollectible(objectRect.left - gameRect.left, objectRect.top - gameRect.top, performance.now()); 
                                    }
                                }
                                increaseDifficulty(); 
                            }
                            if (bullet.parentNode === null) break; 
                        }
                    }
                }
            } catch (error) {
                console.error("Erro em updateBullets:", error);
            }
        }

        /**
         * Atualiza a posição dos coletáveis e verifica colisões com o jogador.
         */
        function updateCollectibles(currentTime) {
            try {
                for (let i = 0; i < collectibles.length; i++) {
                    const collectible = collectibles[i];
                    let currentTop = parseFloat(collectible.style.top);
                    if (isNaN(currentTop)) {
                        currentTop = 0; 
                        collectible.style.top = `${currentTop}px`;
                    }

                    if (collectible.dataset.isStationary === 'true') {
                        if (currentTime - parseFloat(collectible.dataset.spawnTime) > collectibleStationaryDuration) {
                            collectible.dataset.isStationary = 'false'; 
                        }
                    } else {
                        collectible.style.top = `${currentTop + currentEnemyMovementSpeed}px`;
                    }

                    if (currentTop > gameContainer.offsetHeight) {
                        collectible.remove();
                        collectibles.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const collectibleRect = collectible.getBoundingClientRect();

                    if (
                        collectibleRect.bottom > playerRect.top &&
                        collectibleRect.top < playerRect.bottom &&
                        collectibleRect.right > playerRect.left &&
                        collectibleRect.left < playerRect.right
                    ) {
                        if (collectible.classList.contains('power-up')) {
                            collectPowerUp(collectible);
                        } else if (collectible.classList.contains('debuff')) {
                            collectDebuff(collectible);
                        }
                        collectible.remove();
                        collectibles.splice(i, 1);
                        i--;
                        return; 
                    }
                }
            } catch (error) {
                console.error("Erro em updateCollectibles:", error);
            }
        }

        /**
         * Atualiza a posição dos projéteis inimigos e verifica colisões com o jogador.
         */
        function updateEnemyBullets() {
            try {
                for (let i = 0; i < enemyBullets.length; i++) {
                    const eBullet = enemyBullets[i];
                    let currentTop = parseFloat(eBullet.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; eBullet.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(eBullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; eBullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(eBullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(eBullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentTop += dy;
                    currentLeft += dx;

                    eBullet.style.top = `${currentTop}px`;
                    eBullet.style.left = `${currentLeft}px`;

                    if (currentTop > gameContainer.offsetHeight || currentLeft < -eBullet.offsetWidth || currentLeft > gameContainer.offsetWidth) {
                        eBullet.remove();
                        enemyBullets.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const eBulletRect = eBullet.getBoundingClientRect();

                    if (
                        eBulletRect.bottom > playerRect.top &&
                        eBulletRect.top < playerRect.bottom &&
                        eBulletRect.right > playerRect.left &&
                        eBulletRect.left < playerRect.right
                    ) {
                        eBullet.remove();
                        enemyBullets.splice(i, 1);
                        i--;

                        let damageToApply;
                        if (eBullet.dataset.isHeavyBullet === 'true') {
                            damageToApply = parseFloat(eBullet.dataset.baseBulletDamage);
                        } else {
                            damageToApply = baseEnemyBulletDamage;
                        }
                        // Aplica o escalonamento de nível do boss ao dano
                        damageToApply *= (1 + bossLevel * 0.10);

                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateEnemyBullets. Defaulting to 0.");
                            damageToApply = 0;
                        }
                        console.log("Final Damage to Apply:", damageToApply); 
                        
                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); 
                            }
                        } else { 
                            health = Math.max(0, health - damageToApply);
                        }
                        
                        updateHealthBarDisplay();
                        updateShieldBarDisplay(); 
                        console.log("Atingido por inimigo! Vida restante: " + health + "Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect'); 
                        }, 150); 
                        // Player atingido: criar partículas de acerto vermelhas
                        createHitParticles(playerX + player.offsetWidth / 2, playerY + player.offsetHeight / 2, '#FF0000', player.offsetWidth);
                    }
                }
            } catch (error) {
                console.error("Erro em updateEnemyBullets:", error);
            }
        }

        /**
         * Atualiza a posição dos obstáculos e verifica colisões com o jogador.
         */
        function updateObstacles() {
            try {
                for (let i = 0; i < obstacles.length; i++) {
                    const obstacle = obstacles[i];
                    let currentTop = parseFloat(obstacle.style.top);
                    if (isNaN(currentTop)) {
                        currentTop = -45; 
                        obstacle.style.top = `${currentTop}px`; 
                    }
                    obstacle.style.top = `${currentTop + currentEnemyMovementSpeed}px`; 

                    if (currentTop > gameContainer.offsetHeight) {
                        obstacle.remove();
                        obstacles.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const obstacleRect = obstacle.getBoundingClientRect();

                    if (
                        obstacleRect.bottom > playerRect.top &&
                        obstacleRect.top < playerRect.bottom &&
                        obstacleRect.right > playerRect.left &&
                        obstacleRect.left < playerRect.right
                    ) {
                        obstacle.remove();
                        obstacles.splice(i, 1);
                        i--;

                        let damageToApply = obstacleDamage; 
                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateObstacles. Defaulting to 0.");
                            damageToApply = 0;
                        }

                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); 
                            }
                        } else { 
                            health = Math.max(0, health - damageToApply);
                        }
                        
                        updateHealthBarDisplay();
                        updateShieldBarDisplay(); 
                        console.log("Atingido por obstáculo! Vida restante: " + health + ", Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect'); 
                        }, 150); 
                        // Player atingido: criar partículas de acerto vermelhas
                        createHitParticles(playerX + player.offsetWidth / 2, playerY + player.offsetHeight / 2, '#FF0000', player.offsetWidth);
                    }
                }
            } catch (error) {
                console.error("Erro em updateObstacles:", error);
            }
        }

        /**
         * Aumenta a dificuldade do jogo.
         */
        function increaseDifficulty() {
            if (score >= nextBossScoreThreshold && !isBossFightActive) {
                startBossFight(); 
            }
        }

        /**
         * Função para coletar um power-up.
         * @param {HTMLElement} powerUp - O elemento DOM do power-up coletado.
         */
        function collectPowerUp(powerUp) {
            const type = powerUp.dataset.type;
            console.log(`Power-up coletado: ${type}`); 

            if (type === 'damage_1') {
                damage1Bonus += 1; 
                console.log("Power-up de dano +1! Dano atual: " + (bulletConfigurations[currentBulletStage].baseDamage + (playerLevel - 1) + damage1Bonus));
            } else if (type === 'side_bullets') {
                const currentConfig = bulletConfigurations[currentBulletStage];
                // Verifica se pode aumentar os tiros laterais no estágio atual
                if (currentSideShotsLevel < 2) { 
                    currentSideShotsLevel++; 
                    console.log(`Tiros laterais aumentados para o nível ${currentSideShotsLevel + 1} no estágio ${currentBulletStage}.`);
                } else {
                    // Se já está no nível máximo de tiros laterais, tenta avançar de estágio
                    if (currentBulletStage < bulletConfigurations.length - 1) { 
                        currentBulletStage++; 
                        currentSideShotsLevel = 0; 
                        console.log(`Avançado para o estágio de bala ${currentBulletStage}. Tiros laterais resetados.`);
                    } else {
                        // Nível máximo de tiros e estágio de bala alcançados
                        console.log("Nível máximo de tiros e estágio de bala alcançados.");
                    }
                }
            } else if (type === 'health_up') {
                // Ao coletar vida, se o escudo estiver ativo, a vida aumenta por baixo do escudo
                if (shieldActive) {
                    health = Math.min(maxOvershieldHealth, health + healthPowerUpType.healthIncrease);
                    console.log("Power-up de vida coletado! Vida atual (por baixo do escudo): " + health);
                } else {
                    health = Math.min(maxOvershieldHealth, health + healthPowerUpType.healthIncrease);
                    console.log("Power-up de vida coletado! Vida atual: " + health);
                }
            } else if (type === 'shield') { 
                // Ao coletar escudo, ativa o escudo e preenche a vida do escudo
                shieldHealth = maxShieldHealth;
                shieldActive = true;
                player.classList.add('player-shield-active');
                console.log("Power-up de escudo coletado! Vida do escudo: " + shieldHealth);
            }
            updatePlayerStatsBasedOnLevel(); 
            updatePlayerDamageDisplay();
            updateHealthBarDisplay(); 
            updateShieldBarDisplay(); 
            // playerPowerDisplay.textContent = bulletConfigurations[currentBulletStage].powerText; // Removido: Poder não é mais exibido
        }

        /**
         * Função para coletar um debuff.
         * @param {HTMLElement} debuff - O elemento DOM do debuff coletado.
         */
        function collectDebuff(debuff) {
            const type = debuff.dataset.type;
            console.log(`Debuff coletado: ${type}`); 

            if (type === 'damage_down') {
                console.log("DEBUFF - Antes: Stage:", currentBulletStage, "Side Shots:", currentSideShotsLevel, "Damage Bonus:", damage1Bonus, "Player Level:", playerLevel, "Bullet Damage (before debuff logic):", bulletDamage);

                // Prioridade 1: Reduzir o dano base (damage1Bonus)
                if (damage1Bonus > 0) {
                    damage1Bonus = Math.max(0, damage1Bonus - 1);
                    console.log(`Debuff: damage1Bonus reduzido para ${damage1Bonus}`);
                } 
                // Prioridade 2: Reduzir o número de tiros laterais
                else if (currentSideShotsLevel > 0) {
                    currentSideShotsLevel = Math.max(0, currentSideShotsLevel - 1);
                    console.log(`Debuff: Tiros laterais reduzidos para o nível ${currentSideShotsLevel + 1}.`);
                } 
                // Prioridade 3: Retroceder o estágio de bala
                else if (currentBulletStage > 0) {
                    currentBulletStage--; 
                    currentSideShotsLevel = 0; // Reseta tiros laterais ao retroceder estágio
                    console.log(`Debuff: Retornou ao estágio de bala ${currentBulletStage}. Tiros laterais resetados.`);
                } else {
                    console.log("Debuff: Não há mais nada para reduzir.");
                }
                
                updatePlayerStatsBasedOnLevel(); // Recalcula bulletDamage com base nas novas configurações
                console.log("DEBUFF - Depois: Stage:", currentBulletStage, "Side Shots:", currentSideShotsLevel, "Damage Bonus:", damage1Bonus, "Final Bullet Damage:", bulletDamage);
            }
            updatePlayerDamageDisplay();
            // playerPowerDisplay.textContent = bulletConfigurations[currentBulletStage].powerText; // Removido: Poder não é mais exibido

            // Adicionar um efeito visual temporário ao jogador para indicar o debuff
            player.classList.add('player-debuff-effect');
            setTimeout(() => {
                player.classList.remove('player-debuff-effect');
            }, 300); 
        }

        /**
         * Desativa o escudo do jogador.
         */
        function deactivateShield() {
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 
            
            // A variável 'health' já contém o valor correto após o dano ter sido aplicado a ela.
            health = Math.max(0, health); 
            
            console.log("Escudo desativado! Vida do jogador: " + health);
            updateHealthBarDisplay(); // Chamar para atualizar a cor da barra
            updateShieldBarDisplay(); // NOVO: Atualiza a barra de escudo
        }

        /**
         * Atualiza a exibição de dano do jogador (na barra de status).
         */
        function updatePlayerDamageDisplay() {
            if (playerDamageDisplay) {
                let damageText = `${bulletDamage}`; 
                // Ajusta a exibição para o número correto de tiros
                let numShots = 1;
                if (currentSideShotsLevel === 1) numShots = 2;
                else if (currentSideShotsLevel === 2) numShots = 3;

                if (numShots > 1) damageText += `x${numShots}`; 
                
                // Removido: Adiciona o indicador de cor/tipo de bala
                // if (currentBulletStage === 0) damageText += ` (Amarelo)`;
                // else if (currentBulletStage === 1) damageText += ` (Azul)`;
                // else if (currentBulletStage === 2) damageText += ` (Vermelho)`;
                
                // Removido: Não exibir o bônus de dano (+B)
                // if (damage1Bonus > 0) damageText += ` (+${damage1Bonus}B)`; 

                playerDamageDisplay.textContent = damageText;
            }
        }

        /**
         * Atualiza a barra de vida do jogador (agora com suporte a escudo e sobrevida).
         */
        function updateHealthBarDisplay() {
            if (healthBarFill && overshieldBarFill) { 
                // Lógica para a barra de vida principal (incluindo sobrevida)
                if (health > maxHealth) {
                    const baseHealthPercentage = 100; 
                    const overshieldAmount = health - maxHealth;
                    // Calcula a porcentagem da sobrevida em relação ao total de sobrevida possível
                    const overshieldMaxPossible = maxOvershieldHealth - maxHealth; 
                    const overshieldPercentage = (overshieldAmount / overshieldMaxPossible) * 100;

                    healthBarFill.style.width = `${baseHealthPercentage}%`; 
                    overshieldBarFill.style.width = `${overshieldPercentage}%`; 
                    playerHealthText.textContent = `${Math.round(health)} / ${maxOvershieldHealth}`; 
                    healthBarFill.style.backgroundColor = '#48bb78'; /* Verde para vida normal/sobrevida */
                } else {
                    // Lógica para vida normal (sem sobrevida)
                    overshieldBarFill.style.width = '0%'; 
                    const healthPercentage = (health / maxHealth) * 100;
                    healthBarFill.style.width = `${healthPercentage}%`; 
                    
                    // Lógica de cor da barra de vida: verde/laranja/vermelho
                    if (healthPercentage > 60) {
                        healthBarFill.style.backgroundColor = '#48bb78'; /* Verde */
                    } else if (healthPercentage > 30) {
                        healthBarFill.style.backgroundColor = '#f6ad55'; /* Laranja */
                    } else {
                        healthBarFill.style.backgroundColor = '#e53e3e'; /* Vermelho */
                    }
                    playerHealthText.textContent = `${Math.round(health)} / ${maxHealth}`; /* CORREÇÃO: Removido "Vida: " duplicado */
                }
            }
        }

        /**
         * NOVO: Atualiza a barra de escudo.
         */
        function updateShieldBarDisplay() {
            if (shieldBarWrapper && shieldBarFill && shieldHealthText) {
                if (shieldActive && shieldHealth > 0) {
                    shieldBarWrapper.classList.remove('hidden');
                    const shieldPercentage = (shieldHealth / maxShieldHealth) * 100;
                    shieldBarFill.style.width = `${shieldPercentage}%`;
                    shieldBarFill.style.backgroundColor = '#00BFFF'; /* Azul para escudo */
                    shieldHealthText.textContent = `${Math.round(shieldHealth)} / ${maxShieldHealth}`;
                } else {
                    shieldBarWrapper.classList.add('hidden');
                    shieldBarFill.style.width = '0%';
                    shieldHealthText.textContent = '0/100';
                }
            }
        }

        /**
         * Atualiza a barra de progresso do Estágio.
         */
        function updateStageProgressBar() {
            const progress = Math.min(score, nextBossScoreThreshold);
            const progressPercentage = (progress / nextBossScoreThreshold) * 100;
            stageProgressBarFill.style.width = `${progressPercentage}%`;
            stageProgressValue.textContent = `${score} / ${nextBossScoreThreshold}`; 
        }

        /**
         * Inicia a batalha contra o boss.
         */
        function startBossFight() {
            console.log('startBossFight: Setting isBossFightActive = true'); 
            isBossFightActive = true;
            clearGameElements(); 
            
            // A vida do boss agora é baseada no initialBossHealth (400)
            bossHealth = initialBossHealth * Math.pow(2, bossLevel); 
            currentBossBulletDamage = initialBossBulletDamage * (1 + bossLevel * 0.10); 
            bossRageThreshold = bossHealth * 0.35; 
            bossRageActive = false; 
            lastBossPowerUpDropTime = 0; 

            console.log(`Boss Level: ${bossLevel}, Boss Health: ${bossHealth}, Boss Bullet Damage: ${currentBossBulletDamage}, Rage Threshold: ${bossRageThreshold}`); 

            createBoss();
            lastBossShotTime = performance.now(); 
            bossHealthBarHorizontalWrapper.classList.remove('hidden'); // Ajustado para esconder a barra de vida do boss no inicio do estágio
            updateBossActualHealthBar(); // Atualiza a barra de vida do boss ao iniciar a luta

            // NOVO: Fala do chefe ao aparecer
            generateBossTaunt(`Gere uma fala curta e ameaçadora de um chefe espacial que acabou de aparecer para lutar. Use o nome 'Espectro'.`);

            // Controla a música: pausa a de fundo e toca a do boss com fade
            if (isAmbientMusicEnabled) {
                fadeOut(backgroundMusic, () => {
                    fadeIn(bossMusic, 0.6); 
                });
            } else {
                backgroundMusic.pause();
                bossMusic.pause();
            }
        }

        /**
         * Cria o elemento do boss.
         */
        function createBoss() {
            boss = document.createElement('div');
            boss.classList.add('boss');
            
            // NOVO: Seleciona um sprite aleatório para o boss
            const randomSprite = enemySprites[Math.floor(Math.random() * enemySprites.length)];
            boss.style.backgroundImage = `url('${randomSprite}')`;
            
            boss.style.left = `${(gameContainer.offsetWidth / 2) - (110 / 2)}px`; // Ajustado para novo tamanho
            boss.style.top = '50px'; 
            bossMovementDirection = Math.random() < 0.5 ? 1 : -1; 
            bossVerticalDirection = 1; 
            // Removido bossHueRotations, a animação superHueRotate cuidará da cor
            boss.style.filter = `hue-rotate(0deg)`; // Inicia com filtro padrão
            boss.style.pointerEvents = 'none';
            
            // NOVO: Adiciona a classe de brilho com animação mais lenta
            boss.classList.add('super-enemy-glow');
            boss.style.animationDuration = '2s'; // Animação de cor mais lenta para o boss

            gameContainer.appendChild(boss);

            // A barra de vida do boss agora está no topo direito da tela, não mais filha do boss
            // A lógica de updateBossHealthBar já cuida do posicionamento
        }

        /**
         * Atualiza a barra de vida do boss (a barra real, não a de progresso).
         */
        function updateBossActualHealthBar() {
            if (bossHealthBarHorizontalFill && bossHealthBarHorizontalText) { 
                const maxBossHealthForLevel = initialBossHealth * Math.pow(2, bossLevel);
                const healthPercentage = (bossHealth / maxBossHealthForLevel) * 100;
                bossHealthBarHorizontalFill.style.width = `${healthPercentage}%`; /* Largura para horizontal */
                bossHealthBarHorizontalText.textContent = `${Math.round(bossHealth)} / ${Math.round(maxBossHealthForLevel)}`; // NOVO: Texto numérico

                if (healthPercentage > 60) {
                    bossHealthBarHorizontalFill.style.backgroundColor = '#48bb78'; /* Verde */
                } else if (healthPercentage > 30) {
                    bossHealthBarHorizontalFill.style.backgroundColor = '#f6ad55'; /* Laranja */
                } else {
                    bossHealthBarHorizontalFill.style.backgroundColor = '#e53e3e'; /* Vermelho */
                }
            }
        }


        /**
         * Atualiza a lógica do boss (movimento e tiro).
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateBoss(currentTime) {
            try {
                if (!boss) {
                    console.log("updateBoss: Boss object is null, cannot update."); 
                    return;
                }
                console.log("updateBoss: Executing Boss movement and shoot logic. Boss.style.left:", boss.style.left, "Boss.style.top:", boss.style.top, "Boss Health:", bossHealth);
                console.log("updateBoss: bossMovementDirection:", bossMovementDirection, "bossMovementSpeed:", bossMovementSpeed); 

                let bossX = parseFloat(boss.style.left);
                if (isNaN(bossX)) { 
                    bossX = (gameContainer.offsetWidth / 2) - (100 / 2);
                    boss.style.left = `${bossX}px`; 
                    console.log("updateBoss: bossX was NaN, reset to:", bossX); 
                }
                let bossY = parseFloat(boss.style.top);
                if (isNaN(bossY)) {
                    bossY = 50;
                    boss.style.top = `${bossY}px`;
                }


                let currentBossSpeed = bossMovementSpeed;
                if (bossHealth <= bossRageThreshold && !bossRageActive) {
                    bossRageActive = true;
                    boss.style.filter = `hue-rotate(0deg) saturate(200%) brightness(1.2)`; 
                    currentBossBulletDamage *= 1.05; 
                    bossShootInterval *= 0.7; // NOVO: Reduz o intervalo de tiro em 30%
                    console.log("BOSS ENTROU EM MODO DE RAIVA! Dano aumentado, frequência de tiro aumentada.");
                    // NOVO: Fala do chefe ao entrar em raiva
                    generateBossTaunt(`Gere uma fala curta e furiosa de um chefe espacial chamado 'Espectro' que está com pouca vida e entrou em modo de raiva.`);
                }

                if (bossRageActive) {
                    currentBossSpeed = bossRageMovementSpeed; 

                    // Movimento vertical (20% da altura da tela)
                    const verticalRange = gameContainer.offsetHeight * 0.2;
                    const initialBossTop = 50; 
                    const targetMinY = initialBossTop;
                    const targetMaxY = initialBossTop + verticalRange;

                    bossY += bossVerticalDirection * 1.5; 

                    if (bossY > targetMaxY) {
                        bossY = targetMaxY;
                        bossVerticalDirection = -1;
                    } else if (bossY < targetMinY) {
                        bossY = targetMinY;
                        bossVerticalDirection = 1;
                    }
                    boss.style.top = `${bossY}px`;
                }


                let newBossX = bossX + bossMovementDirection * currentBossSpeed; 
                console.log("updateBoss: old bossX:", bossX, "newBossX calculated:", newBossX); 

                if (newBossX + boss.offsetWidth + bossPadding > gameContainer.offsetWidth) {
                    newBossX = gameContainer.offsetWidth - boss.offsetWidth - bossPadding;
                    bossMovementDirection *= -1; 
                    console.log("updateBoss: Hit right boundary, newBossX:", newBossX, "new bossMovementDirection:", bossMovementDirection); 
                } else if (newBossX < bossPadding) {
                    newBossX = bossPadding;
                    bossMovementDirection *= -1; 
                    console.log("updateBoss: Hit left boundary, newBossX:", newBossX, "new bossMovementDirection:", bossMovementDirection); 
                }
                boss.style.left = `${newBossX}px`; 
                console.log("updateBoss: boss.style.left updated to:", boss.style.left); 
                console.log("updateBoss: boss.getBoundingClientRect().left:", boss.getBoundingClientRect().left); 

                if (currentTime - lastBossShotTime > bossShootInterval) {
                    if (bossRageActive && Math.random() < 0.30) { 
                        createShotgunBossBullets();
                    } else {
                        const attackTypes = [createSingleBossBullet, createFanBossBullets, createRicochetBossBullet];
                        const selectedAttack = attackTypes[Math.floor(Math.random() * attackTypes.length)];
                        selectedAttack();
                    }
                    lastBossShotTime = currentTime;

                    if (bossLevel >= 0 && !isHeavyEnemyOnScreen && Math.random() < 0.20) { 
                        console.log("Boss attempting to summon heavy enemy...");
                        createFallingObject(currentTime, true, {health: bossHealth, damage: currentBossBulletDamage});
                    }
                }
            } catch (error) {
                console.error("Erro em updateBoss:", error);
            }
        }

        /**
         * Cria uma única bala do boss.
         */
        function createSingleBossBullet() {
            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            bossBullet.style.left = `${bossLeft + (boss.offsetWidth / 2) - (15 / 2)}px`;
            bossBullet.style.top = `${bossTop + boss.offsetHeight}px`;
            bossBullet.dataset.dx = 0; 
            bossBullet.dataset.dy = currentEnemyBulletSpeed; 
            bossBullet.style.pointerEvents = 'none';
            gameContainer.appendChild(bossBullet);
            bossBullets.push(bossBullet);
        }

        /**
         * Cria balas do boss em leque.
         */
        function createFanBossBullets() {
            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            const startX = bossLeft + boss.offsetWidth / 2;
            const startY = bossTop + boss.offsetHeight;
            const spreadAngle = Math.PI / 6; 
            const numBullets = 3;
            const baseSpeed = currentEnemyBulletSpeed * 0.5; 

            for (let i = 0; i < numBullets; i++) {
                const angleOffset = (i - (numBullets - 1) / 2) * spreadAngle / (numBullets - 1);
                const angle = Math.PI / 2 + angleOffset; 

                const dx = Math.cos(angle) * baseSpeed;
                const dy = Math.sin(angle) * baseSpeed;

                const bossBullet = document.createElement('div');
                bossBullet.classList.add('boss-bullet');
                bossBullet.style.left = `${startX - (15 / 2)}px`;
                bossBullet.style.top = `${startY}px`;
                bossBullet.dataset.dx = dx;
                bossBullet.dataset.dy = dy;
                bossBullet.style.pointerEvents = 'none';
                gameContainer.appendChild(bossBullet);
                bossBullets.push(bossBullet);
            }
        }

        /**
         * Cria uma bala ricochete do boss.
         */
        function createRicochetBossBullet() {
            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            bossBullet.style.left = `${bossLeft + (boss.offsetWidth / 2) - (15 / 2)}px`;
            bossBullet.style.top = `${bossTop + boss.offsetHeight}px`;
            bossBullet.style.pointerEvents = 'none';
            
            bossBullet.dataset.dx = (Math.random() > 0.5 ? 1 : -1) * (currentEnemyBulletSpeed * 0.75); 
            bossBullet.dataset.dy = currentEnemyBulletSpeed * 0.5; 
            gameContainer.appendChild(bossBullet);
            bossBullets.push(bossBullet);
        }

        /**
         * Cria 10 balas do boss em todas as direções (ataque "shotgun").
         */
        function createShotgunBossBullets() {
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            const startX = bossLeft + boss.offsetWidth / 2;
            const startY = bossTop + boss.offsetHeight / 2; 
            const numBullets = 10;
            const angleIncrement = (Math.PI * 2) / numBullets; 
            const baseSpeed = currentEnemyBulletSpeed * 0.8; 

            for (let i = 0; i < numBullets; i++) {
                const angle = i * angleIncrement;

                const dx = Math.cos(angle) * baseSpeed;
                const dy = Math.sin(angle) * baseSpeed;

                const bossBullet = document.createElement('div');
                bossBullet.classList.add('boss-bullet');
                bossBullet.style.left = `${startX - (15 / 2)}px`;
                bossBullet.style.top = `${startY - (15 / 2)}px`; 
                bossBullet.dataset.dx = dx;
                bossBullet.dataset.dy = dy;
                bossBullet.dataset.isShotgun = 'true'; 
                bossBullet.style.pointerEvents = 'none';
                gameContainer.appendChild(bossBullet);
                bossBullets.push(bossBullet);
            }
        }

        /**
         * Atualiza a posição dos projéteis do boss e verifica colisões com o jogador.
         */
        function updateBossBullets() {
            try {
                for (let i = 0; i < bossBullets.length; i++) {
                    const bBullet = bossBullets[i];
                    let currentTop = parseFloat(bBullet.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; bBullet.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(bBullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; bBullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(bBullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(bBullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentTop += dy;
                    currentLeft += dx;

                    // Lógica de ricochete APENAS para balas que NÃO SÃO de shotgun
                    if (bBullet.dataset.isShotgun !== 'true' && bBullet.dataset.dx !== '0') { 
                        if (currentLeft <= 0) {
                            currentLeft = 0; 
                            dx *= -1; 
                            bBullet.dataset.dx = dx; 
                        } else if (currentLeft + bBullet.offsetWidth >= gameContainer.offsetWidth) {
                            currentLeft = gameContainer.offsetWidth - bBullet.offsetWidth; 
                            dx *= -1; 
                            bBullet.dataset.dx = dx; 
                        }
                    }

                    bBullet.style.top = `${currentTop}px`;
                    bBullet.style.left = `${currentLeft}px`;

                    // Remove a bala se sair da tela (incluindo as de shotgun que não ricocheteiam)
                    if (currentTop > gameContainer.offsetHeight || currentLeft < -bBullet.offsetWidth || currentLeft > gameContainer.offsetWidth) {
                        bBullet.remove();
                        bossBullets.splice(i, 1);
                        i--;
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const bBulletRect = bBullet.getBoundingClientRect();

                    if (
                        bBulletRect.bottom > playerRect.top &&
                        bBulletRect.top < playerRect.bottom &&
                        bBulletRect.right > playerRect.left &&
                        bBulletRect.left < playerRect.right
                    ) {
                        bBullet.remove();
                        bossBullets.splice(i, 1);
                        i--;

                        let damageToApply = currentBossBulletDamage; 
                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateBossBullets. Defaulting to 0.");
                            damageToApply = 0;
                        }
                        
                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); 
                            }
                        } else { 
                            health = Math.max(0, health - damageToApply);
                        }
                        
                        updateHealthBarDisplay();
                        updateShieldBarDisplay(); 
                        console.log("Atingido por inimigo! Vida restante: " + health + "Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect');
                        }, 150); 
                        // Player atingido: criar partículas de acerto vermelhas
                        createHitParticles(playerX + player.offsetWidth / 2, playerY + player.offsetHeight / 2, '#FF0000', player.offsetWidth);
                    }
                }
            } catch (error) {
                console.error("Erro em updateBossBullets:", error);
            }
        }

        /**
         * Lida com a derrota do boss, exibindo a tela de "Stage Clear".
         */
        function handleBossDefeated() {
            console.log('handleBossDefeated started.'); 
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            clearGameElements(); 
            console.log('handleBossDefeated: gameRunning = false, isBossFightActive =', isBossFightActive); 

            score += 50; 
            // scoreValueDisplay.textContent = score; // Removido, score não é exibido diretamente
            stageScoreDisplay.textContent = score; 

            bossLevel++; 
            playerLevel++; 
            updatePlayerStatsBasedOnLevel(); 
            
            nextBossScoreThreshold = score + Math.ceil(score * 0.5); 
            console.log("Próximo Boss em: " + nextBossScoreThreshold + " pontos.");

            stageClearScreen.classList.remove('hidden'); 
            bossHealthBarHorizontalWrapper.classList.add('hidden'); // Esconde a barra de vida do boss
            console.log('handleBossDefeated: Stage Clear screen shown.'); 
            
            // NOVO: Fala do chefe ao ser derrotado
            generateBossTaunt(`Gere uma fala curta e de derrota de um chefe espacial chamado 'Espectro' que acabou de ser derrotado.`);

            // Controla a música: pausa a do boss e retoma a de fundo com fade
            if (isAmbientMusicEnabled) {
                fadeOut(bossMusic, () => {
                    fadeIn(backgroundMusic, 0.5); 
                });
            } else {
                backgroundMusic.pause();
                bossMusic.pause();
            }
        }

        /**
         * Atualiza a posição dos segmentos de fundo para criar rolagem infinita com rotação.
         */
        function updateBackgroundSegments() {
            try {
                const gameContainerHeight = gameContainer.offsetHeight;
                const scrollSpeed = backgroundScrollSpeed; 

                backgroundSegments.forEach(segment => {
                    let currentTop = parseFloat(segment.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; segment.style.top = `${currentTop}px`; }
                    currentTop += scrollSpeed;
                    segment.style.top = `${currentTop}px`;

                    // Correção do cenário infinito: Ajusta a posição para evitar lacunas
                    if (currentTop >= gameContainer.offsetHeight) {
                        segment.style.top = `${currentTop - (gameContainerHeight * 2)}px`; 
                        segment.classList.toggle('rotated-180'); 
                    }
                });
            } catch (error) {
                console.error("Erro em updateBackgroundSegments:", error);
            }
        }

        /**
         * Atualiza o estado do escudo.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateShield(currentTime) {
            // A lógica de desativação está nos métodos de dano.
        }
        
        /**
         * Loop principal do jogo.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function gameLoop(currentTime) {
            try {
                if (!gameRunning || gamePaused) return;

                console.log('gameLoop: Running. CurrentTime:', currentTime); 
                updateBackgroundSegments(); 
                updateShield(currentTime); 

                updateFallingObjects(currentTime); 
                updateEnemyBullets(); 
                updateObstacles(); 

                if (!isBossFightActive) {
                    if (currentTime - lastObjectSpawnTime > objectSpawnInterval) {
                        createFallingObject(currentTime); 
                        lastObjectSpawnTime = currentTime;
                    }

                    if (currentTime - lastObstacleSpawnTime > currentObstacleSpawnInterval) { 
                        createObstacle();
                        lastObstacleSpawnTime = currentTime;
                    }
                } else { 
                    console.log('gameLoop: Executing BOSS logic'); 
                    updateBoss(currentTime);
                    updateBossBullets();
                    if (currentTime - lastBossPowerUpDropTime > bossFightPowerUpInterval) {
                        const dropType = Math.random() < 0.7 ? 'health_up' : 'shield'; 
                        const spawnX = Math.random() * (gameContainer.offsetWidth - 30); 
                        createCollectible(spawnX, 0, currentTime, dropType); 
                        lastBossPowerUpDropTime = currentTime;
                    }
                }

                updateCollectibles(currentTime);
                updateStageProgressBar(); 

                if (currentTime - lastShotTime > shootInterval) {
                    createBullet();
                    lastShotTime = currentTime;
                }

                updateBullets(); 
                updatePlayerPosition();
                animationFrameId = requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("Erro crítico no gameLoop:", error);
                showGameOverScreen(); 
            }
        }

        /**
         * Inicia o loop do jogo.
         */
        function startGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**

         * Exibe a tela de Fim de Jogo.
         */
        async function showGameOverScreen() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            clearGameElements(); 
            finalScoreDisplay.textContent = score;
            
            // Pausa e reseta ambas as músicas ao Game Over
            backgroundMusic.pause(); 
            backgroundMusic.currentTime = 0; 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
            bossHealthBarHorizontalWrapper.classList.add('hidden'); // Esconde a barra de vida do boss

            // Lógica de Ranking
            const highScores = await getHighScores();
            console.log("showGameOverScreen: High Scores fetched:", highScores); 
            let isTop10 = false;
            if (highScores.length < 10) {
                isTop10 = true;
            } else {
                // Check if current score is higher than the lowest score in top 10
                const lowestTop10Score = highScores[highScores.length - 1].score;
                if (score > lowestTop10Score) {
                    isTop10 = true;
                }
            }
            console.log("showGameOverScreen: Is score Top 10?", isTop10); 

            if (isTop10) {
                gameOverScreen.classList.add('hidden'); 
                rankingScreen.classList.remove('hidden'); 
                nameInputForm.classList.remove('hidden'); 
                playerNameInput.value = ''; 
                playerNameInput.focus(); 
                displayHighScores(highScores, highScoresList); 
            } else {
                gameOverScreen.classList.remove('hidden'); 
                rankingScreen.classList.add('hidden'); 
            }
        }

        /**
         * Pausa o jogo.
         */
        function pauseGame() {
            if (gameRunning && !gamePaused) {
                gamePaused = true;
                cancelAnimationFrame(animationFrameId);
                pauseScreen.classList.remove('hidden');
                // pauseRankingContainer.classList.add('hidden'); // Removido
                // pauseContinueText.classList.remove('hidden'); // Removido
                backgroundMusic.pause(); 
                bossMusic.pause(); 
            }
        }

        /**
         * Retoma o jogo.
         */
        function resumeGame() {
            if (gameRunning && gamePaused) {
                gamePaused = false;
                pauseScreen.classList.add('hidden');
                startGameLoop();
                if (isAmbientMusicEnabled) { 
                    if (isBossFightActive) {
                        bossMusic.play().catch(e => console.log("Erro ao tocar música do boss:", e));
                    } else {
                        backgroundMusic.play().catch(e => console.log("Erro ao tocar música de fundo:", e));
                    }
                }
            }
        }

        // --- Firestore Functions ---

        /**
         * Salva uma nova pontuação no Firestore.
         * @param {string} name - Nome do jogador.
         * @param {number} score - Pontuação do jogador.
         */
        async function saveHighScore(name, score) {
            if (!userId) {
                console.error("User not authenticated. Cannot save high score.");
                return;
            }
            try {
                // Use o appId para criar um caminho de coleção único para este aplicativo.
                const scoresCollectionRef = collection(db, `artifacts/${appId}/public/data/highScores`);
                await addDoc(scoresCollectionRef, {
                    name: name,
                    score: score,
                    timestamp: Date.now(), 
                    userId: userId 
                });
                console.log("High score saved successfully!");
                // Após salvar, atualiza a lista de pontuações
                const updatedHighScores = await getHighScores();
                displayHighScores(updatedHighScores, highScoresList); 
                nameInputForm.classList.add('hidden'); 
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        }

        /**
         * Busca as 10 maiores pontuações do Firestore.
         * @returns {Array<Object>} Um array de objetos de pontuação.
         */
        async function getHighScores() {
            console.log("getHighScores: Attempting to fetch high scores..."); 
            try {
                const scoresCollectionRef = collection(db, `artifacts/${appId}/public/data/highScores`);
                // Ordena por score em ordem decrescente e limita a 10 resultados
                const q = query(scoresCollectionRef, orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                const scores = [];
                querySnapshot.forEach((doc) => {
                    scores.push(doc.data());
                });
                console.log("getHighScores: Fetched scores:", scores); 
                return scores;
            } catch (e) {
                console.error("Error getting documents: ", e);
            }
        }

        /**
         * Exibe as pontuações na lista de ranking.
         * @param {Array<Object>} scores - Array de objetos de pontuação.
         * @param {HTMLElement} targetListElement - O elemento UL onde as pontuações serão exibidas.
         */
        function displayHighScores(scores, targetListElement) {
            console.log("displayHighScores: Displaying scores:", scores); 
            targetListElement.innerHTML = ''; 
            if (scores.length === 0) {
                const li = document.createElement('li');
                li.textContent = "Nenhuma pontuação ainda.";
                targetListElement.appendChild(li);
                return;
            }
            scores.forEach((scoreData, index) => {
                const li = document.createElement('li');
                // CORREÇÃO: Usar scoreData.score para exibir a pontuação
                li.innerHTML = `<span>${index + 1}. ${scoreData.name || 'Anônimo'}</span><span>${scoreData.score}</span>`;
                targetListElement.appendChild(li);
            });
        }

        /**
         * Configura todos os event listeners e obtém referências aos elementos DOM.
         * Chamado no window.onload para garantir que todos os elementos estejam disponíveis.
         */
        function setupEventListeners() {
            // Reatribuição das referências DOM (agora dentro de uma função chamada no onload)
            gameContainer = document.getElementById('gameContainer');
            player = document.getElementById('player');
            playerDamageDisplay = document.getElementById('playerDamageDisplay'); 
            playerLevelDisplay = document.getElementById('playerLevelDisplay'); 

            gameOverScreen = document.getElementById('gameOverScreen');
            finalScoreDisplay = document.getElementById('finalScore');
            restartButton = document.getElementById('restartButton');
            startScreen = document.getElementById('startScreen');
            stageClearScreen = document.getElementById('stageClearScreen'); 
            continueButton = document.getElementById('continueButton');   
            pauseButton = document.getElementById('pauseButton'); 
            pauseScreen = document.getElementById('pauseScreen'); 

            // Referências aos elementos da nova UI de barras
            healthBarFill = document.getElementById('healthBarFill');
            overshieldBarFill = document.getElementById('overshieldBarFill');
            playerHealthText = document.getElementById('playerHealthText'); 
            // NOVO: Referências para a barra de escudo
            shieldBarWrapper = document.getElementById('shieldBarWrapper');
            shieldBarFill = document.getElementById('shieldBarFill');
            shieldHealthText = document.getElementById('shieldHealthText');

            // NOVAS REFERÊNCIAS PARA A BARRA DE VIDA DO BOSS (agora horizontal)
            bossHealthBarHorizontalWrapper = document.getElementById('bossHealthBarHorizontalWrapper');
            bossHealthBarHorizontalFill = document.getElementById('bossHealthBarHorizontalFill');
            bossHealthBarHorizontalText = document.getElementById('bossHealthBarHorizontalText'); // REINTRODUZIDO: Texto numérico da barra do boss

            // NOVAS REFERÊNCIAS PARA A BARRA DE PROGESSO DO ESTÁGIO (antiga barra de escudo)
            stageProgressBarWrapper = document.getElementById('stageProgressBarWrapper');
            stageProgressBarFill = document.getElementById('stageProgressBarFill');
            stageProgressValue = document.getElementById('stageProgressValue');


            pressStartText = document.getElementById('pressStartText'); 
            // pauseContinueText = document.getElementById('pauseContinueText'); // Removido

            rankingScreen = document.getElementById('rankingScreen');
            highScoresList = document.getElementById('highScoresList');
            nameInputForm = document.getElementById('nameInputForm');
            playerNameInput = document.getElementById('playerNameInput');
            submitScoreButton = document.getElementById('submitScoreButton');
            // rankingPlayAgainButton = document.getElementById('rankingPlayAgainButton'); // Removido
            showRankingButton = document.getElementById('showRankingButton'); 
            // backToStartScreenButton = document.getElementById('backToStartScreenButton'); // Removido

            // NOVO: Referências para os itens do menu de pausa
            resumeGameMenuItem = document.getElementById('resumeGameMenuItem');
            settingsMenuItem = document.getElementById('settingsMenuItem');
            restartGameMenuItem = document.getElementById('restartGameMenuItem');
            viewRankingMenuItem = document.getElementById('viewRankingMenuItem');

            // NOVO: Referências para os itens do menu de ranking
            rankingPlayAgainMenuItem = document.getElementById('rankingPlayAgainMenuItem');
            backFromRankingMenuItem = document.getElementById('backFromRankingMenuItem');


            // CORREÇÃO: Atribuir stageScoreDisplay ao elemento DOM
            stageScoreDisplay = document.getElementById('stageScore');


            // Referência ao novo contêiner de partículas
            particleContainer = document.getElementById('particleContainer');

            // Referências para a tela de carregamento
            loadingScreen = document.getElementById('loadingScreen');
            loadingProgressFill = document.getElementById('loadingProgressFill');

            // Referências para os elementos da tela de configurações
            // settingsButton = document.getElementById('settingsButton'); // Removido
            settingsScreen = document.getElementById('settingsScreen');
            toggleShotSoundCheckbox = document.getElementById('toggleShotSound');
            toggleAmbientMusicCheckbox = document.getElementById('toggleAmbientMusic');
            toggleExplosionSoundCheckbox = document.getElementById('toggleExplosionSound'); 
            backToPreviousScreenFromSettings = document.getElementById('backToPreviousScreenFromSettings'); // Renomeado para evitar conflito com o elemento HTML

            // NOVO: Referência para o display de falas do chefe
            bossTauntDisplay = document.getElementById('bossTauntDisplay');


            // --- Eventos de Controle ---

            // Controle de Toque (Celular)
            gameContainer.addEventListener('touchstart', (e) => {
                if (!gameRunning || gamePaused) return;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY; 
                playerMoving = true;
            });

            gameContainer.addEventListener('touchmove', (e) => {
                if (!gameRunning || !playerMoving || gamePaused) return;
                const gameContainerRect = gameContainer.getBoundingClientRect(); 

                // Certifique-se de que playerX e playerY estão atualizados a partir da posição do elemento player
                // Já que o player se move tanto por teclado quanto por mouse/toque, é melhor sempre recalcular
                const currentPlayerLeft = parseFloat(player.style.left);
                const currentPlayerBottom = parseFloat(player.style.bottom);
                playerX = currentPlayerLeft;
                playerY = gameContainer.offsetHeight - currentPlayerBottom - player.offsetHeight;


                const touchCurrentX = e.touches[0].clientX;
                const touchCurrentY = e.touches[0].clientY; 
                const deltaX = touchCurrentX - touchStartX;
                const deltaY = touchCurrentY - touchStartY; 
                
                // Mova o player com base na diferença do toque, mas dentro dos limites do gameContainer
                playerX += deltaX;
                playerY += deltaY;

                playerX = Math.max(0, Math.min(playerX, gameContainer.offsetWidth - player.offsetWidth));
                playerY = Math.max(0, Math.min(playerY, gameContainer.offsetHeight - player.offsetHeight)); 

                updatePlayerPosition();
                touchStartX = touchCurrentX;
                touchStartY = touchCurrentY; 
            });

            gameContainer.addEventListener('touchend', () => {
                playerMoving = false;
            });

            // Controle de Teclado (Desktop)
            document.addEventListener('keydown', (e) => {
                if (!gameRunning || gamePaused) return;

                // Get current player position relative to game container
                playerX = parseFloat(player.style.left);
                playerY = gameContainer.offsetHeight - parseFloat(player.style.bottom) - player.offsetHeight;

                if (isNaN(playerX)) playerX = gameContainer.offsetWidth / 2 - player.offsetWidth / 2;
                if (isNaN(playerY)) playerY = gameContainer.offsetHeight - player.offsetHeight - 20;


                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                    playerX = Math.max(0, playerX - playerSpeed * 2);
                } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                    playerX = Math.min(gameContainer.offsetWidth - player.offsetWidth, playerX + playerSpeed * 2);
                } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') { 
                    playerY = Math.max(0, playerY - playerSpeed * 2); 
                } else if (e.key === ' ' && window.innerWidth > 768) { // Pausa com espaço apenas no desktop
                    pauseGame();
                }
                updatePlayerPosition();
            });

            // Mouse Follow Controls (Desktop)
            gameContainer.addEventListener('mousemove', (e) => {
                if (!gameRunning || gamePaused) return;
                const gameContainerRect = gameContainer.getBoundingClientRect();

                // Calculate new player position based on mouse position relative to game container
                // Center the player element on the mouse cursor
                let newPlayerX = e.clientX - gameContainerRect.left - (player.offsetWidth / 2);
                let newPlayerY = e.clientY - gameContainerRect.top - (player.offsetHeight / 2);

                // Clamp player position within game boundaries
                playerX = Math.max(0, Math.min(newPlayerX, gameContainer.offsetWidth - player.offsetWidth));
                playerY = Math.max(0, Math.min(newPlayerY, gameContainer.offsetHeight - player.offsetHeight));

                updatePlayerPosition();
            });


            // Botão Reiniciar (na tela de Game Over)
            restartButton.addEventListener('click', initializeGame);
            
            // Evento no div startScreen para iniciar o jogo (qualquer toque/clique)
            startScreen.addEventListener('click', () => { 
                if (startScreen.classList.contains('hidden')) return; 
                initializeGame();
                toggleFullScreen(); 
            }); 
            
            // Botão Continuar para a tela de Stage Clear
            continueButton.addEventListener('click', () => {
                startNextStage();
                toggleFullScreen(); 
            }); 

            // Botão de Pausa (agora só para mobile, mas o evento está no botão no rodapé)
            pauseButton.addEventListener('click', pauseGame);
            
            // Eventos dos itens do menu de pausa
            resumeGameMenuItem.addEventListener('click', () => { 
                resumeGame();
            });

            settingsMenuItem.addEventListener('click', () => {
                pauseScreen.classList.add('hidden');
                settingsScreen.classList.remove('hidden');
                updateSoundSettingsUI(); 
                previousScreen = 'pause'; 
            });

            restartGameMenuItem.addEventListener('click', initializeGame);

            viewRankingMenuItem.addEventListener('click', async () => {
                pauseScreen.classList.add('hidden');
                rankingScreen.classList.remove('hidden');
                nameInputForm.classList.add('hidden'); 
                const highScores = await getHighScores();
                displayHighScores(highScores, highScoresList); 
                previousScreen = 'pause'; // Define a tela anterior como pausa
            });


            // Botão de Enviar Pontuação (na tela de Ranking)
            submitScoreButton.addEventListener('click', () => {
                const playerName = playerNameInput.value.trim();
                if (playerName) {
                    saveHighScore(playerName, score);
                } else {
                    // Substitua alert() por um modal customizado no jogo real
                    const messageBox = document.createElement('div');
                    messageBox.style.cssText = `
                        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background-color: #333; color: white; padding: 20px; border-radius: 10px;
                        font-family: 'Press Start 2P', cursive; text-align: center; z-index: 100;
                        box-shadow: 0 0 10px rgba(0,0,0,0.5);
                    `;
                    messageBox.innerHTML = `
                        <p>Por favor, insira seu nome!</p>
                        <button style="margin-top: 10px; padding: 5px 10px; background-color: #f6e05e; color: #1a202c; border: none; border-radius: 5px; cursor: pointer;">OK</button>
                    `;
                    document.body.appendChild(messageBox);
                    messageBox.querySelector('button').addEventListener('click', () => {
                        messageBox.remove();
                    });
                }
            });

            // Botão Jogar Novamente (na tela de Ranking)
            rankingPlayAgainMenuItem.addEventListener('click', initializeGame);

            // Evento para mostrar o ranking (botão na tela de Game Over)
            showRankingButton.addEventListener('click', async () => {
                console.log("showRankingButton: Clicked to show ranking."); 
                gameOverScreen.classList.add('hidden');
                rankingScreen.classList.remove('hidden');
                nameInputForm.classList.add('hidden'); 
                const highScores = await getHighScores();
                displayHighScores(highScores, highScoresList); 
                previousScreen = 'gameover'; // Define a tela anterior como gameover
            });

            // Botão para voltar da tela de ranking (dinâmico)
            backFromRankingMenuItem.addEventListener('click', () => {
                rankingScreen.classList.add('hidden');
                if (previousScreen === 'pause') {
                    pauseScreen.classList.remove('hidden');
                } else {
                    startScreen.classList.remove('hidden');
                }
                // previousScreen = null; // REMOVIDO: Não resetar previousScreen aqui
            });

            // Eventos da nova tela de configurações
            // settingsButton.addEventListener('click', () => { // Removido
            //     startScreen.classList.add('hidden');
            //     settingsScreen.classList.remove('hidden');
            //     updateSoundSettingsUI(); 
            //     previousScreen = 'start'; 
            // });

            toggleShotSoundCheckbox.addEventListener('change', () => {
                isShotSoundEnabled = toggleShotSoundCheckbox.checked;
                saveSoundSettings();
            });

            toggleAmbientMusicCheckbox.addEventListener('change', () => {
                isAmbientMusicEnabled = toggleAmbientMusicCheckbox.checked;
                saveSoundSettings();
                applyMusicSettings(); 
            });

            toggleExplosionSoundCheckbox.addEventListener('change', () => { 
                isExplosionSoundEnabled = toggleExplosionSoundCheckbox.checked;
                saveSoundSettings();
            });

            backToPreviousScreenFromSettings.addEventListener('click', () => {
                settingsScreen.classList.add('hidden');
                if (previousScreen === 'pause') {
                    pauseScreen.classList.remove('hidden');
                } else {
                    startScreen.classList.remove('hidden');
                }
                // previousScreen = null; // REMOVIDO: Não resetar previousScreen aqui
            });
        }


        // Exibe a tela inicial ao carregar
        window.onload = async () => {
            // Configura os event listeners e obtém as referências DOM primeiro
            setupEventListeners();
            
            // Exibe a tela de carregamento
            loadingScreen.classList.remove('hidden');
            console.log("window.onload: Tela de carregamento visível.");

            // Carrega as configurações de som antes do pré-carregamento para que a música inicial respeite as preferências
            loadSoundSettings();

            // Pré-carrega os assets (apenas imagens e músicas de fundo/boss)
            await preloadAssets();
            console.log("window.onload: Pré-carregamento de assets concluído.");

            // Esconde a tela de carregamento e mostra a tela inicial
            loadingScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            console.log("window.onload: Tela de carregamento escondida, tela inicial visível.");
            
            // Garante que outras telas de jogo estejam escondidas no início
            gameOverScreen.classList.add('hidden'); 
            stageClearScreen.classList.add('hidden'); 
            pauseScreen.classList.add('hidden'); 
            rankingScreen.classList.add('hidden'); 
            nameInputForm.classList.add('hidden'); 
            settingsScreen.classList.add('hidden'); 
            
            gameRunning = false; 
            gamePaused = false; 
            console.log("window.onload: Jogo inicializado e pronto para começar.");
        };

        // NOVO: Função para gerar falas do chefe usando a Gemini API
        async function generateBossTaunt(promptText) {
            const bossTauntDisplay = document.getElementById('bossTauntDisplay'); // Garante que a referência é obtida aqui

            if (!bossTauntDisplay) {
                console.error("Elemento bossTauntDisplay não encontrado.");
                return;
            }

            bossTauntDisplay.classList.remove('visible'); // Esconde antes de gerar nova fala
            bossTauntDisplay.textContent = '...'; // Indicador de carregamento

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: promptText }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyDB_ZjOi57saguQuCGFfsRhlCPXKGzEoaU"; // API Key inserida
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    bossTauntDisplay.textContent = text;
                    bossTauntDisplay.classList.add('visible');
                    // Esconde a fala após alguns segundos
                    setTimeout(() => {
                        bossTauntDisplay.classList.remove('visible');
                    }, 5000); // 5 segundos
                } else {
                    console.error("Estrutura de resposta inesperada da Gemini API:", result);
                    bossTauntDisplay.textContent = "Erro na comunicação...";
                    bossTauntDisplay.classList.add('visible');
                    setTimeout(() => {
                        bossTauntDisplay.classList.remove('visible');
                    }, 2000);
                }
            } catch (error) {
                console.error("Erro ao chamar Gemini API:", error);
                bossTauntDisplay.textContent = "Erro na comunicação...";
                setTimeout(() => {
                    bossTauntDisplay.classList.remove('visible');
                }, 2000);
            }
        }
    </script>
</body>
</html>
