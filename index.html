<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiro no Metrô</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Fonte padrão, mas Press Start 2P para elementos do jogo */
            background-color: #1a202c; /* Cor de fundo escura */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Evita barras de rolagem */
        }

        .game-master-wrapper {
            display: flex;
            flex-direction: column; /* Empilha os contêineres verticalmente */
            border-radius: 1.5rem; /* Cantos mais arredondados para o wrapper geral */
            overflow: hidden; /* Garante que o conteúdo respeite o border-radius */
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.7); /* Sombra mais forte para profundidade */
            border: 4px solid #4a5568; /* Borda mais grossa */
            width: 400px; /* Largura fixa para a área total do jogo */
            height: 700px; /* Altura fixa para a área total do jogo */
            max-width: 95vw; /* Garante que caiba em telas menores */
            max-height: 95vh; /* Garante que caiba em telas menores */
            background-color: #2d3748; /* Fundo para o próprio wrapper */
            position: relative; /* Para sobreposição da tela inicial */
        }

        /* Novo layout principal do jogo */
        .main-game-layout {
            display: flex;
            flex-grow: 1; /* Permite que ocupe o espaço restante */
            width: 100%;
            height: 100%; /* Ocupa toda a altura disponível dentro do wrapper */
        }

        /* Contêineres laterais para barras de vida/escudo */
        .sidebar-container {
            width: 25px; /* Largura das barras laterais (ainda mais fina) */
            background-color: #1a202c;
            display: flex;
            flex-direction: column; /* Barras verticais */
            align-items: center;
            padding: 0.5rem 0.2rem;
            flex-shrink: 0;
            z-index: 10;
            position: relative; /* Para posicionamento de ícones e texto */
        }

        .left-sidebar {
            border-right: 2px solid #4a5568;
            box-shadow: inset -3px 0 5px rgba(0,0,0,0.3);
        }

        .right-sidebar {
            border-left: 2px solid #4a5568;
            box-shadow: inset 3px 0 5px rgba(0,0,0,0.3);
        }

        .sidebar-bar-wrapper {
            width: 100%;
            flex-grow: 1; /* Ocupa o espaço vertical disponível */
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* Preenche de baixo para cima */
            align-items: center;
            margin-top: 1rem; /* Espaço do topo */
            margin-bottom: 1rem; /* Espaço da base */
            position: relative;
        }

        .vertical-bar {
            width: 15px; /* Largura da barra vertical */
            height: 100%; /* Altura total do wrapper */
            background-color: #555;
            border-radius: 7.5px; /* Metade da largura para cantos arredondados */
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255,255,255,0.2);
            display: flex; /* Para centralizar o texto */
            align-items: flex-end; /* Para o preenchimento subir */
        }

        .vertical-fill {
            width: 100%;
            background-color: #f6e05e; /* Amarelo para vida normal */
            transition: height 0.2s ease-out, background-color 0.2s ease-out;
            position: absolute;
            bottom: 0; /* Começa do fundo */
        }

        .vertical-overshield-fill { /* NOVO: Estilo para a barra de sobrevida */
            width: 100%;
            background-color: #8A2BE2; /* Roxo vibrante para sobrevida */
            transition: height 0.2s ease-out;
            position: absolute;
            bottom: 0;
            z-index: 1; /* Acima do preenchimento normal, abaixo do texto */
        }

        .vertical-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg); /* Gira e centraliza o texto */
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 2;
            white-space: nowrap;
        }

        .sidebar-icon {
            font-size: 1.2rem;
            color: #cbd5e0;
            margin-bottom: 0.5rem;
        }

        /* Contêiner da área do jogo (agora central) */
        .game-area-wrapper {
            flex-grow: 1; /* Ocupa o espaço central restante */
            display: flex;
            flex-direction: column;
            position: relative; /* Para posicionar elementos internos */
        }

        /* Novo contêiner superior para Dano e Nível */
        .top-info-container {
            width: 100%;
            background-color: #1a202c;
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-between; /* Espaço entre os itens */
            align-items: center;
            color: #cbd5e0;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            flex-shrink: 0;
            border-bottom: 2px solid #4a5568;
            box-shadow: inset 0 -3px 5px rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* Contêiner do jogo em si (o que rolava antes) */
        .game-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Ocupa o espaço restante entre top e bottom info */
            overflow: hidden;
            /* REMOVIDO: transition: filter 0.5s ease-in-out; */
        }

        /* Novo contêiner inferior para Progresso do Boss e Pontos */
        .bottom-info-container {
            width: 100%;
            background-color: #1a202c;
            padding: 0.8rem 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            color: #cbd5e0;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            flex-shrink: 0;
            border-top: 2px solid #4a5568;
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* Estilos existentes (mantidos e ajustados) */
        .background-segment {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('https://i.ibb.co/fYVsCnG4/file-000000003bdc622f9c39eafbf705cd33.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 0;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
            transition: filter 0.5s ease-in-out; /* Adicionado para transição suave */
        }

        .background-segment.rotated-180 {
            transform: rotate(180deg);
        }

        .player {
            position: absolute;
            bottom: 20px;
            width: 60px;
            height: 60px;
            background-image: url('https://i.ibb.co/mrgQRnPP/file-00000000bd8861f8b1feda6cccc966af.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            left: calc(50% - 30px);
            box-shadow: 0 0 15px 5px rgba(99, 179, 237, 0.9), 0 0 25px 10px rgba(99, 179, 237, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 7;
            transition: filter 0.1s ease-out;
            /* REMOVIDO: filter: hue-rotate(...) para não ser afetado pelo estágio */
        }

        .player.player-hit-effect {
            filter: invert(100%) hue-rotate(180deg);
        }

        .player.player-shield-active {
            filter: hue-rotate(200deg) brightness(1.2);
            box-shadow: 0 0 20px 8px rgba(0, 0, 255, 0.9), 0 0 30px 15px rgba(0, 0, 255, 0.5);
        }

        .bullet {
            position: absolute;
            background-color: #f6e05e;
            width: 8px;
            height: 20px;
            border-radius: 0.25rem;
            box-shadow: 0 0 8px 3px rgba(246, 224, 94, 0.9), 0 0 15px 5px rgba(246, 224, 94, 0.5);
            z-index: 5;
        }

        .falling-object {
            position: absolute;
            top: -60px;
            width: 60px;
            height: 60px;
            background-image: url('https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: filter 0.1s ease-out;
            z-index: 2;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
        }

        .falling-object.enemy-hit-effect {
            filter: brightness(200%) saturate(200%);
        }

        .falling-object.heavy-enemy {
            width: 72px;
            height: 72px;
            z-index: 6;
        }

        .enemy-health-bar-wrapper {
            position: absolute;
            width: 100%;
            top: -15px;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3;
        }

        .enemy-health-bar {
            width: 80%;
            height: 5px;
            background-color: #555;
            border-radius: 2.5px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .enemy-health-fill {
            height: 100%;
            background-color: #48bb78;
            width: 100%;
            transition: width 0.1s ease-out, background-color 0.1s ease-out;
        }

        .power-up, .debuff {
            position: absolute;
            width: 36px; /* 20% maior */
            height: 36px; /* 20% maior */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            z-index: 6;
            animation: pulse 1s infinite alternate, neon-glow 1.5s infinite alternate; /* Efeito neon */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /* REMOVIDO: hue-rotate(${-currentStageHueRotation}deg) */
            filter: saturate(200%) brightness(150%); /* Apenas saturação e brilho para neon */
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            to { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes neon-glow {
            0% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px var(--neon-color, #00f), 0 0 15px var(--neon-color, #00f); }
            50% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px var(--neon-color, #00f), 0 0 30px var(--neon-color, #00f); }
            100% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 10px var(--neon-color, #00f), 0 0 15px var(--neon-color, #00f); }
        }

        .game-over-screen, .start-screen, .stage-clear-screen, .pause-screen, .ranking-screen { /* Adicionado .ranking-screen */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            z-index: 30;
            border-radius: 1.5rem;
        }

        .start-screen {
            background-image: url('https://i.ibb.co/JjxJVM6D/1753025379623.png'); /* NOVA IMAGEM DE TELA INICIAL */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .start-screen h1, .start-screen p {
            color: #f6e05e; /* Garante que o texto seja visível sobre a imagem */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); /* Adiciona sombra para legibilidade */
        }

        /* Estilo para o texto "PRESS START" piscando */
        #pressStartText {
            font-size: 1.5rem; /* Tamanho ajustado */
            color: #f6e05e;
            text-shadow: 0 0 8px rgba(246, 224, 94, 0.8);
            animation: blink 1s infinite;
            margin-top: 20px; /* Adiciona um pouco de espaço */
        }

        @keyframes blink {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; } /* CORRIGIDO: Era 'opacity = 0;' */
        }

        .pause-screen, .ranking-screen { /* Adicionado .ranking-screen */
            background-image: url('https://i.ibb.co/JjxJVM6D/1753025379623.png'); /* MESMA IMAGEM DA TELA INICIAL */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Estilo para o texto "CONTINUAR" na tela de pausa */
        #pauseContinueText {
            font-size: 1.5rem; /* Tamanho ajustado */
            color: #f6e05e;
            text-shadow: 0 0 8px rgba(246, 224, 94, 0.8);
            margin-bottom: 20px; /* Espaço para o botão */
        }
        /* Estilo para a lista de ranking na tela de pausa */
        #pauseRankingDisplay {
            list-style: none;
            padding: 0;
            margin: 1rem 0 2rem 0;
            width: 80%;
            max-width: 300px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
            color: #cbd5e0;
            font-size: 0.8rem;
            text-align: left; /* Alinha o texto à esquerda na lista */
            max-height: 200px; /* Limita a altura para caber na tela de pausa */
            overflow-y: auto; /* Adiciona rolagem se a lista for muito longa */
        }

        #pauseRankingDisplay li {
            padding: 0.4rem 0.8rem;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid rgba(74, 85, 104, 0.3);
        }
        #pauseRankingDisplay li:last-child {
            border-bottom: none;
        }


        /* Estilos para a tela de Ranking */
        .ranking-screen h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: #48bb78; /* Verde para o título do ranking */
            text-shadow: 0 0 10px rgba(72, 187, 120, 0.8);
        }

        .ranking-screen ul {
            list-style: none;
            padding: 0;
            margin: 1rem 0 2rem 0;
            width: 80%;
            max-width: 300px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
        }

        .ranking-screen li {
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #cbd5e0;
            border-bottom: 1px solid rgba(74, 85, 104, 0.5);
        }

        .ranking-screen li:last-child {
            border-bottom: none;
        }

        .ranking-input-form {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            align-items: center;
            margin-top: 1rem;
        }

        .ranking-input-form input[type="text"] {
            background-color: #2d3748;
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            padding: 0.6rem 1rem;
            color: #cbd5e0;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            text-align: center;
            outline: none;
        }

        .ranking-input-form input::placeholder {
            color: #a0aec0;
        }

        .ranking-input-form button {
            background-color: #f6e05e;
            color: #1a202c;
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .ranking-input-form button:hover {
            background-color: #d69e2e;
            transform: translateY(-2px);
        }


        .game-over-screen h1, .start-screen h1, .stage-clear-screen h1, .pause-screen h1 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #f6e05e;
            text-shadow: 0 0 10px rgba(246, 224, 94, 0.8);
        }

        .game-over-screen p, .stage-clear-screen p, .pause-screen p {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .restart-button, .start-button, .continue-button, .pause-button-style, .resume-button, .submit-score-button, .ranking-play-again-button { /* Adicionado submit-score-button, ranking-play-again-button */
            background-color: #48bb78;
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 12px rgba(72, 187, 120, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .restart-button:hover, .start-button:hover, .continue-button:hover, .pause-button-style:hover, .resume-button:hover, .submit-score-button:hover, .ranking-play-again-button:hover {
            background-color: #38a169;
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(72, 187, 120, 0.6);
        }

        .restart-button:active, .start-button:active, .continue-button:active, .pause-button-style:active, .resume-button:active, .submit-score-button:active, .ranking-play-again-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(72, 187, 120, 0.4);
        }

        .hidden {
            display: none;
        }

        .boss {
            position: absolute;
            top: 50px;
            width: 100px;
            height: 100px;
            background-image: url('https://i.ibb.co/WWJbQ2xC/file-0000000084d061f8ac4929730520d69e.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 8;
            transition: filter 0.1s ease-out;
        }

        .boss-health-bar-wrapper {
            position: absolute;
            width: 100px;
            z-index: 9;
        }

        .boss-health-bar {
            width: 100%;
            height: 15px;
            background-color: #555;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .boss-health-fill {
            height: 100%;
            background-color: #48bb78;
            width: 100%;
            transition: width 0.2s ease-out;
        }

        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 2;
            white-space: nowrap;
            line-height: 1;
        }

        .boss-bullet {
            position: absolute;
            background-image: url('https://placehold.co/15x15/ff0000/FFFFFF/png?text=B');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            box-shadow: 0 0 10px 3px rgba(255, 0, 0, 0.8);
            z-index: 4;
        }

        .enemy-bullet {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            z-index: 4;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .enemy-bullet-color {
            background-color: #ffcc00;
            box-shadow: 0 0 8px 2px rgba(255, 204, 0, 0.7);
        }

        .enemy-bullet.heavy-enemy-bullet {
            width: 24px; /* AUMENTADO PARA 24px */
            height: 24px; /* AUMENTADO PARA 24px */
        }
        .heavy-enemy-bullet-color {
            background-color: #FF4500; /* Laranja avermelhado vibrante */
            box-shadow: 0 0 15px 6px rgba(255, 69, 0, 0.9), 0 0 25px 10px rgba(255, 69, 0, 0.6); /* Brilho mais intenso */
        }

        .obstacle {
            position: absolute;
            top: -50px;
            width: 45px;
            height: 45px;
            background-image: url('https://i.ibb.co/GQNYF8tQ/file-000000007a5c61f7ab26c44fcda85d3b.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
            z-index: 3;
            filter: hue-rotate(var(--stage-hue-rotation)); /* APLICADO AQUI */
        }

        /* Botão de pausa flutuante na área do jogo */
        .pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20; /* Acima dos elementos do jogo, mas abaixo das telas de menu */
            background-color: rgba(246, 224, 94, 0.8); /* Amarelo semi-transparente */
            color: #1a202c;
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
        }
        .pause-button:hover {
            background-color: #f6e05e;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
        }
    </style>
</head>
<body>
    <div class="game-master-wrapper">
        <div class="main-game-layout">
            <!-- Left Sidebar for Shield Bar -->
            <div class="sidebar-container left-sidebar">
                <i class="fas fa-shield-alt sidebar-icon"></i>
                <div class="sidebar-bar-wrapper">
                    <div class="vertical-bar" id="shieldHealthBar">
                        <div class="vertical-fill" id="shieldHealthFill"></div>
                        <span class="vertical-text" id="shieldHealthText"></span>
                    </div>
                </div>
            </div>

            <div class="game-area-wrapper">
                <!-- Top Info Container for Player Stats -->
                <div class="top-info-container">
                    <div class="info-item">
                        <i class="fas fa-fist-raised"></i>
                        <span>Dano: <span id="playerDamageDisplay">1</span></span>
                    </div>
                    <div class="info-item">
                        <i class="fas fa-medal"></i>
                        <span>Nível: <span id="playerLevelDisplay">1</span></span>
                    </div>
                    <div class="info-item">
                        <i class="fas fa-star"></i>
                        <span>Pontos: <span id="scoreValue">0</span></span>
                    </div>
                </div>

                <div class="game-container" id="gameContainer">
                    <div class="background-segment" id="bgSegment1"></div>
                    <div class="background-segment" id="bgSegment2"></div>

                    <div class="player" id="player">
                    </div>

                    <div class="start-screen" id="startScreen">
                        <p id="pressStartText">PRESS START</p> <!-- Texto "PRESS START" piscando -->
                    </div>

                    <div class="game-over-screen hidden" id="gameOverScreen">
                        <h1>FIM DE JOGO!</h1>
                        <p>Sua Pontuação: <span id="finalScore">0</span></p>
                        <button class="restart-button" id="restartButton">JOGAR NOVAMENTE</button>
                        <button class="screen-button" id="showRankingButton">VER RANKING</button> <!-- Botão adicionado -->
                    </div>

                    <div class="stage-clear-screen hidden" id="stageClearScreen">
                        <h1>ESTÁGIO CONCLUÍDO!</h1>
                        <p>Pontuação do Estágio: <span id="stageScore">0</span></p>
                        <button class="continue-button" id="continueButton">CONTINUAR</button>
                    </div>

                    <div class="pause-screen hidden" id="pauseScreen">
                        <p id="pauseContinueText">PAUSADO</p> <!-- Alterado para PAUSADO -->
                        <div id="pauseRankingDisplay">
                            <!-- Ranking será inserido aqui dinamicamente -->
                        </div>
                        <p>Toque em qualquer lugar para continuar.</p> <!-- Instrução para o jogador -->
                    </div>

                    <!-- Nova tela de ranking -->
                    <div class="ranking-screen hidden" id="rankingScreen">
                        <h1>TOP 10 PONTUAÇÕES</h1>
                        <ul id="highScoresList">
                            <!-- Itens do ranking serão inseridos aqui pelo JS -->
                        </ul>
                        <div class="ranking-input-form hidden" id="nameInputForm">
                            <p>Parabéns! Você entrou no Top 10!</p>
                            <input type="text" id="playerNameInput" placeholder="Seu nome" maxlength="10">
                            <button id="submitScoreButton">Enviar Pontuação</button>
                        </div>
                        <button class="ranking-play-again-button" id="rankingPlayAgainButton">JOGAR NOVAMENTE</button>
                    </div>

                    <!-- Botão de Pausa movido para dentro de game-container -->
                    <button class="pause-button" id="pauseButton">PAUSAR</button>
                </div>

                <!-- Bottom Info Container for Boss Progress -->
                <div class="bottom-info-container">
                    <i class="fas fa-dungeon"></i>
                    <span>Boss: <span id="bossProgressText">0 / 50</span></span>
                    <div class="boss-progress-bar">
                        <div class="boss-progress-fill" id="bossProgressFill"></div>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar for Health Bar -->
            <div class="sidebar-container right-sidebar">
                <i class="fas fa-heart sidebar-icon"></i>
                <div class="sidebar-bar-wrapper">
                    <div class="vertical-bar" id="playerHealthBar">
                        <div class="vertical-fill" id="healthFill"></div>
                        <div class="vertical-overshield-fill" id="overshieldFill"></div> <!-- NOVO: Barra de sobrevida -->
                        <span class="vertical-text" id="playerHealthText"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyAv0ptf_r0wd4smm24uJBIpUtKuSNVr5iY",
            authDomain: "navizinhas.firebaseapp.com",
            projectId: "navizinhas",
            storageBucket: "navizinhas.firebasestorage.app",
            messagingSenderId: "890224253385",
            appId: "1:890224253385:web:34f00091c09694aab43018",
            measurementId: "G-GE8MVDE7TV"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId = null;
        // __app_id é fornecido pelo ambiente Canvas, se disponível.
        // Caso contrário, usamos o projectId do FirebaseConfig como um fallback seguro.
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;


        // Authenticate anonymously
        // onAuthStateChanged will be triggered automatically on Firebase init
        // We ensure signInAnonymously is called if no token is provided.
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("Firebase authenticated. User ID:", userId);
            } else {
                try {
                    // __initial_auth_token é fornecido pelo ambiente Canvas para autenticação customizada.
                    // Se não estiver disponível, fazemos login anonimamente.
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token !== null) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                    userId = auth.currentUser.uid;
                    console.log("Firebase authenticated anonymously. User ID:", userId);
                } catch (error) {
                    console.error("Firebase authentication error:", error);
                    // Mesmo se a autenticação falhar, o jogo deve tentar rodar, apenas sem o ranking.
                    // Não há necessidade de 'resolve()' aqui, pois não estamos em uma Promise.
                }
            }
        });


        // Referências aos elementos DOM (declaradas no escopo global para serem acessíveis)
        let gameContainer, player, scoreValueDisplay, playerDamageDisplay, playerLevelDisplay, 
            gameOverScreen, finalScoreDisplay, restartButton, startScreen, stageClearScreen, 
            continueButton, pauseButton, pauseScreen, playerHealthBar, healthFill, 
            overshieldFill, playerHealthText, shieldHealthBar, shieldHealthFill, 
            shieldHealthText, bossProgressText, bossProgressFill, pressStartText, 
            pauseContinueText, rankingScreen, highScoresList, nameInputForm, 
            playerNameInput, submitScoreButton, rankingPlayAgainButton, showRankingButton,
            pauseRankingDisplay; // Adicionado pauseRankingDisplay aqui


        // Segmentos de fundo
        const bgSegment1 = document.getElementById('bgSegment1');
        const bgSegment2 = document.getElementById('bgSegment2');
        const backgroundSegments = [bgSegment1, bgSegment2];
        
        // Variáveis de estado do jogo
        let score = 0;
        let health = 0; 
        let maxHealth = 100; 
        let maxOvershieldHealth = 200; 
        let gameRunning = false;
        let playerX; 
        let playerY; 
        let playerSpeed = 8; 
        let gamePaused = false; 
        
        // Velocidades base e ajustadas
        const baseEnemyMovementSpeed = 5; 
        const baseEnemyBulletSpeed = 5;   
        const baseObstacleSpawnInterval = 2500; 
        let backgroundScrollSpeed = 2; 

        // Velocidades e intervalos ajustados (can be modified by difficulty)
        let currentEnemyMovementSpeed = baseEnemyMovementSpeed * 0.8 * 0.7; 
        let currentEnemyBulletSpeed = baseEnemyBulletSpeed * 1.4;     
        let collectibleMovementSpeed = 0; 
        let currentObstacleSpawnInterval = baseObstacleSpawnInterval; 

        let objectSpawnInterval = 1500; 
        let lastObjectSpawnTime = 0;
        let fallingObjects = []; 
        let obstacles = []; 
        let animationFrameId;

        // Player shooting variables
        let bullets = []; 
        let bulletSpeed = 10; 
        let shootInterval = 300; 
        let lastShotTime = 0;
        let bulletDamage = 1; 
        let slantedBulletsActive = false; 
        let sideShotsLevel = 0; 

        // Collectible variables
        let collectibles = []; 
        let collectibleDropChance = 0.07; 
        const collectibleStationaryDuration = 5000; 

        // Boss variables
        let boss = null;
        let bossHealth = 0;
        const initialBossHealth = 200; 
        let bossBullets = [];
        let bossShootInterval = 3000; 
        let lastBossShotTime = 0;
        let isBossFightActive = false;
        let bossMovementDirection = 1; 
        const bossMovementSpeed = 2.5; 
        const bossPadding = 10; 
        let bossLevel = 0; 
        const initialBossBulletDamage = 20; 
        let currentBossBulletDamage = initialBossBulletDamage; 
        let nextBossScoreThreshold = 50; 
        let bossRageThreshold = 0; 
        let bossRageActive = false; 
        let lastBossPowerUpDropTime = 0; 
        const bossFightPowerUpInterval = 10000; 

        // Boss hue rotation values for different levels
        const bossHueRotations = [0, 90, 180, 270, 30]; 

        // Player level variable
        let playerLevel = 1;

        // Enemy bullet variables
        let enemyBullets = []; 

        // Obstacle variables
        const obstacleDamage = 20; 
        let lastObstacleSpawnTime = 0;

        // Shield variables
        let shieldActive = false;
        let shieldHealth = 0;
        const maxShieldHealth = 100;

        // Variable to control if a heavy enemy is on screen
        let isHeavyEnemyOnScreen = false; 

        // Definition of the new heavy enemy
        const heavyEnemyDefinition = {
            type: 'heavy_enemy',
            hits: 100, 
            sprite: 'https://i.ibb.co/LztRMfLf/file-000000003cc4622f93ccd51271bb76c1.png', 
            width: 72, 
            height: 72, 
            speed: 1.95, 
            shootInterval: 1000, 
            baseBulletDamage: 20, 
            hueRotations: [0, 90, 180] 
        };

        // Base damage of enemy bullets (for scaling)
        const baseEnemyBulletDamage = 10; 

        // Power-up types with neon colors
        const powerUpTypes = [
            { type: 'damage_1', text: '+1', color: '#00FFFF', damageIncrease: 1, sprite: 'https://i.ibb.co/tpmGNwnx/file-00000000c23c61f79d81df79065596e4.png', hueRotate: 140 }, 
            { type: 'side_bullets', text: '>>', color: '#FF00FF', damageIncrease: 0, sprite: 'https://i.ibb.co/6JGv0Nk7/file-00000000f4c461f7a9330c93bf5d848c.png', hueRotate: 50 }, 
            { type: 'shield', text: 'ESC', color: '#00FF00', damageIncrease: 0, sprite: 'https://i.ibb.co/HfN8Wkv3/file-00000000553861f78733587cf43f0566.png', hueRotate: 240 }, 
        ];
        // New health power-up type (added separately for spawn control)
        const healthPowerUpType = { type: 'health_up', text: '❤️', color: '#FFFF00', healthIncrease: 20, sprite: 'https://i.ibb.co/RpmCgPyD/file-00000000fdf061f59a3de32e7e743922-1.png', hueRotate: 50 }; 

        // Debuff type
        const debuffType = { type: 'damage_down', text: '-1', color: '#FF4500', damageDecrease: 1, sprite: 'https://i.ibb.co/FbvqcCqK/file-000000007ee861fdb4cec6e89e0ac0ba.png', hueRotate: 30 }; 

        // Enemy types and their properties (hits needed, base color, hue rotation)
        const enemyTypes = [
            { scoreThreshold: 0, hits: 1, hueRotate: 0, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 20, hits: 2, hueRotate: 60, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 40, hits: 3, hueRotate: 120, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 60, hits: 4, hueRotate: 180, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }, 
            { scoreThreshold: 80, hits: 5, hueRotate: 240, sprite: 'https://i.ibb.co/TMFR5810/file-00000000646c61f8b1feda6cccc966af.png' }  
        ];

        // Cores de fundo do cenário para indicar níveis avançados (mais coloridas)
        const backgroundPresets = [
            'linear-gradient(to bottom, #4a90e2 0%, #2e6cb8 100%)', 
            'linear-gradient(to bottom, #7ed321 0%, #5cb82e 100%)', 
            'linear-gradient(to bottom, #f5a623 0%, #d08b1a 100%)', 
            'linear-gradient(to bottom, #bd10e0 0%, #9a0db8 100%)', 
            'linear-gradient(to bottom, #50e3c2 0%, #3bb29c 100%)', 
            'linear-gradient(to bottom, #f8e71c 0%, #d0c015 100%)', 
            'linear-gradient(to bottom, #9013fe 0%, #6b0bc4 100%)'  
        ];
        let currentColorIndex = 0;
        let currentStageHueRotation = 0; 
        const stageHueRotationIncrement = 60; 

        // Variáveis para controle de toque
        let touchStartX = 0;
        let touchStartY = 0; 
        let playerMoving = false;

        // Referência ao elemento de áudio
        const backgroundMusic = new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3'); 
        backgroundMusic.loop = true; 
        backgroundMusic.volume = 0.5; 

        const playerShotSound = new Audio('https://cdn.pixabay.com/download/audio/2022/03/10/audio_f8319f0956.mp3?filename=gun-gun-shot-6133.mp3'); 
        playerShotSound.volume = 0.3;

        const enemyShotSound = new Audio('https://cdn.pixabay.com/download/audio/2022/03/15/audio_2435555416.mp3?filename=laser-gun-8178.mp3'); 
        enemyShotSound.volume = 0.2;

        const bossMusic = new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3'); 
        bossMusic.loop = true;
        bossMusic.volume = 0.6;

        /**
         * Requests fullscreen mode for the document.
         */
        function toggleFullScreen() {
            const element = document.documentElement; 

            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) { 
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) { 
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { 
                element.msRequestFullscreen();
            }
        }

        /**
         * Updates player stats based on current level.
         */
        function updatePlayerStatsBasedOnLevel() {
            maxHealth = 100 + (playerLevel - 1) * 20; 
            maxOvershieldHealth = maxHealth * 2; // O máximo da sobrevida é o dobro da vida máxima
            bulletDamage = 1 + (playerLevel - 1); 
        }

        /**
         * Initializes the game state for a new game.
         */
        function initializeGame() {
            score = 0;
            playerLevel = 1; 
            bossLevel = 0; 
            nextBossScoreThreshold = 50; 
            currentStageHueRotation = 0; 
            document.documentElement.style.setProperty('--stage-hue-rotation', `${currentStageHueRotation}deg`); 

            updatePlayerStatsBasedOnLevel(); 
            health = maxHealth; // Começa com vida cheia, sem sobrevida
            slantedBulletsActive = false; 
            sideShotsLevel = 0; 

            // Reseta variáveis do escudo
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 
            
            // Reseta variáveis do Boss
            bossRageActive = false;
            lastBossPowerUpDropTime = 0;
            isHeavyEnemyOnScreen = false; 

            scoreValueDisplay.textContent = score; 
            updateHealthBarDisplay(); 
            updatePlayerDamageDisplay(); 
            playerLevelDisplay.textContent = playerLevel; 
            updateBossProgressBar(); 

            // Reinitialize speeds and intervals to adjusted base values
            currentEnemyMovementSpeed = baseEnemyMovementSpeed * 0.8 * 0.7; 
            currentEnemyBulletSpeed = baseEnemyBulletSpeed * 1.4;
            currentObstacleSpawnInterval = baseObstacleSpawnInterval; 
            objectSpawnInterval = 1500; 
            
            currentBossBulletDamage = initialBossBulletDamage;

            clearGameElements(); 
            isBossFightActive = false; 
            
            gameOverScreen.classList.add('hidden');
            startScreen.classList.add('hidden'); 
            stageClearScreen.classList.add('hidden'); 
            pauseScreen.classList.add('hidden'); 
            rankingScreen.classList.add('hidden'); // Esconde a tela de ranking
            nameInputForm.classList.add('hidden'); // Esconde o formulário de nome

            // Recriar e anexar o player
            if (!player || !player.parentNode || player.parentNode !== gameContainer) {
                if (player && player.parentNode) player.parentNode.removeChild(player);
                player = document.createElement('div');
                player.id = 'player';
                player.classList.add('player');
                gameContainer.appendChild(player);
            }

            playerX = gameContainer.offsetWidth / 2 - player.offsetWidth / 2;
            playerY = gameContainer.offsetHeight - player.offsetHeight - 20; 
            player.style.left = `${playerX}px`;
            player.style.bottom = `${20}px`; 

            // Initialize background segments
            backgroundSegments[0].style.top = '0px';
            backgroundSegments[1].style.top = `${-gameContainer.offsetHeight}px`; 
            backgroundSegments[0].classList.remove('rotated-180');
            backgroundSegments[1].classList.add('rotated-180'); 
            
            gameRunning = true;
            gamePaused = false; 
            lastObjectSpawnTime = performance.now(); 
            lastShotTime = performance.now(); 
            lastObstacleSpawnTime = performance.now(); 
            startGameLoop();
            console.log('initializeGame: isBossFightActive =', isBossFightActive); 

            backgroundMusic.play().catch(e => console.log("Error playing music:", e)); 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
        }

        /**
         * Prepares the game for the next stage.
         */
        function startNextStage() {
            isBossFightActive = false; 
            console.log('startNextStage: isBossFightActive set to', isBossFightActive); 
            clearGameElements(); 
            
            health = maxHealth; // Começa o próximo estágio com vida cheia, sem sobrevida
            // Reseta variáveis do escudo
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 

            // Reseta variáveis do Boss
            bossRageActive = false;
            lastBossPowerUpDropTime = 0;
            isHeavyEnemyOnScreen = false; 
            
            updateHealthBarDisplay();
            updatePlayerDamageDisplay();
            playerLevelDisplay.textContent = playerLevel;
            updateBossProgressBar(); 

            currentEnemyMovementSpeed = baseEnemyMovementSpeed * (0.8 + (bossLevel * 0.1)); 
            currentEnemyBulletSpeed = baseEnemyBulletSpeed * (1.4 + (bossLevel * 0.2)); 
            objectSpawnInterval = Math.max(400, 1500 - (bossLevel * 100)); 
            currentObstacleSpawnInterval = Math.max(1000, baseObstacleSpawnInterval - (bossLevel * 200)); 

            currentStageHueRotation = (currentStageHueRotation + stageHueRotationIncrement) % 360;
            document.documentElement.style.setProperty('--stage-hue-rotation', `${currentStageHueRotation}deg`); 

            stageClearScreen.classList.add('hidden'); 
            gameRunning = true;
            gamePaused = false; 
            lastObjectSpawnTime = performance.now(); 
            lastShotTime = performance.now(); 
            lastObstacleSpawnTime = performance.now(); 
            startGameLoop();

            // Recriar e anexar o player
            if (!player || !player.parentNode || player.parentNode !== gameContainer) {
                if (player && player.parentNode) player.parentNode.removeChild(player);
                player = document.createElement('div');
                player.id = 'player';
                player.classList.add('player');
                gameContainer.appendChild(player);
            }
            // Manter a posição do player do estágio anterior ou resetar para o padrão
            playerX = gameContainer.offsetWidth / 2 - player.offsetWidth / 2;
            playerY = gameContainer.offsetHeight - player.offsetHeight - 20;
            updatePlayerPosition();


            backgroundMusic.play().catch(e => console.log("Error playing music:", e)); 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
        }

        /**
         * Clears all game elements (enemies, bullets, collectibles, etc.).
         */
        function clearGameElements() {
            // Remove elementos do DOM e limpa arrays
            for (let i = fallingObjects.length - 1; i >= 0; i--) { // Iterar de trás para frente
                const obj = fallingObjects[i];
                if (obj && obj.parentNode) { // Adicionado: Verificação de nulidade e parentNode
                    obj.parentNode.removeChild(obj);
                }
            }
            fallingObjects = [];

            for (let i = bullets.length - 1; i >= 0; i--) { // Iterar de trás para frente
                const bullet = bullets[i];
                if (bullet && bullet.parentNode) { // Adicionado: Verificação de nulidade e parentNode
                    bullet.parentNode.removeChild(bullet);
                }
            }
            bullets = [];

            for (let i = collectibles.length - 1; i >= 0; i--) { // Iterar de trás para frente
                const col = collectibles[i];
                if (col && col.parentNode) { // Adicionado: Verificação de nulidade e parentNode
                    col.parentNode.removeChild(col);
                }
            }
            collectibles = [];

            for (let i = enemyBullets.length - 1; i >= 0; i--) { // Iterar de trás para frente
                const b = enemyBullets[i];
                if (b && b.parentNode) { // Adicionado: Verificação de nulidade e parentNode
                    b.parentNode.removeChild(b);
                }
            }
            enemyBullets = [];

            for (let i = obstacles.length - 1; i >= 0; i--) { // Iterar de trás para frente
                const o = obstacles[i];
                if (o && o.parentNode) { // Adicionado: Verificação de nulidade e parentNode
                    o.parentNode.removeChild(o);
                }
            }
            obstacles = [];

            if (boss && boss.parentNode) { // Adicionado verificação obj.parentNode
                boss.parentNode.removeChild(boss);
                boss = null;
            }
            const existingBossHealthBarWrapper = document.getElementById('bossHealthBarWrapper');
            if (existingBossHealthBarWrapper && existingBossHealthBarWrapper.parentNode) { // Adicionado verificação obj.parentNode
                existingBossHealthBarWrapper.parentNode.removeChild(existingBossHealthBarWrapper);
            }

            for (let i = bossBullets.length - 1; i >= 0; i--) { // Iterar de trás para frente
                const b = bossBullets[i];
                if (b && b.parentNode) { // Adicionado: Verificação de nulidade e parentNode
                    b.parentNode.removeChild(b);
                }
            }
            bossBullets = [];
            console.log('clearGameElements called. All elements removed and arrays cleared.');
        }

        /**
         * Updates player position.
         */
        function updatePlayerPosition() {
            if (!player) return; // Adicionado: Verificação para evitar erro se player for nulo
            player.style.left = `${playerX}px`;
            player.style.bottom = `${gameContainer.offsetHeight - playerY - player.offsetHeight}px`;
        }

        /**
         * Checks if two rectangles overlap.
         * @param {Object} rect1 - First rectangle {left, top, width, height}.
         * @param {Object} rect2 - Second rectangle {left, top, width, height}.
         * @returns {boolean} True if overlapping, false otherwise.
         */
        function isOverlapping(rect1, rect2) {
            return rect1.left < rect2.left + rect2.width &&
                   rect1.left + rect1.width > rect2.left &&
                   rect1.top < rect2.top + rect2.height &&
                   rect1.top + rect1.height > rect2.top;
        }

        /**
         * Creates a new falling object (enemy) with variable difficulty.
         * @param {DOMHighResTimeStamp} currentTime - The current time.
         * @param {boolean} [isBossSummon=false] - Indicates if the enemy is being summoned by the boss.
         * @param {Object} [bossStats=null] - Contains {health, damage} of the boss if summoned by it.
         */
        function createFallingObject(currentTime, isBossSummon = false, bossStats = null) {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            if (isHeavyEnemyOnScreen && !isBossSummon) {
                console.log("Heavy enemy already on screen (normal spawn attempt), skipping.");
                return;
            }
            if (isBossSummon && isHeavyEnemyOnScreen) {
                console.log("Boss attempted to summon heavy enemy, but one is already on screen, skipping.");
                return;
            }

            const object = document.createElement('div');
            object.classList.add('falling-object');
            
            let selectedEnemyType;
            let isHeavyEnemy = false;
            let spawned = false;
            let maxAttempts = 10;

            let tempLeft, tempTop, tempWidth, tempHeight; 

            if (isBossSummon) {
                selectedEnemyType = heavyEnemyDefinition;
                isHeavyEnemy = true;
                object.classList.add('heavy-enemy');
                object.dataset.movementDirection = (Math.random() < 0.5 ? 1 : -1);
                tempWidth = selectedEnemyType.width * 0.8; 
                tempHeight = selectedEnemyType.height * 0.8; 
                tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                tempTop = 50; 

                object.dataset.hitsRemaining = Math.max(1, Math.round(bossStats.health * 0.10)); 
                object.dataset.initialHits = Math.max(1, Math.round(bossStats.health * 0.10));
                object.dataset.baseBulletDamage = selectedEnemyType.baseBulletDamage; // Usa o dano base do heavy enemy
                object.dataset.isBossSummoned = 'true'; 

                const chosenHueIndex = Math.floor(Math.random() * selectedEnemyType.hueRotations.length);
                selectedEnemyType.hueRotate = selectedEnemyType.hueRotations[chosenHueIndex];

            } else if (bossLevel >= 1 && Math.random() < 0.075) { 
                selectedEnemyType = heavyEnemyDefinition;
                isHeavyEnemy = true;
                object.classList.add('heavy-enemy');
                object.dataset.movementDirection = (Math.random() < 0.5 ? 1 : -1);
                tempWidth = selectedEnemyType.width;
                tempHeight = selectedEnemyType.height;
                tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                tempTop = 50; 

                const chosenHueIndex = Math.floor(Math.random() * selectedEnemyType.hueRotations.length);
                selectedEnemyType.hueRotate = selectedEnemyType.hueRotations[chosenHueIndex];

            } else { 
                tempWidth = 60;
                tempHeight = 60;
                tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                tempTop = -tempHeight;

                let availableEnemyLevels = [];
                for (let j = 0; j < enemyTypes.length; j++) {
                    if (score >= enemyTypes[j].scoreThreshold) {
                        availableEnemyLevels.push(enemyTypes[j]);
                    }
                }

                if (availableEnemyLevels.length === 0) {
                    availableEnemyLevels.push(enemyTypes[0]);
                }

                const enemiesToSpawnFrom = availableEnemyLevels.slice(Math.max(0, availableEnemyLevels.length - 3));
                selectedEnemyType = enemiesToSpawnFrom[Math.floor(Math.random() * enemiesToSpawnFrom.length)];
            }

            for (let i = 0; i < maxAttempts; i++) {
                if (isHeavyEnemy) {
                    tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                } else { 
                    tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth);
                    tempTop = -tempHeight;
                }

                const hypotheticalRect = {
                    left: tempLeft,
                    top: tempTop,
                    width: tempWidth,
                    height: tempHeight
                };

                let overlap = false;
                for (const existingObj of fallingObjects) {
                    const existingRect = {
                        left: parseFloat(existingObj.style.left),
                        top: parseFloat(existingObj.style.top),
                        width: existingObj.offsetWidth,
                        height: existingObj.offsetHeight
                    };
                    const padding = 5;
                    if (isOverlapping(
                        {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                        {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                    )) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    for (const existingObstacle of obstacles) {
                        const existingRect = {
                            left: parseFloat(existingObstacle.style.left),
                            top: parseFloat(existingObstacle.style.top),
                            width: existingObstacle.offsetWidth,
                            height: existingObstacle.offsetHeight
                        };
                        const padding = 5;
                        if (isOverlapping(
                            {left: hypotheticalRect.left - padding, top: hypotheticalRect.top - padding, width: hypotheticalRect.width + padding*2, height: hypotheticalRect.height + padding*2},
                            {left: existingRect.left - padding, top: existingRect.top - padding, width: existingRect.width + padding*2, height: existingRect.height + padding*2}
                        )) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (!overlap) {
                    object.style.left = `${tempLeft}px`;
                    object.style.top = `${tempTop}px`;
                    object.style.width = `${tempWidth}px`;
                    object.style.height = `${tempHeight}px`;
                    spawned = true;
                    break;
                }
            }

            if (!spawned) {
                console.warn("Não foi possível spawnar inimigo sem sobreposição após tentativas.");
                return; 
            }

            if (!isBossSummon) {
                const strengthMultiplier = 1 + (bossLevel * 0.25);
                const additionalHeavyStrength = isHeavyEnemy && Math.random() < 0.1 ? 1.1 : 1;
                object.dataset.hitsRemaining = selectedEnemyType.hits * strengthMultiplier * additionalHeavyStrength;
                object.dataset.initialHits = selectedEnemyType.hits * strengthMultiplier * additionalHeavyStrength;
                object.dataset.baseBulletDamage = selectedEnemyType.baseBulletDamage;
            } 
            object.dataset.hitsRemaining = Math.round(object.dataset.hitsRemaining);
            object.dataset.initialHits = Math.round(object.dataset.initialHits);
            object.dataset.baseBulletDamage = Math.round(object.dataset.baseBulletDamage); 
            
            object.style.backgroundImage = `url('${selectedEnemyType.sprite}')`;
            object.style.backgroundColor = 'transparent';
            object.style.backgroundSize = 'contain';
            object.style.backgroundRepeat = 'no-repeat';
            object.style.backgroundPosition = 'center';
            object.style.filter = `hue-rotate(${selectedEnemyType.hueRotate}deg)`;

            const enemyHealthBarWrapper = document.createElement('div');
            enemyHealthBarWrapper.classList.add('enemy-health-bar-wrapper');
            const enemyHealthBar = document.createElement('div');
            enemyHealthBar.classList.add('enemy-health-bar');
            const enemyHealthFill = document.createElement('div');
            enemyHealthFill.classList.add('enemy-health-fill');
            enemyHealthBar.appendChild(enemyHealthFill);
            enemyHealthBarWrapper.appendChild(enemyHealthBar);
            object.appendChild(enemyHealthBarWrapper);

            object.dataset.hasShot = 'false';
            object.dataset.shootTimer = currentTime + (isHeavyEnemy ? selectedEnemyType.shootInterval : 1000);
            object.dataset.shootType = isHeavyEnemy ? 'straight' : (Math.random() < 0.5 ? 'straight' : 'diagonal');
            object.dataset.isHeavy = isHeavyEnemy;

            gameContainer.appendChild(object);
            fallingObjects.push(object);

            if (isHeavyEnemy) {
                isHeavyEnemyOnScreen = true;
                console.log("Heavy enemy spawned. isHeavyEnemyOnScreen = true");
            }
        }

        /**
         * Cria uma nova bala do jogador.
         */
        function createBullet() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            const bulletBottom = gameContainer.offsetHeight - playerY - player.offsetHeight + 10;
            const bulletWidth = 8; 
            const bulletHeight = 20; 

            const createSingleBullet = (xOffset, initialDx) => {
                const bullet = document.createElement('div');
                bullet.classList.add('bullet');
                bullet.style.left = `${playerX + player.offsetWidth / 2 - bulletWidth / 2 + xOffset}px`;
                bullet.style.bottom = `${bulletBottom}px`; 
                
                let dx = initialDx;
                bullet.dataset.dx = dx;
                bullet.dataset.dy = bulletSpeed; 
                gameContainer.appendChild(bullet);
                bullets.push(bullet);
                playerShotSound.currentTime = 0; 
                playerShotSound.play().catch(e => console.log("Erro ao tocar som de tiro do player:", e));
            };

            createSingleBullet(0, 0); 

            if (sideShotsLevel >= 1) { 
                createSingleBullet(-15, 0); 
                createSingleBullet(15, 0);  
            }
            if (sideShotsLevel >= 2) { 
                createSingleBullet(-30, 0); 
                createSingleBullet(30, 0);  
            }

            if (slantedBulletsActive) { 
                createSingleBullet(-20, -2); 
                createSingleBullet(20, 2);  
            }
        }

        /**
         * Converte um valor hexadecimal de cor para RGBA.
         * @param {string} hex - A cor em formato hexadecimal (ex: '#RRGGBB' ou '#RGB').
         * @param {number} alpha - O valor do canal alfa (0 a 1).
         * @returns {string} A cor em formato RGBA (ex: 'rgba(255, 0, 0, 0.7)').
         */
        function hexToRgba(hex, alpha = 1) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            }
            else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        /**
         * Cria um coletável (power-up ou debuff).
         * @param {number} x - Posição X para spawnar o coletável.
         * @param {number} y - Posição Y para spawnar o coletável.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         * @param {string} [forcedType=null] - Tipo de power-up a ser forçado (ex: 'health_up').
         */
        function createCollectible(x, y, currentTime, forcedType = null) {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            const collectible = document.createElement('div');
            const powerUpSize = 30 * 1.2; 
            collectible.style.width = `${powerUpSize}px`;
            collectible.style.height = `${powerUpSize}px`;
            collectible.style.left = `${x}px`;
            collectible.style.top = `${y}px`; 
            collectible.dataset.spawnTime = currentTime; 
            collectible.dataset.isStationary = 'true'; 

            let selectedCollectibleType;

            if (forcedType) { 
                selectedCollectibleType = [...powerUpTypes, healthPowerUpType, debuffType].find(type => type.type === forcedType);
                if (!selectedCollectibleType) { 
                    selectedCollectibleType = powerUpTypes[0]; 
                }
            } else { 
                const healthDropProbability = 0.30; 
                const debuffDropProbability = 0.10; 
                const rand = Math.random();

                if (rand < healthDropProbability) { 
                    selectedCollectibleType = healthPowerUpType;
                } else if (rand < healthDropProbability + debuffDropProbability) { 
                    selectedCollectibleType = debuffType;
                } else { 
                    const otherPowerUps = powerUpTypes.filter(type => type.type !== 'health_up' && type.type !== 'damage_down' && type.type !== 'shield'); 
                    selectedCollectibleType = otherPowerUps[Math.floor(Math.random() * otherPowerUps.length)];
                }
            }
            
            collectible.dataset.type = selectedCollectibleType.type; 
            if (selectedCollectibleType.type === 'debuff') {
                collectible.classList.add('debuff');
            } else {
                collectible.classList.add('power-up');
            }
            collectible.style.backgroundImage = `url('${selectedCollectibleType.sprite}')`; 
            collectible.style.backgroundColor = 'transparent'; 
            collectible.style.backgroundSize = 'contain';
            collectible.style.backgroundRepeat = 'no-repeat';
            collectible.style.backgroundPosition = 'center';
            collectible.innerHTML = ''; 

            // Aplica o brilho neon e saturação
            collectible.style.setProperty('--neon-color', selectedCollectibleType.color);
            // Removido: hue-rotate(${-currentStageHueRotation}deg) para não ser afetado pelo filtro do estágio
            collectible.style.filter = `saturate(200%) brightness(150%)`; 

            gameContainer.appendChild(collectible);
            collectibles.push(collectible);
        }

        /**
         * Cria um obstáculo.
         */
        function createObstacle() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            const obstacle = document.createElement('div');
            obstacle.classList.add('obstacle');
            
            const baseSize = 45;
            let tempWidth = baseSize + Math.random() * baseSize; 
            let tempHeight = tempWidth; 
            let spawned = false;
            let maxAttempts = 10;

            for (let i = 0; i < maxAttempts; i++) {
                let tempLeft = Math.random() * (gameContainer.offsetWidth - tempWidth); 
                let tempTop = -tempHeight; 

                const hypotheticalRect = {
                    left: tempLeft,
                    top: tempTop,
                    width: tempWidth,
                    height: tempHeight
                };

                let overlap = false;
                for (const existingObstacle of obstacles) {
                    const existingRect = {
                        left: parseFloat(existingObstacle.style.left),
                        top: parseFloat(existingObstacle.style.top),
                        width: existingObstacle.offsetWidth,
                        height: existingObstacle.offsetHeight
                    };
                    if (isOverlapping(hypotheticalRect, existingRect)) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    for (const existingObj of fallingObjects) {
                        const existingRect = {
                            left: parseFloat(existingObj.style.left),
                            top: parseFloat(existingObj.style.top),
                            width: existingObj.offsetWidth,
                            height: existingObj.offsetHeight
                        };
                        if (isOverlapping(hypotheticalRect, existingRect)) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (!overlap) {
                    obstacle.style.left = `${tempLeft}px`;
                    obstacle.style.top = `${tempTop}px`;
                    obstacle.style.width = `${tempWidth}px`;
                    obstacle.style.height = `${tempHeight}px`;
                    spawned = true;
                    break;
                }
            }

            if (!spawned) {
                console.warn("Não foi possível spawnar obstáculo sem sobreposição após tentativas.");
                return; 
            }

            const randomHue = Math.floor(Math.random() * 360);
            obstacle.style.filter = `hue-rotate(${randomHue}deg) var(--stage-hue-rotation)`; /* APLICADO AQUI */

            gameContainer.appendChild(obstacle);
            obstacles.push(obstacle);
        }

        /**
         * Cria um projétil de um inimigo normal ou pesado.
         * @param {HTMLElement} enemyObject - O elemento DOM do inimigo que está atirando.
         * @param {boolean} [isHeavyBullet=false] - Indica se é uma bala de inimigo pesado.
         */
        function createEnemyBullet(enemyObject, isHeavyBullet = false) {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            const enemyBullet = document.createElement('div');
            enemyBullet.classList.add('enemy-bullet');
            if (isHeavyBullet) {
                enemyBullet.classList.add('heavy-enemy-bullet'); 
                enemyBullet.classList.add('heavy-enemy-bullet-color'); 
            } else {
                enemyBullet.classList.add('enemy-bullet-color'); 
            }
            let enemyLeft = parseFloat(enemyObject.style.left);
            if (isNaN(enemyLeft)) { enemyLeft = 0; enemyObject.style.left = `${enemyLeft}px`; }
            let enemyTop = parseFloat(enemyObject.style.top);
            if (isNaN(enemyTop)) { enemyTop = -60; enemyObject.style.top = `${enemyTop}px`; }

            const bulletSize = isHeavyBullet ? 24 : 12; /* AUMENTADO PARA 24px */
            enemyBullet.style.left = `${enemyLeft + (enemyObject.offsetWidth / 2) - (bulletSize / 2)}px`;
            enemyBullet.style.top = `${enemyTop + enemyObject.offsetHeight}px`;
            
            let dx = 0;
            let dy = isHeavyBullet ? heavyEnemyDefinition.speed * 2 : currentEnemyBulletSpeed; 

            if (!isHeavyBullet && enemyObject.dataset.shootType === 'diagonal') { 
                dx = (Math.random() < 0.5 ? -1 : 1) * (currentEnemyBulletSpeed * 0.5); 
                dy = currentEnemyBulletSpeed * 0.866; 
            }
            enemyBullet.dataset.dx = dx;
            enemyBullet.dataset.dy = dy;
            enemyBullet.dataset.isHeavyBullet = isHeavyBullet; 

            gameContainer.appendChild(enemyBullet);
            enemyBullets.push(enemyBullet);
            enemyShotSound.currentTime = 0; 
            enemyShotSound.play().catch(e => console.log("Erro ao tocar som de tiro do inimigo:", e));
        }

        /**
         * Atualiza a posição dos objetos em caída e seus estados.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateFallingObjects(currentTime) {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                for (let i = fallingObjects.length - 1; i >= 0; i--) { // Iterar de trás para frente
                    const object = fallingObjects[i];
                    if (!object || !object.parentNode) { // Verificação de nulidade e parentNode
                        fallingObjects.splice(i, 1);
                        continue;
                    }

                    let currentTop = parseFloat(object.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; object.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(object.style.left); 

                    if (object.dataset.isHeavy === 'true') {
                        let direction = parseFloat(object.dataset.movementDirection);
                        currentLeft += direction * heavyEnemyDefinition.speed; 

                        if (currentLeft <= 0 || currentLeft + object.offsetWidth >= gameContainer.offsetWidth) {
                            direction *= -1;
                            object.dataset.movementDirection = direction;
                            currentLeft = Math.max(0, Math.min(currentLeft, gameContainer.offsetWidth - object.offsetWidth)); 
                        }
                        object.style.left = `${currentLeft}px`;

                        if (currentTime >= parseFloat(object.dataset.shootTimer)) {
                            createEnemyBullet(object, true); 
                            object.dataset.shootTimer = currentTime + heavyEnemyDefinition.shootInterval; 
                        }
                    } else {
                        object.style.top = `${currentTop + currentEnemyMovementSpeed}px`;

                        if (object.dataset.hasShot === 'false' && currentTime >= parseFloat(object.dataset.shootTimer)) {
                            createEnemyBullet(object, false); 
                            object.dataset.hasShot = 'true';
                        }

                        if (currentTop > gameContainer.offsetHeight) {
                            if (object.parentNode) object.parentNode.removeChild(object); 
                            fallingObjects.splice(i, 1);
                            continue;
                        }
                    }

                    const enemyHealthBarWrapper = object.querySelector('.enemy-health-bar-wrapper');
                    if (enemyHealthBarWrapper) {
                        if (object.dataset.isHeavy === 'true') {
                            enemyHealthBarWrapper.style.top = `${-20}px`; 
                        } else {
                            enemyHealthBarWrapper.style.top = `${-15}px`;
                        }
                    }
                }
            } catch (error) {
                console.error("Erro em updateFallingObjects:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Atualiza a posição das balas do jogador e verifica colisões com objetos em caída.
         */
        function updateBullets() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                for (let i = bullets.length - 1; i >= 0; i--) { // Iterar de trás para frente
                    const bullet = bullets[i];
                    if (!bullet || !bullet.parentNode) { // Verificação de nulidade e parentNode
                        bullets.splice(i, 1);
                        continue; 
                    }

                    let currentBottom = parseFloat(bullet.style.bottom);
                    if (isNaN(currentBottom)) { currentBottom = 0; bullet.style.bottom = `${currentBottom}px`; }
                    let currentLeft = parseFloat(bullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; bullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(bullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(bullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentBottom += dy;
                    currentLeft += dx;

                    bullet.style.bottom = `${currentBottom}px`;
                    bullet.style.left = `${currentLeft}px`;

                    if (currentBottom > gameContainer.offsetHeight || currentBottom < -bullet.offsetHeight) {
                        if (bullet.parentNode) bullet.parentNode.removeChild(bullet); 
                        bullets.splice(i, 1);
                        continue; 
                    }

                    if (isBossFightActive && boss) {
                        const bulletRect = bullet.getBoundingClientRect();
                        const bossRect = boss.getBoundingClientRect();

                        if (
                            bulletRect.bottom > bossRect.top &&
                            bulletRect.top < bossRect.bottom &&
                            bulletRect.right > bossRect.left &&
                            bulletRect.left < bossRect.right
                        ) {
                            if (bullet.parentNode) bullet.parentNode.removeChild(bullet); 
                            bullets.splice(i, 1);
                            
                            bossHealth = Math.max(0, bossHealth - bulletDamage);
                            updateBossHealthBar();
                            if (bossHealth <= 0) {
                                handleBossDefeated(); 
                                return; 
                            }
                            continue; 
                        }
                    }

                    const bulletRect = bullet.getBoundingClientRect();
                    for (let j = fallingObjects.length - 1; j >= 0; j--) { // Iterar de trás para frente
                        const object = fallingObjects[j];
                        if (!object || !object.parentNode) { // Verificação de nulidade e parentNode
                            fallingObjects.splice(j, 1);
                            continue;
                        }
                        const objectRect = object.getBoundingClientRect();

                        if (
                            bulletRect.bottom > objectRect.top &&
                            bulletRect.top < objectRect.bottom &&
                            bulletRect.right > objectRect.left &&
                            bulletRect.left < objectRect.right
                        ) {
                            if (bullet.parentNode) bullet.parentNode.removeChild(bullet); 
                            bullets.splice(i, 1);
                            
                            let hitsRemaining = parseInt(object.dataset.hitsRemaining);
                            hitsRemaining -= bulletDamage; 
                            object.dataset.hitsRemaining = hitsRemaining;

                            const enemyHealthFill = object.querySelector('.enemy-health-fill');
                            if (enemyHealthFill) {
                                const healthPercentage = (hitsRemaining / parseInt(object.dataset.initialHits)) * 100;
                                enemyHealthFill.style.width = `${healthPercentage}%`;
                                if (healthPercentage > 60) {
                                    enemyHealthFill.style.backgroundColor = '#48bb78'; 
                                } else if (healthPercentage > 30) {
                                    enemyHealthFill.style.backgroundColor = '#f6ad55'; 
                                } else {
                                    enemyHealthFill.style.backgroundColor = '#e53e3e'; 
                                }
                            }

                            if (hitsRemaining > 0) {
                                object.classList.add('enemy-hit-effect');
                                setTimeout(() => {
                                    object.classList.remove('enemy-hit-effect');
                                }, 100); 
                            } else {
                                if (object.parentNode) object.parentNode.removeChild(object); 
                                fallingObjects.splice(j, 1);
                                
                                if (object.dataset.isHeavy === 'true') {
                                    isHeavyEnemyOnScreen = false; 
                                    console.log("Heavy enemy defeated. isHeavyEnemyOnScreen = false");
                                    score += 10; 
                                    const gameRect = gameContainer.getBoundingClientRect();
                                    const positivePowerUps = powerUpTypes.filter(type => type.type !== 'damage_down');
                                    const forcedPowerUp = positivePowerUps[Math.floor(Math.random() * positivePowerUps.length)];
                                    createCollectible(objectRect.left - gameRect.left, objectRect.top - gameRect.top, performance.now(), forcedPowerUp.type);
                                } else {
                                    score++; 
                                    if (Math.random() < collectibleDropChance) { 
                                        const gameRect = gameContainer.getBoundingClientRect(); 
                                        createCollectible(objectRect.left - gameRect.left, objectRect.top - gameRect.top, performance.now()); 
                                    }
                                }
                                scoreValueDisplay.textContent = score; 
                                increaseDifficulty(); 
                            }
                            if (bullet.parentNode === null) break; 
                        }
                    }
                }
            } catch (error) {
                console.error("Erro em updateBullets:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Atualiza a posição dos coletáveis e verifica colisões com o jogador.
         */
        function updateCollectibles(currentTime) {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                for (let i = collectibles.length - 1; i >= 0; i--) { // Iterar de trás para frente
                    const collectible = collectibles[i];
                    if (!collectible || !collectible.parentNode) { // Verificação de nulidade e parentNode
                        collectibles.splice(i, 1);
                        continue;
                    }

                    let currentTop = parseFloat(collectible.style.top);
                    if (isNaN(currentTop)) {
                        currentTop = 0; 
                        collectible.style.top = `${currentTop}px`;
                    }

                    if (collectible.dataset.isStationary === 'true') {
                        if (currentTime - parseFloat(collectible.dataset.spawnTime) > collectibleStationaryDuration) {
                            collectible.dataset.isStationary = 'false'; 
                        }
                    } else {
                        collectible.style.top = `${currentTop + currentEnemyMovementSpeed}px`;
                    }

                    if (currentTop > gameContainer.offsetHeight) {
                        if (collectible.parentNode) collectible.parentNode.removeChild(collectible); 
                        collectibles.splice(i, 1);
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const collectibleRect = collectible.getBoundingClientRect();

                    if (
                        collectibleRect.bottom > playerRect.top &&
                        collectibleRect.top < playerRect.bottom &&
                        collectibleRect.right > playerRect.left &&
                        collectibleRect.left < playerRect.right
                    ) {
                        if (collectible.classList.contains('power-up')) {
                            collectPowerUp(collectible);
                        } else if (collectible.classList.contains('debuff')) {
                            collectDebuff(collectible);
                        }
                        if (collectible.parentNode) collectible.parentNode.removeChild(collectible); 
                        collectibles.splice(i, 1);
                        return; 
                    }
                }
            } catch (error) {
                console.error("Erro em updateCollectibles:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Atualiza a posição dos projéteis inimigos e verifica colisões com o jogador.
         */
        function updateEnemyBullets() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                for (let i = enemyBullets.length - 1; i >= 0; i--) { // Iterar de trás para frente
                    const eBullet = enemyBullets[i];
                    if (!eBullet || !eBullet.parentNode) { // Verificação de nulidade e parentNode
                        enemyBullets.splice(i, 1);
                        continue;
                    }

                    let currentTop = parseFloat(eBullet.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; eBullet.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(eBullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; eBullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(eBullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(eBullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentTop += dy;
                    currentLeft += dx;

                    eBullet.style.top = `${currentTop}px`;
                    eBullet.style.left = `${currentLeft}px`;

                    if (currentTop > gameContainer.offsetHeight || currentLeft < -eBullet.offsetWidth || currentLeft > gameContainer.offsetWidth) {
                        if (eBullet.parentNode) eBullet.parentNode.removeChild(eBullet); 
                        enemyBullets.splice(i, 1);
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const eBulletRect = eBullet.getBoundingClientRect();

                    if (
                        eBulletRect.bottom > playerRect.top &&
                        eBulletRect.top < playerRect.bottom &&
                        eBulletRect.right > playerRect.left &&
                        eBulletRect.left < playerRect.right
                    ) {
                        if (eBullet.parentNode) eBullet.parentNode.removeChild(eBullet); 
                        enemyBullets.splice(i, 1);

                        // Correção: Pega o dano base da bala do inimigo (se for heavy, usa o baseBulletDamage do dataset)
                        let damageToApply;
                        if (eBullet.dataset.isHeavyBullet === 'true') {
                            // Pega o dano base diretamente do dataset da bala do heavy enemy
                            damageToApply = parseFloat(eBullet.dataset.baseBulletDamage);
                            console.log("Heavy enemy bullet hit! Base Damage from dataset:", eBullet.dataset.baseBulletDamage, "Parsed:", damageToApply); // DEBUG
                        } else {
                            // Usa o dano base para inimigos normais
                            damageToApply = baseEnemyBulletDamage;
                            console.log("Normal enemy bullet hit! Base Damage:", damageToApply); // DEBUG
                        }
                        // Aplica o escalonamento de nível do boss ao dano
                        damageToApply *= (1 + bossLevel * 0.10);

                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateEnemyBullets. Defaulting to 0.");
                            damageToApply = 0;
                        }
                        console.log("Final Damage to Apply:", damageToApply); // DEBUG
                        
                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); // Aplica o dano restante na vida/sobrevida
                            }
                        } else { // Sem escudo, aplica na vida/sobrevida
                            health = Math.max(0, health - damageToApply);
                        }
                        
                        updateHealthBarDisplay();
                        console.log("Atingido por inimigo! Vida restante: " + health + ", Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect'); 
                        }, 150); 
                    }
                }
            } catch (error) {
                console.error("Erro em updateEnemyBullets:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Atualiza a posição dos obstáculos e verifica colisões com o jogador.
         */
        function updateObstacles() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                for (let i = obstacles.length - 1; i >= 0; i--) { // Iterar de trás para frente
                    const obstacle = obstacles[i];
                    if (!obstacle || !obstacle.parentNode) { // Verificação de nulidade e parentNode
                        obstacles.splice(i, 1);
                        continue;
                    }

                    let currentTop = parseFloat(obstacle.style.top);
                    if (isNaN(currentTop)) {
                        currentTop = -45; 
                        obstacle.style.top = `${currentTop}px`; 
                    }
                    obstacle.style.top = `${currentTop + currentEnemyMovementSpeed}px`; 

                    if (currentTop > gameContainer.offsetHeight) {
                        if (obstacle.parentNode) obstacle.parentNode.removeChild(obstacle); 
                        obstacles.splice(i, 1);
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const obstacleRect = obstacle.getBoundingClientRect();

                    if (
                        obstacleRect.bottom > playerRect.top &&
                        obstacleRect.top < playerRect.bottom &&
                        obstacleRect.right > playerRect.left &&
                        obstacleRect.left < playerRect.right
                    ) {
                        if (obstacle.parentNode) obstacle.parentNode.removeChild(obstacle); 
                        obstacles.splice(i, 1);

                        let damageToApply = obstacleDamage; 
                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateObstacles. Defaulting to 0.");
                            damageToApply = 0;
                        }

                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); // Aplica o dano restante na vida/sobrevida
                            }
                        } else { // Sem escudo, aplica na vida/sobrevida
                            health = Math.max(0, health - damageToApply);
                        }

                        updateHealthBarDisplay();
                        console.log("Atingido por obstáculo! Vida restante: " + health + ", Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect'); 
                        }, 150); 
                    }
                }
            } catch (error) {
                console.error("Erro em updateObstacles:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Aumenta a dificuldade do jogo.
         */
        function increaseDifficulty() {
            if (score >= nextBossScoreThreshold && !isBossFightActive) {
                startBossFight(); 
            }
        }

        /**
         * Função para coletar um power-up.
         * @param {HTMLElement} powerUp - O elemento DOM do power-up coletado.
         */
        function collectPowerUp(powerUp) {
            const type = powerUp.dataset.type;
            console.log(`Power-up coletado: ${type}`); 

            if (type === 'damage_1') {
                bulletDamage = Math.max(1, bulletDamage + 1); 
                console.log("Power-up de dano +1! Dano atual: " + bulletDamage);
            } else if (type === 'side_bullets') {
                sideShotsLevel = Math.min(2, sideShotsLevel + 1); 
                console.log("Power-up de tiros laterais ativado! Nível: " + sideShotsLevel);
            } else if (type === 'health_up') {
                // Ao coletar vida, sempre aumenta 'health' até o limite de maxOvershieldHealth
                health = Math.min(maxOvershieldHealth, health + healthPowerUpType.healthIncrease);
                console.log("Power-up de vida coletado! Vida atual: " + health);
            } else if (type === 'shield') { 
                if (!shieldActive) { 
                    // Se o escudo não estava ativo, ativa e preenche
                    shieldHealth = maxShieldHealth; 
                    shieldActive = true; 
                    player.classList.add('player-shield-active'); 
                } else {
                    // Se o escudo já está ativo, apenas recarrega
                    shieldHealth = maxShieldHealth;
                }
                console.log("Power-up de escudo coletado! Vida do escudo: " + shieldHealth);
            }
            updatePlayerDamageDisplay();
            updateHealthBarDisplay(); 
        }

        /**
         * Função para coletar um debuff.
         * @param {HTMLElement} debuff - O elemento DOM do debuff coletado.
         */
        function collectDebuff(debuff) {
            const type = debuff.dataset.type;
            console.log(`Debuff coletado: ${type}`); 

            if (type === 'damage_down') {
                bulletDamage = Math.max(1, bulletDamage - 1); 
                sideShotsLevel = Math.max(0, sideShotsLevel - 1); 
                slantedBulletsActive = false; 
                console.log("Debuff de dano -1! Dano atual: " + bulletDamage + ". Tiros laterais Nível: " + sideShotsLevel); 
            }
            updatePlayerDamageDisplay();
        }

        /**
         * Desativa o escudo do jogador.
         */
        function deactivateShield() {
            shieldActive = false;
            shieldHealth = 0;
            player.classList.remove('player-shield-active'); 
            
            // A variável 'health' já contém o valor correto após o dano ter sido aplicado a ela.
            health = Math.max(0, health); // Garante que a vida não fique negativa
            
            console.log("Escudo desativado! Vida do jogador: " + health);
            updateHealthBarDisplay(); 
        }

        /**
         * Atualiza a exibição de dano do jogador (na barra de status).
         */
        function updatePlayerDamageDisplay() {
            if (playerDamageDisplay) {
                let damageText = `${bulletDamage}`;
                if (slantedBulletsActive) damageText += ` (//)`;
                if (sideShotsLevel > 0) damageText += ` (S${sideShotsLevel})`; 
                
                playerDamageDisplay.textContent = damageText;
            }
        }

        /**
         * Atualiza a barra de vida do jogador (agora com suporte a escudo e sobrevida).
         */
        function updateHealthBarDisplay() {
            if (healthFill && shieldHealthFill && overshieldFill) { 
                // A barra de vida do jogador (e sobrevida) está sempre visível
                // A barra de escudo é que alterna visibilidade
                if (shieldActive) {
                    shieldHealthBar.classList.remove('hidden');
                    const shieldPercentage = (shieldHealth / maxShieldHealth) * 100;
                    shieldHealthFill.style.height = `${shieldPercentage}%`; 
                    shieldHealthText.textContent = `${Math.round(shieldHealth)} / ${maxShieldHealth}`;
                } else {
                    shieldHealthBar.classList.add('hidden');
                }

                // Lógica para a barra de vida principal (incluindo sobrevida)
                if (health > maxHealth) {
                    const baseHealthPercentage = 100; // Vida base sempre cheia (100%)
                    const overshieldAmount = health - maxHealth;
                    // Calcula a porcentagem da sobrevida em relação ao total de sobrevida possível
                    const overshieldMaxPossible = maxOvershieldHealth - maxHealth; 
                    const overshieldPercentage = (overshieldAmount / overshieldMaxPossible) * 100;

                    healthFill.style.backgroundColor = '#48bb78'; /* Verde para vida base cheia */
                    healthFill.style.height = `${baseHealthPercentage}%`; 
                    overshieldFill.style.height = `${overshieldPercentage}%`; // Barra de sobrevida sobe
                    playerHealthText.textContent = `${Math.round(health)} / ${maxOvershieldHealth} (Sobrevida)`;
                } else {
                    // Lógica para vida normal (sem sobrevida)
                    overshieldFill.style.height = '0%'; // Garante que a sobrevida esteja oculta
                    const healthPercentage = (health / maxHealth) * 100;
                    healthFill.style.height = `${healthPercentage}%`; 
                    if (healthPercentage > 60) {
                        healthFill.style.backgroundColor = '#48bb78'; 
                    } else if (healthPercentage > 30) {
                        healthFill.style.backgroundColor = '#f6ad55'; 
                    } else {
                        healthFill.style.backgroundColor = '#e53e3e'; 
                    }
                    playerHealthText.textContent = `${Math.round(health)} / ${maxHealth}`; 
                }
            }
        }

        /**
         * Atualiza a barra de progresso do Boss.
         */
        function updateBossProgressBar() {
            const progress = Math.min(score, nextBossScoreThreshold);
            const progressPercentage = (progress / nextBossScoreThreshold) * 100;
            bossProgressFill.style.width = `${progressPercentage}%`;
            bossProgressText.textContent = `${score} / ${nextBossScoreThreshold}`;
        }

        /**
         * Inicia a batalha contra o boss.
         */
        function startBossFight() {
            console.log('startBossFight: Setting isBossFightActive = true'); 
            isBossFightActive = true;
            clearGameElements(); 
            
            bossHealth = initialBossHealth * Math.pow(2, bossLevel); 
            currentBossBulletDamage = initialBossBulletDamage * (1 + bossLevel * 0.10); 
            bossRageThreshold = bossHealth * 0.35; 
            bossRageActive = false; 
            lastBossPowerUpDropTime = performance.now(); 

            console.log(`Boss Level: ${bossLevel}, Boss Health: ${bossHealth}, Boss Bullet Damage: ${currentBossBulletDamage}, Rage Threshold: ${bossRageThreshold}`); 

            createBoss();
            lastBossShotTime = performance.now(); 

            backgroundMusic.pause(); 
            backgroundMusic.currentTime = 0; 
            bossMusic.play().catch(e => console.log("Erro ao tocar música do boss:", e)); 
        }

        /**
         * Cria o elemento do boss.
         */
        function createBoss() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            boss = document.createElement('div');
            boss.classList.add('boss');
            boss.style.left = `${(gameContainer.offsetWidth / 2) - (100 / 2)}px`; 
            boss.style.top = '50px'; 
            bossMovementDirection = Math.random() < 0.5 ? 1 : -1; 
            const bossHue = bossHueRotations[bossLevel % bossHueRotations.length];
            boss.style.filter = `hue-rotate(${bossHue}deg)`; 
            gameContainer.appendChild(boss);

            const bossHealthBarWrapper = document.createElement('div');
            bossHealthBarWrapper.id = 'bossHealthBarWrapper'; 
            gameContainer.appendChild(bossHealthBarWrapper); // Adicionar o wrapper antes de tentar adicionar coisas a ele

            bossHealthBarWrapper.classList.add('boss-health-bar-wrapper'); // Adiciona classe depois que o elemento existe no DOM

            const healthBar = document.createElement('div');
            healthBar.classList.add('boss-health-bar');
            bossHealthBarWrapper.appendChild(healthBar);

            const healthFillBoss = document.createElement('div'); 
            healthFillBoss.classList.add('boss-health-fill');
            healthBar.appendChild(healthFillBoss);

            const bossHealthText = document.createElement('span'); 
            bossHealthText.classList.add('boss-health-text');
            healthBar.appendChild(bossHealthText); 

            updateBossHealthBar(); 
        }

        /**
         * Atualiza a barra de vida do boss.
         */
        function updateBossHealthBar() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            if (boss) {
                const bossHealthBarWrapper = document.getElementById('bossHealthBarWrapper');
                if (bossHealthBarWrapper) {
                    let bossLeft = parseFloat(boss.style.left);
                    if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (100 / 2); boss.style.left = `${bossLeft}px`; }
                    let bossTop = parseFloat(boss.style.top);
                    if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

                    bossHealthBarWrapper.style.left = `${bossLeft}px`;
                    bossHealthBarWrapper.style.top = `${bossTop + boss.offsetHeight + 5}px`; 
                }

                const healthFillBoss = bossHealthBarWrapper.querySelector('.boss-health-fill');
                const bossHealthText = bossHealthBarWrapper.querySelector('.boss-health-text');

                const currentMaxBossHealth = initialBossHealth * Math.pow(2, bossLevel); 
                const healthPercentage = (bossHealth / currentMaxBossHealth) * 100;
                healthFillBoss.style.width = `${healthPercentage}%`; 
                
                if (healthPercentage > 60) {
                    healthFillBoss.style.backgroundColor = '#48bb78'; 
                } else if (healthPercentage > 30) {
                    healthFillBoss.style.backgroundColor = '#f6ad55'; 
                } else {
                    healthFillBoss.style.backgroundColor = '#e53e3e'; 
                }
                bossHealthText.textContent = `${Math.round(bossHealth)} / ${Math.round(currentMaxBossHealth)}`; 
            }
        }

        /**
         * Atualiza a lógica do boss (movimento e tiro).
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateBoss(currentTime) {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                if (!boss) {
                    console.log("updateBoss: Boss object is null, cannot update."); 
                    return;
                }
                console.log("updateBoss: Executing Boss movement and shoot logic. Boss.style.left:", boss.style.left, "Boss.style.top:", boss.style.top, "Boss Health:", bossHealth);
                console.log("updateBoss: bossMovementDirection:", bossMovementDirection, "bossMovementSpeed:", bossMovementSpeed); 

                let bossX = parseFloat(boss.style.left);
                if (isNaN(bossX)) { 
                    bossX = (gameContainer.offsetWidth / 2) - (100 / 2);
                    boss.style.left = `${bossX}px`; 
                    console.log("updateBoss: bossX was NaN, reset to:", bossX); 
                }

                let newBossX = bossX + bossMovementDirection * bossMovementSpeed; 
                console.log("updateBoss: old bossX:", bossX, "newBossX calculated:", newBossX); 

                if (newBossX + boss.offsetWidth + bossPadding > gameContainer.offsetWidth) {
                    newBossX = gameContainer.offsetWidth - boss.offsetWidth - bossPadding;
                    bossMovementDirection *= -1; 
                    console.log("updateBoss: Hit right boundary, newBossX:", newBossX, "new bossMovementDirection:", bossMovementDirection); 
                } else if (newBossX < bossPadding) {
                    newBossX = bossPadding;
                    bossMovementDirection *= -1; 
                    console.log("updateBoss: Hit left boundary, newBossX:", newBossX, "new bossMovementDirection:", bossMovementDirection); 
                }
                boss.style.left = `${newBossX}px`; 
                console.log("updateBoss: boss.style.left updated to:", boss.style.left); 
                console.log("updateBoss: boss.getBoundingClientRect().left:", boss.getBoundingClientRect().left); 

                updateBossHealthBar(); 

                if (bossHealth <= bossRageThreshold && !bossRageActive) {
                    bossRageActive = true;
                    boss.style.filter = `hue-rotate(0deg) saturate(200%) brightness(1.2)`; 
                    currentBossBulletDamage *= 1.05; 
                    console.log("BOSS ENTROU EM MODO DE RAIVA! Dano aumentado.");
                }

                if (currentTime - lastBossShotTime > bossShootInterval) {
                    if (bossRageActive && Math.random() < 0.30) { 
                        createShotgunBossBullets();
                    } else {
                        const attackTypes = [createSingleBossBullet, createFanBossBullets, createRicochetBossBullet];
                        const selectedAttack = attackTypes[Math.floor(Math.random() * attackTypes.length)];
                        selectedAttack();
                    }
                    lastBossShotTime = currentTime;

                    if (bossLevel >= 0 && !isHeavyEnemyOnScreen && Math.random() < 0.20) { 
                        console.log("Boss attempting to summon heavy enemy...");
                        createFallingObject(currentTime, true, {health: bossHealth, damage: currentBossBulletDamage});
                    }
                }
            } catch (error) {
                console.error("Erro em updateBoss:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Cria uma única bala do boss.
         */
        function createSingleBossBullet() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            bossBullet.style.left = `${bossLeft + (boss.offsetWidth / 2) - (15 / 2)}px`;
            bossBullet.style.top = `${bossTop + boss.offsetHeight}px`;
            bossBullet.dataset.dx = 0; 
            bossBullet.dataset.dy = currentEnemyBulletSpeed; 
            gameContainer.appendChild(bossBullet);
            bossBullets.push(bossBullet);
        }

        /**
         * Cria balas do boss em leque.
         */
        function createFanBossBullets() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            const startX = bossLeft + boss.offsetWidth / 2;
            const startY = bossTop + boss.offsetHeight;
            const spreadAngle = Math.PI / 6; 
            const numBullets = 3;
            const baseSpeed = currentEnemyBulletSpeed * 0.5; // REDUZIDO EM 50%

            for (let i = 0; i < numBullets; i++) {
                const angleOffset = (i - (numBullets - 1) / 2) * spreadAngle / (numBullets - 1);
                const angle = Math.PI / 2 + angleOffset; 

                const dx = Math.cos(angle) * baseSpeed;
                const dy = Math.sin(angle) * baseSpeed;

                const bossBullet = document.createElement('div');
                bossBullet.classList.add('boss-bullet');
                bossBullet.style.left = `${startX - (15 / 2)}px`;
                bossBullet.style.top = `${startY}px`;
                bossBullet.dataset.dx = dx;
                bossBullet.dataset.dy = dy;
                gameContainer.appendChild(bossBullet);
                bossBullets.push(bossBullet);
            }
        }

        /**
         * Cria uma bala ricochete do boss.
         */
        function createRicochetBossBullet() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            const bossBullet = document.createElement('div');
            bossBullet.classList.add('boss-bullet');
            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            bossBullet.style.left = `${bossLeft + (boss.offsetWidth / 2) - (15 / 2)}px`;
            bossBullet.style.top = `${bossTop + boss.offsetHeight}px`;
            
            bossBullet.dataset.dx = (Math.random() > 0.5 ? 1 : -1) * (currentEnemyBulletSpeed * 0.75); // REDUZIDO EM 50%
            bossBullet.dataset.dy = currentEnemyBulletSpeed * 0.5; // REDUZIDO EM 50%
            gameContainer.appendChild(bossBullet);
            bossBullets.push(bossBullet);
        }

        /**
         * Cria 10 balas do boss em todas as direções (ataque "shotgun").
         */
        function createShotgunBossBullets() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar spawn se o jogo não estiver rodando

            let bossLeft = parseFloat(boss.style.left);
            if (isNaN(bossLeft)) { bossLeft = (gameContainer.offsetWidth / 2) - (15 / 2); boss.style.left = `${bossLeft}px`; }
            let bossTop = parseFloat(boss.style.top);
            if (isNaN(bossTop)) { bossTop = 50; boss.style.top = `${bossTop}px`; }

            const startX = bossLeft + boss.offsetWidth / 2;
            const startY = bossTop + boss.offsetHeight / 2; 
            const numBullets = 10;
            const angleIncrement = (Math.PI * 2) / numBullets; 
            const baseSpeed = currentEnemyBulletSpeed * 0.8; 

            for (let i = 0; i < numBullets; i++) {
                const angle = i * angleIncrement;

                const dx = Math.cos(angle) * baseSpeed;
                const dy = Math.sin(angle) * baseSpeed;

                const bossBullet = document.createElement('div');
                bossBullet.classList.add('boss-bullet');
                bossBullet.style.left = `${startX - (15 / 2)}px`;
                bossBullet.style.top = `${startY - (15 / 2)}px`; 
                bossBullet.dataset.dx = dx;
                bossBullet.dataset.dy = dy;
                bossBullet.dataset.isShotgun = 'true'; // MARCA COMO TIRO DE SHOTGUN
                gameContainer.appendChild(bossBullet);
                bossBullets.push(bossBullet);
            }
        }

        /**
         * Atualiza a posição dos projéteis do boss e verifica colisões com o jogador.
         */
        function updateBossBullets() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                for (let i = bossBullets.length - 1; i >= 0; i--) { // Iterar de trás para frente
                    const bBullet = bossBullets[i];
                    if (!bBullet || !bBullet.parentNode) { // Verificação de nulidade
                        bossBullets.splice(i, 1);
                        continue;
                    }

                    let currentTop = parseFloat(bBullet.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; bBullet.style.top = `${currentTop}px`; }
                    let currentLeft = parseFloat(bBullet.style.left);
                    if (isNaN(currentLeft)) { currentLeft = 0; bBullet.style.left = `${currentLeft}px`; }
                    let dx = parseFloat(bBullet.dataset.dx);
                    if (isNaN(dx)) { dx = 0; }
                    let dy = parseFloat(bBullet.dataset.dy);
                    if (isNaN(dy)) { dy = 0; }

                    currentTop += dy;
                    currentLeft += dx;

                    // Lógica de ricochete APENAS para balas que NÃO SÃO de shotgun
                    if (bBullet.dataset.isShotgun !== 'true' && bBullet.dataset.dx !== '0') { 
                        if (currentLeft <= 0) {
                            currentLeft = 0; 
                            dx *= -1; 
                            bBullet.dataset.dx = dx; 
                        } else if (currentLeft + bBullet.offsetWidth >= gameContainer.offsetWidth) {
                            currentLeft = gameContainer.offsetWidth - bBullet.offsetWidth; 
                            dx *= -1; 
                            bBullet.dataset.dx = dx; 
                        }
                    }

                    bBullet.style.top = `${currentTop}px`;
                    bBullet.style.left = `${currentLeft}px`;

                    // Remove a bala se sair da tela (incluindo as de shotgun que não ricocheteiam)
                    if (currentTop > gameContainer.offsetHeight || currentLeft < -bBullet.offsetWidth || currentLeft > gameContainer.offsetWidth) {
                        if (bBullet.parentNode) bBullet.parentNode.removeChild(bBullet); // Remove do DOM
                        bossBullets.splice(i, 1);
                        continue;
                    }

                    const playerRect = player.getBoundingClientRect();
                    const bBulletRect = bBullet.getBoundingClientRect();

                    if (
                        bBulletRect.bottom > playerRect.top &&
                        bBulletRect.top < playerRect.bottom &&
                        bBulletRect.right > playerRect.left &&
                        bBulletRect.left < playerRect.right
                    ) {
                        if (bBullet.parentNode) bBullet.parentNode.removeChild(bBullet); // Remove do DOM
                        bossBullets.splice(i, 1);

                        let damageToApply = currentBossBulletDamage; 
                        if (isNaN(damageToApply)) { 
                            console.error("Calculated damageToApply is NaN in updateBossBullets. Defaulting to 0.");
                            damageToApply = 0;
                        }
                        
                        // Lógica de dano: Escudo > Sobrevida > Vida
                        if (shieldActive) {
                            shieldHealth -= damageToApply;
                            if (shieldHealth <= 0) {
                                const remainingDamage = Math.abs(shieldHealth); 
                                deactivateShield(); 
                                health = Math.max(0, health - remainingDamage); // Aplica o dano restante na vida/sobrevida
                            }
                        } else { // Sem escudo, aplica na vida/sobrevida
                            health = Math.max(0, health - damageToApply);
                        }
                        
                        updateHealthBarDisplay();
                        console.log("Atingido pelo boss! Vida restante: " + health + ", Escudo: " + shieldHealth);
                        if (health <= 0) {
                            showGameOverScreen(); 
                            return;
                        }
                        player.classList.add('player-hit-effect');
                        setTimeout(() => {
                            player.classList.remove('player-hit-effect');
                        }, 150); 
                    }
                }
            } catch (error) {
                console.error("Erro em updateBossBullets:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Lida com a derrota do boss, exibindo a tela de "Stage Clear".
         */
        function handleBossDefeated() {
            console.log('Entering handleBossDefeated(). Game state:', gameRunning, 'isBossFightActive:', isBossFightActive);
            gameRunning = false; // Primeiro, pare o jogo.
            cancelAnimationFrame(animationFrameId); // Cancele o loop de animação.
            
            clearGameElements(); // Limpa todos os elementos após a derrota do boss
            
            console.log('handleBossDefeated: gameRunning = false, isBossFightActive =', isBossFightActive); 

            score += 50; 
            scoreValueDisplay.textContent = score; 
            stageScoreDisplay.textContent = score; 

            bossLevel++; 
            playerLevel++; 
            updatePlayerStatsBasedOnLevel(); 
            
            nextBossScoreThreshold = score + Math.ceil(score * 0.5); 
            console.log("Próximo Boss em: " + nextBossScoreThreshold + " pontos.");

            stageClearScreen.classList.remove('hidden'); 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;
            console.log('Exiting handleBossDefeated(). Stage Clear Screen shown.');
        }

        /**
         * Atualiza a posição dos segmentos de fundo para criar rolagem infinita com rotação.
         */
        function updateBackgroundSegments() {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            try {
                backgroundSegments.forEach(segment => {
                    if (!segment) return; // Adicionado: Verificação de nulidade

                    const gameContainerHeight = gameContainer.offsetHeight; // Captura a altura dentro do loop para robustez
                    const scrollSpeed = backgroundMusic.paused ? 0 : backgroundScrollSpeed; // PAUSA O SCROLL SE A MÚSICA ESTIVER PAUSADA

                    let currentTop = parseFloat(segment.style.top);
                    if (isNaN(currentTop)) { currentTop = 0; segment.style.top = `${currentTop}px`; }
                    currentTop += scrollSpeed;
                    segment.style.top = `${currentTop}px`;

                    if (currentTop >= gameContainerHeight) { // Usa gameContainerHeight aqui
                        segment.style.top = `${currentTop - (gameContainerHeight * 2) - 1}px`; 
                        segment.classList.toggle('rotated-180'); 
                    }
                });
            } catch (error) {
                console.error("Erro em updateBackgroundSegments:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Atualiza o estado do escudo.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function updateShield(currentTime) {
            if (!gameRunning) return; // Adicionado: Verificação para evitar execução se o jogo não estiver rodando
            // A lógica de desativação está nos métodos de dano.
        }
        
        /**
         * Loop principal do jogo.
         * @param {DOMHighResTimeStamp} currentTime - O tempo atual.
         */
        function gameLoop(currentTime) {
            try {
                if (!gameRunning || gamePaused) {
                    return;
                }

                updateBackgroundSegments(); 
                updateShield(currentTime); 

                updateFallingObjects(currentTime); 
                updateEnemyBullets(); 
                updateObstacles(); 

                if (!isBossFightActive) {
                    if (currentTime - lastObjectSpawnTime > objectSpawnInterval) {
                        createFallingObject(currentTime); 
                        lastObjectSpawnTime = currentTime;
                    }

                    if (currentTime - lastObstacleSpawnTime > currentObstacleSpawnInterval) { 
                        createObstacle();
                        lastObstacleSpawnTime = currentTime;
                    }
                } else { 
                    updateBoss(currentTime);
                    updateBossBullets();
                    if (currentTime - lastBossPowerUpDropTime > bossFightPowerUpInterval) {
                        const dropType = Math.random() < 0.7 ? 'health_up' : 'shield'; 
                        const spawnX = Math.random() * (gameContainer.offsetWidth - 30); 
                        createCollectible(spawnX, 0, currentTime, dropType); 
                        lastBossPowerUpDropTime = currentTime;
                    }
                }

                updateCollectibles(currentTime);
                updateBossProgressBar(); 

                if (currentTime - lastShotTime > shootInterval) {
                    createBullet();
                    lastShotTime = currentTime;
                }

                updateBullets(); 
                updatePlayerPosition();
                animationFrameId = requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("Erro crítico no gameLoop:", error);
                if (gameRunning) showGameOverScreen(); 
            }
        }

        /**
         * Inicia o loop do jogo.
         */
        function startGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Exibe a tela de Fim de Jogo.
         */
        async function showGameOverScreen() {
            console.log('Entering showGameOverScreen(). Game state:', gameRunning);
            gameRunning = false; // Primeiro, pare o jogo.
            cancelAnimationFrame(animationFrameId); // Cancele o loop de animação.
            
            clearGameElements(); // Garante que todos os elementos sejam removidos ao game over
            
            finalScoreDisplay.textContent = score;
            backgroundMusic.pause(); 
            backgroundMusic.currentTime = 0; 
            bossMusic.pause(); 
            bossMusic.currentTime = 0;

            // Lógica de Ranking
            const highScores = await getHighScores();
            let isTop10 = false;
            if (highScores.length < 10) {
                isTop10 = true;
            } else {
                // Check if current score is higher than the lowest score in top 10
                const lowestTop10Score = highScores[highScores.length - 1].score;
                if (score > lowestTop10Score) {
                    isTop10 = true;
                }
            }

            if (isTop10) {
                gameOverScreen.classList.add('hidden'); // Esconde Game Over
                rankingScreen.classList.remove('hidden'); // Mostra Ranking
                nameInputForm.classList.remove('hidden'); // Mostra formulário de nome
                playerNameInput.value = ''; // Limpa o input
                playerNameInput.focus(); // Foca no input
                displayHighScores(highScores); // Exibe o ranking atual
            } else {
                gameOverScreen.classList.remove('hidden'); // Mostra Game Over
                // Se não for Top 10, mas queremos mostrar o ranking, podemos fazer isso aqui.
                // Por enquanto, apenas esconde o ranking se não for Top 10.
                rankingScreen.classList.add('hidden'); 
            }
            // Se o jogador não for top 10, ele ainda pode querer ver o ranking.
            // O botão "VER RANKING" na tela de Game Over cuidará disso.
            console.log('Exiting showGameOverScreen(). Game Over screen shown or ranking displayed.');
        }

        /**
         * Pausa o jogo.
         */
        async function pauseGame() { // Adicionado async
            if (gameRunning && !gamePaused) {
                gamePaused = true;
                cancelAnimationFrame(animationFrameId);
                pauseScreen.classList.remove('hidden');
                backgroundMusic.pause();
                bossMusic.pause();

                // Exibir ranking na tela de pausa
                const highScores = await getHighScores();
                displayPauseRanking(highScores);
            }
        }

        /**
         * Retoma o jogo.
         */
        function resumeGame() {
            if (gameRunning && gamePaused) {
                gamePaused = false;
                pauseScreen.classList.add('hidden');
                // Limpar ranking da tela de pausa
                if (pauseRankingDisplay) {
                    pauseRankingDisplay.innerHTML = '';
                }
                startGameLoop();
                if (isBossFightActive) {
                    bossMusic.play().catch(e => console.log("Erro ao tocar música do boss:", e));
                } else {
                    backgroundMusic.play().catch(e => console.log("Erro ao tocar música de fundo:", e));
                }
            }
        }

        // --- Firestore Functions ---

        /**
         * Salva uma nova pontuação no Firestore.
         * @param {string} name - Nome do jogador.
         * @param {number} score - Pontuação do jogador.
         */
        async function saveHighScore(name, score) {
            if (!userId) {
                console.error("User not authenticated. Cannot save high score.");
                // Exibe uma mensagem para o usuário se não estiver autenticado
                const messageBox = document.createElement('div');
                messageBox.style.cssText = `
                    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background-color: #333; color: white; padding: 20px; border-radius: 10px;
                    font-family: 'Press Start 2P', cursive; text-align: center; z-index: 100;
                    box-shadow: 0 0 10px rgba(0,0,0,0.5);
                `;
                messageBox.innerHTML = `
                    <p>Erro: Não foi possível autenticar. Verifique sua conexão ou tente novamente.</p>
                    <button style="margin-top: 10px; padding: 5px 10px; background-color: #f6e05e; color: #1a202c; border: none; border-radius: 5px; cursor: pointer;">OK</button>
                `;
                document.body.appendChild(messageBox);
                messageBox.querySelector('button').addEventListener('click', () => {
                    messageBox.remove();
                });
                return;
            }
            try {
                // Use o appId para criar um caminho de coleção único para este aplicativo.
                const scoresCollectionRef = collection(db, `artifacts/${appId}/public/data/highScores`);
                await addDoc(scoresCollectionRef, {
                    name: name,
                    score: score,
                    timestamp: Date.now(), // Para ordenar por data, se necessário
                    userId: userId // Armazena o ID do usuário
                });
                console.log("High score saved successfully!");
                // Após salvar, atualiza a lista de pontuações
                const updatedHighScores = await getHighScores();
                displayHighScores(updatedHighScores);
                nameInputForm.classList.add('hidden'); // Esconde o formulário após o envio
            } catch (e) {
                console.error("Error adding document: ", e);
                const messageBox = document.createElement('div');
                messageBox.style.cssText = `
                    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background-color: #333; color: white; padding: 20px; border-radius: 10px;
                    font-family: 'Press Start 2P', cursive; text-align: center; z-index: 100;
                    box-shadow: 0 0 10px rgba(0,0,0,0.5);
                `;
                messageBox.innerHTML = `
                    <p>Erro ao salvar pontuação: ${e.message}.</p>
                    <button style="margin-top: 10px; padding: 5px 10px; background-color: #f6e05e; color: #1a202c; border: none; border-radius: 5px; cursor: pointer;">OK</button>
                `;
                document.body.appendChild(messageBox);
                messageBox.querySelector('button').addEventListener('click', () => {
                    messageBox.remove();
                });
            }
        }

        /**
         * Busca as 10 maiores pontuações do Firestore.
         * @returns {Array<Object>} Um array de objetos de pontuação.
         */
        async function getHighScores() {
            try {
                const scoresCollectionRef = collection(db, `artifacts/${appId}/public/data/highScores`);
                // Ordena por score em ordem decrescente e limita a 10 resultados
                const q = query(scoresCollectionRef, orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                const scores = [];
                querySnapshot.forEach((doc) => {
                    scores.push(doc.data());
                });
                return scores;
            } catch (e) {
                console.error("Error getting documents: ", e);
                const messageBox = document.createElement('div');
                messageBox.style.cssText = `
                    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background-color: #333; color: white; padding: 20px; border-radius: 10px;
                    font-family: 'Press Start 2P', cursive; text-align: center; z-index: 100;
                    box-shadow: 0 0 10px rgba(0,0,0,0.5);
                `;
                messageBox.innerHTML = `
                    <p>Erro ao carregar ranking: ${e.message}.</p>
                    <button style="margin-top: 10px; padding: 5px 10px; background-color: #f6e05e; color: #1a202c; border: none; border-radius: 5px; cursor: pointer;">OK</button>
                `;
                document.body.appendChild(messageBox);
                messageBox.querySelector('button').addEventListener('click', () => {
                    messageBox.remove();
                });
                return [];
            }
        }

        /**
         * Exibe as pontuações na lista de ranking principal (tela de Game Over/Ranking).
         * @param {Array<Object>} scores - Array de objetos de pontuação.
         */
        function displayHighScores(scores) {
            highScoresList.innerHTML = ''; // Limpa a lista anterior
            if (scores.length === 0) {
                const li = document.createElement('li');
                li.textContent = "Nenhuma pontuação ainda.";
                highScoresList.appendChild(li);
                return;
            }
            scores.forEach((scoreData, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${index + 1}. ${scoreData.name || 'Anônimo'}</span><span>${scoreData.score}</span>`;
                highScoresList.appendChild(li);
            });
        }

        /**
         * Exibe as pontuações na lista de ranking da tela de pausa.
         * @param {Array<Object>} scores - Array de objetos de pontuação.
         */
        function displayPauseRanking(scores) {
            if (!pauseRankingDisplay) return; // Garante que o elemento existe
            pauseRankingDisplay.innerHTML = ''; // Limpa a lista anterior
            const title = document.createElement('p');
            title.textContent = "TOP PONTUAÇÕES";
            title.style.cssText = "font-size: 0.9rem; color: #cbd5e0; margin-bottom: 0.5rem; text-shadow: none;";
            pauseRankingDisplay.appendChild(title);

            if (scores.length === 0) {
                const li = document.createElement('li');
                li.textContent = "Nenhuma pontuação.";
                li.style.cssText = "font-size: 0.7rem; justify-content: center;";
                pauseRankingDisplay.appendChild(li);
                return;
            }
            scores.forEach((scoreData, index) => {
                if (index >= 5) return; // Limita a 5 itens para não sobrecarregar a tela de pausa
                const li = document.createElement('li');
                li.innerHTML = `<span>${index + 1}. ${scoreData.name || 'Anônimo'}</span><span>${scoreData.score}</span>`;
                li.style.cssText = "font-size: 0.7rem;"; // Tamanho de fonte menor para a pausa
                pauseRankingDisplay.appendChild(li);
            });
        }

        /**
         * Configura todos os event listeners e obtém referências aos elementos DOM.
         * Chamado no window.onload para garantir que todos os elementos estejam disponíveis.
         */
        function setupEventListeners() {
            // Reatribuição das referências DOM (agora dentro de uma função chamada no onload)
            gameContainer = document.getElementById('gameContainer');
            player = document.getElementById('player');
            scoreValueDisplay = document.getElementById('scoreValue'); 
            playerDamageDisplay = document.getElementById('playerDamageDisplay'); 
            playerLevelDisplay = document.getElementById('playerLevelDisplay'); 
            gameOverScreen = document.getElementById('gameOverScreen');
            finalScoreDisplay = document.getElementById('finalScore');
            restartButton = document.getElementById('restartButton');
            startScreen = document.getElementById('startScreen');
            stageClearScreen = document.getElementById('stageClearScreen'); 
            continueButton = document.getElementById('continueButton');   
            pauseButton = document.getElementById('pauseButton'); 
            pauseScreen = document.getElementById('pauseScreen'); 

            playerHealthBar = document.getElementById('playerHealthBar'); 
            healthFill = document.getElementById('healthFill'); 
            overshieldFill = document.getElementById('overshieldFill'); 
            playerHealthText = document.getElementById('playerHealthText'); 

            shieldHealthBar = document.getElementById('shieldHealthBar'); 
            shieldHealthFill = document.getElementById('shieldHealthFill');
            shieldHealthText = document.getElementById('shieldHealthText');

            bossProgressText = document.getElementById('bossProgressText');
            bossProgressFill = document.getElementById('bossProgressFill');

            pressStartText = document.getElementById('pressStartText'); 
            pauseContinueText = document.getElementById('pauseContinueText'); 

            rankingScreen = document.getElementById('rankingScreen');
            highScoresList = document.getElementById('highScoresList');
            nameInputForm = document.getElementById('nameInputForm');
            playerNameInput = document.getElementById('playerNameInput');
            submitScoreButton = document.getElementById('submitScoreButton');
            rankingPlayAgainButton = document.getElementById('rankingPlayAgainButton');
            showRankingButton = document.getElementById('showRankingButton'); 
            pauseRankingDisplay = document.getElementById('pauseRankingDisplay'); // Obtenção da referência

            // --- Eventos de Controle ---

            // Controle de Toque (Celular)
            gameContainer.addEventListener('touchstart', (e) => {
                if (!gameRunning || gamePaused) return;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY; 
                playerMoving = true;
            });

            gameContainer.addEventListener('touchmove', (e) => {
                if (!gameRunning || !playerMoving || gamePaused) return;
                const touchCurrentX = e.touches[0].clientX;
                const touchCurrentY = e.touches[0].clientY; 
                const deltaX = touchCurrentX - touchStartX;
                const deltaY = touchCurrentY - touchStartY; 
                
                playerX += deltaX * 1.0; 
                playerX = Math.max(0, Math.min(playerX, gameContainer.offsetWidth - player.offsetWidth));

                playerY += deltaY * 1.0; 
                playerY = Math.max(0, Math.min(playerY, gameContainer.offsetHeight - player.offsetHeight));

                updatePlayerPosition();
                touchStartX = touchCurrentX;
                touchStartY = touchCurrentY; 
            });

            gameContainer.addEventListener('touchend', () => {
                playerMoving = false;
            });

            // Controle de Teclado (Desktop)
            document.addEventListener('keydown', (e) => {
                if (!gameRunning || gamePaused) return;
                if (e.key === 'ArrowLeft') {
                    playerX = Math.max(0, playerX - playerSpeed * 2);
                } else if (e.key === 'ArrowRight') {
                    playerX = Math.min(gameContainer.offsetWidth - player.offsetWidth, playerX + playerSpeed * 2);
                } else if (e.key === 'ArrowUp') { 
                    playerY = Math.max(0, playerY - playerSpeed * 2); 
                } else if (e.key === 'ArrowDown') { 
                    playerY = Math.min(gameContainer.offsetHeight - player.offsetHeight, playerY + playerSpeed * 2); 
                } else if (e.key === 'p' || e.key === 'P') { 
                    pauseGame();
                }
                updatePlayerPosition();
            });

            // Botão Reiniciar (na tela de Game Over)
            restartButton.addEventListener('click', initializeGame);
            
            // Evento no div startScreen para iniciar o jogo (qualquer toque/clique)
            startScreen.addEventListener('click', () => { 
                initializeGame();
                toggleFullScreen(); 
            }); 
            
            // Botão Continuar para a tela de Stage Clear
            continueButton.addEventListener('click', () => {
                startNextStage();
                toggleFullScreen(); 
            }); 

            // Botão de Pausa
            pauseButton.addEventListener('click', pauseGame);
            
            // Evento no div pauseScreen para retomar o jogo (qualquer toque/clique)
            pauseScreen.addEventListener('click', () => { 
                resumeGame();
            });

            // Botão de Enviar Pontuação (na tela de Ranking)
            submitScoreButton.addEventListener('click', () => {
                const playerName = playerNameInput.value.trim();
                if (playerName) {
                    saveHighScore(playerName, score);
                } else {
                    // Substitua alert() por um modal customizado no jogo real
                    const messageBox = document.createElement('div');
                    messageBox.style.cssText = `
                        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background-color: #333; color: white; padding: 20px; border-radius: 10px;
                        font-family: 'Press Start 2P', cursive; text-align: center; z-index: 100;
                        box-shadow: 0 0 10px rgba(0,0,0,0.5);
                    `;
                    messageBox.innerHTML = `
                        <p>Por favor, insira seu nome!</p>
                        <button style="margin-top: 10px; padding: 5px 10px; background-color: #f6e05e; color: #1a202c; border: none; border-radius: 5px; cursor: pointer;">OK</button>
                    `;
                    document.body.appendChild(messageBox);
                    messageBox.querySelector('button').addEventListener('click', () => {
                        messageBox.remove();
                    });
                }
            });

            // Botão Jogar Novamente (na tela de Ranking)
            rankingPlayAgainButton.addEventListener('click', initializeGame);

            // Evento para mostrar o ranking (botão na tela de Game Over)
            showRankingButton.addEventListener('click', async () => {
                gameOverScreen.classList.add('hidden');
                rankingScreen.classList.remove('hidden');
                nameInputForm.classList.add('hidden'); // Esconde o formulário ao apenas visualizar o ranking
                const highScores = await getHighScores();
                displayHighScores(highScores);
            });

            // Botão para voltar ao início da tela de ranking
            backToStartScreenButton.addEventListener('click', () => {
                rankingScreen.classList.add('hidden');
                startScreen.classList.remove('hidden');
            });
        }


        // Exibe a tela inicial ao carregar
        window.onload = async () => {
            // Configura os event listeners e obtém as referências DOM primeiro
            setupEventListeners();
            // Em seguida, inicializa o Firebase e a autenticação
            // A autenticação Firebase já é tratada pelo onAuthStateChanged que é disparado na inicialização do app.
            // Não precisamos de uma função initializeFirebaseAndAuth separada aqui, pois a lógica já está no script type="module".

            startScreen.classList.remove('hidden');
            gameOverScreen.classList.add('hidden'); 
            stageClearScreen.classList.add('hidden'); 
            pauseScreen.classList.add('hidden'); 
            rankingScreen.classList.add('hidden'); 
            nameInputForm.classList.add('hidden'); 
            gameRunning = false; 
            gamePaused = false; 
        };
    </script>
</body>
</html>
